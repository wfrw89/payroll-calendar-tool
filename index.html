<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payroll Calendar Generator v4.0</title>

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-purple: #6B69D6;
            --primary-purple-light: #8B89E5;
            --success-teal: #0FA47F;
            --success-teal-light: #14B98F;
            --warning-yellow: #F59E0B;
            --warning-orange: #F97316;
            --danger-red: #eb5757;
            --text-dark: #37352f;
            --text-medium: #787774;
            --text-light: #9B9A97;
            --bg-main: #fafafa;
            --bg-card: #ffffff;
            --border-light: #e5e5e4;
            --border-medium: #d3d3d1;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 48px 24px;
            color: var(--text-dark);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            animation: fadeIn 0.5s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 56px;
        }

        .header h1 {
            font-size: 44px;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 12px;
            letter-spacing: -0.04em;
            background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-medium);
            font-size: 17px;
            font-weight: 400;
        }

        .card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 36px;
            margin-bottom: 28px;
            border: 1px solid var(--border-light);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: fadeIn 0.6s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .card-header {
            font-size: 19px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 28px;
            padding-bottom: 18px;
            border-bottom: 2px solid #f1f1f0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .card-header::before {
            content: '';
            width: 5px;
            height: 24px;
            background: linear-gradient(180deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            border-radius: 3px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 28px;
            margin-bottom: 24px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dark);
        }

        .form-group input:not([type="checkbox"]),
        .form-group select {
            padding: 12px 16px;
            border: 1.5px solid var(--border-light);
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            background: var(--bg-card);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--text-dark);
            height: 48px;
            line-height: 1.5;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: none;
        }

        .form-group select {
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='8' viewBox='0 0 12 8' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1.5L6 6.5L11 1.5' stroke='%23666' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
            padding-right: 40px;
        }

        .form-group input:not([type="checkbox"]):focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary-purple);
            box-shadow: 0 0 0 4px rgba(107, 105, 214, 0.1);
            transform: translateY(-1px);
        }

        .form-group input:not([type="checkbox"]):hover:not(:focus),
        .form-group select:hover:not(:focus) {
            border-color: var(--border-medium);
        }

        /* Checkbox Styling */
        .form-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary-purple);
            margin: 0;
            flex-shrink: 0;
        }

        .form-group input[type="checkbox"]:focus {
            outline: 2px solid var(--primary-purple);
            outline-offset: 2px;
        }

        .form-group input[type="checkbox"]:hover {
            opacity: 0.8;
        }

        .help-text {
            font-size: 13px;
            color: var(--text-medium);
            margin-top: 4px;
        }

        .button-group {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            margin-top: 28px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 0.01em;
        }

        button:active {
            transform: scale(0.98);
        }

        button.primary {
            background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(107, 105, 214, 0.25);
        }

        button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(107, 105, 214, 0.35);
        }

        button.secondary {
            background: #f1f1f0;
            color: var(--text-dark);
        }

        button.secondary:hover {
            background: #e5e5e4;
            transform: translateY(-1px);
        }

        button.success {
            background: linear-gradient(135deg, var(--success-teal) 0%, var(--success-teal-light) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(15, 164, 127, 0.25);
        }

        button.success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(15, 164, 127, 0.35);
        }

        button.danger {
            background: var(--danger-red);
            color: white;
        }

        button.danger:hover {
            background: #d13636;
            transform: translateY(-1px);
        }

        button.small {
            padding: 7px 16px;
            font-size: 13px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .task-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 24px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .task-table th {
            text-align: left;
            font-size: 12px;
            font-weight: 700;
            color: var(--text-medium);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            padding: 16px 18px;
            background: #fafafa;
            border-bottom: 2px solid var(--border-light);
        }

        .task-table td {
            padding: 18px;
            border-bottom: 1px solid #f7f7f7;
            font-size: 15px;
            vertical-align: middle;
            background: white;
        }

        .task-table tr:last-child td {
            border-bottom: none;
        }

        .task-table tr:hover td {
            background: #fafafa;
        }

        .task-row.core td {
            background: #f0f9f7;
        }

        .task-row.core:hover td {
            background: #e6f4f0;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--success-teal) 0%, var(--success-teal-light) 100%);
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(15, 164, 127, 0.2);
        }

        .task-name-cell {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
        }

        .task-offset-input {
            width: 90px;
            padding: 8px 12px;
            border: 1.5px solid var(--border-light);
            border-radius: 6px;
            font-size: 15px;
            text-align: center;
            font-family: inherit;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .task-offset-input:focus {
            outline: none;
            border-color: var(--primary-purple);
            box-shadow: 0 0 0 3px rgba(107, 105, 214, 0.1);
        }

        .add-task-row {
            display: flex;
            gap: 14px;
            margin-top: 24px;
            align-items: stretch;
        }

        .add-task-row input {
            padding: 12px 16px;
            border: 1.5px solid var(--border-light);
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .add-task-row input:focus {
            outline: none;
            border-color: var(--primary-purple);
            box-shadow: 0 0 0 4px rgba(107, 105, 214, 0.1);
        }

        .add-task-row input:first-child {
            flex: 1;
        }

        .add-task-row input[type="number"] {
            width: 140px;
            text-align: center;
            font-weight: 600;
        }

        .calendar-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 24px;
            font-size: 14px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            table-layout: fixed;
        }

        .calendar-table th {
            background: linear-gradient(135deg, #2d2c2f 0%, #37352f 100%);
            color: white;
            padding: 18px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .calendar-table th:last-child {
            border-right: none;
        }

        .calendar-table th:not(:first-child) {
            text-align: center;
        }

        .calendar-table th:first-child,
        .calendar-table td:first-child {
            width: 150px;
        }

        .calendar-table th:last-child,
        .calendar-table td:last-child {
            width: 400px;
        }

        /* Task columns (not first or last) - ensure enough width for month abbreviations */
        .calendar-table th:not(:first-child):not(:last-child),
        .calendar-table td:not(:first-child):not(:last-child) {
            min-width: 150px; /* Increased to prevent "25 Sept" wrapping on any display */
        }

        .calendar-table td {
            padding: 18px 16px;
            border-bottom: 1px solid #f1f1f0;
            border-right: 1px solid #f7f7f7;
            text-align: center;
            vertical-align: top;
            background: white;
        }

        .calendar-table td:first-child {
            text-align: left;
            font-weight: 600;
            background: #fafafa;
        }

        .calendar-table td:last-child {
            text-align: left;
            background: #fffef5;
            font-size: 13px;
            line-height: 1.7;
        }

        .calendar-table tr:hover td {
            background: #f7f8f9;
        }

        .calendar-table tr:hover td:first-child {
            background: #f0f0f0;
        }

        .calendar-table tr:hover td:last-child {
            background: #fff9e6;
        }

        .calendar-table tr:last-child td {
            border-bottom: none;
        }

        .period-label {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0;
        }

        .holiday-indicator {
            width: 10px;
            height: 10px;
            background: var(--warning-yellow);
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
            animation: pulse 2s ease-in-out infinite;
            flex-shrink: 0;
        }

        .adjustment-indicator {
            width: 10px;
            height: 10px;
            background: var(--warning-orange);
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
            animation: pulse 2s ease-in-out infinite;
            flex-shrink: 0;
            margin-left: 4px;
        }

        .override-indicator {
            font-size: 14px;
            margin-right: 6px;
            display: inline-block;
        }

        .date-display {
            font-weight: 600;
            display: block;
            color: var(--text-dark);
            font-size: 15px;
        }

        .day-display {
            font-size: 12px;
            color: var(--text-medium);
            display: block;
            margin-top: 4px;
            font-weight: 500;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 24px;
        }

        .config-card {
            background: linear-gradient(135deg, #fafafa 0%, #f7f7f7 100%);
            border: 1.5px solid var(--border-light);
            border-radius: 10px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .config-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .config-card:hover {
            background: white;
            border-color: var(--primary-purple);
            box-shadow: var(--shadow-lg);
            transform: translateY(-4px);
        }

        .config-card:hover::before {
            transform: scaleX(1);
        }

        .config-card h3 {
            font-size: 17px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 14px;
        }

        .config-card p {
            font-size: 13px;
            color: var(--text-medium);
            margin-bottom: 6px;
        }

        .config-actions {
            display: flex;
            gap: 10px;
            margin-top: 18px;
        }

        .message {
            padding: 16px 20px;
            border-radius: 8px;
            margin-top: 24px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: fadeIn 0.3s ease;
            font-weight: 500;
        }

        .message::before {
            content: '';
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .message.success {
            background: linear-gradient(135deg, #d3f9d8 0%, #c1f5c8 100%);
            color: #0f5132;
            border: 1.5px solid #a3cfbb;
        }

        .message.success::before {
            content: 'âœ“';
            background: var(--success-teal);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .message.error {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c2c7 100%);
            color: #721c24;
            border: 1.5px solid #f1aeb5;
        }

        .message.error::before {
            content: '!';
            background: var(--danger-red);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .message.loading {
            background: linear-gradient(135deg, #e7f3ff 0%, #d4e9ff 100%);
            color: #052c65;
            border: 1.5px solid #9ec5fe;
        }

        .message.loading::before {
            content: '';
            border: 2px solid var(--primary-purple);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .hidden {
            display: none;
        }

        #payDateConfig {
            margin-top: 20px;
            padding: 24px;
            background: linear-gradient(135deg, #fafafa 0%, #f7f7f7 100%);
            border-radius: 10px;
            border: 1.5px solid var(--border-light);
        }

        .cutoff-mode-selector {
            margin-top: 20px;
            padding: 24px;
            background: linear-gradient(135deg, #f8f3ff 0%, #f5f0ff 100%);
            border-radius: 10px;
            border: 1.5px solid #e5d9ff;
            box-shadow: var(--shadow-sm);
        }

        .cutoff-mode-selector label {
            display: block;
            margin-bottom: 16px;
            font-weight: 600;
            color: var(--text-dark);
            font-size: 15px;
        }

        .radio-group {
            display: flex;
            gap: 28px;
            margin-bottom: 20px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .radio-option:hover {
            transform: translateX(2px);
        }

        .radio-option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--primary-purple);
        }

        .radio-option label {
            cursor: pointer;
            margin: 0;
            font-weight: 500;
            font-size: 14px;
        }

        .cutoff-config {
            margin-top: 20px;
        }

        .legend {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 16px;
            background: #fafafa;
            border-radius: 8px;
            flex-wrap: wrap;
            gap: 16px;
        }

        .legend-items {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-medium);
        }

        .add-offcycle-btn {
            background: var(--primary-purple);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .add-offcycle-btn:hover {
            background: var(--primary-purple-light);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .add-offcycle-btn:active {
            transform: translateY(0);
        }

        @media (max-width: 768px) {
            body {
                padding: 24px 16px;
            }

            .header h1 {
                font-size: 32px;
            }

            .card {
                padding: 24px;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .add-task-row {
                flex-direction: column;
            }

            .add-task-row input[type="number"] {
                width: 100%;
            }

            .calendar-table {
                font-size: 12px;
            }

            .calendar-table th,
            .calendar-table td {
                padding: 12px 10px;
            }

            .button-group {
                flex-direction: column;
            }

            .button-group button {
                width: 100%;
                justify-content: center;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Calendar Day Picker Styles */
        .day-picker {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-top: 12px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--border-medium);
            max-width: 280px;
            box-shadow: var(--shadow-sm);
        }

        .day-picker-button {
            padding: 8px 6px;
            background: white;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-dark);
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-picker-button:hover {
            background: var(--primary-purple-light);
            color: white;
            border-color: var(--primary-purple);
        }

        .day-picker-button.selected {
            background: var(--primary-purple);
            color: white;
            border-color: var(--primary-purple);
            font-weight: 600;
            box-shadow: 0 0 0 2px rgba(107, 105, 214, 0.2);
        }

        .day-picker-button.last-day {
            grid-column: span 7;
            background: var(--success-teal);
            color: white;
            border-color: var(--success-teal);
            font-weight: 600;
            padding: 10px;
            font-size: 12px;
        }

        .day-picker-button.last-day:hover {
            background: var(--success-teal-light);
            border-color: var(--success-teal-light);
        }

        .day-picker-button.last-day.selected {
            background: var(--success-teal);
            box-shadow: 0 0 0 2px rgba(15, 164, 127, 0.2);
        }

        .day-picker-label {
            font-size: 13px;
            color: var(--text-medium);
            margin-bottom: 6px;
            font-weight: 500;
        }

        /* Icon Button Styles */
        .icon-button {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-medium);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .icon-button:hover {
            background: var(--primary-purple-light);
            color: white;
        }

        /* Clock Icon Button Styles */
        .clock-icon-button {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: #D3D3D1;  /* Faint grey by default */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .clock-icon-button:hover {
            color: var(--text-medium);
            background: rgba(0, 0, 0, 0.05);
        }

        .clock-icon-button.has-time {
            color: #000000;  /* Black when time is set */
        }

        .clock-icon-button.has-time:hover {
            color: var(--primary-purple);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lg);
            animation: fadeIn 0.3s ease;
        }

        .modal h3 {
            margin-bottom: 20px;
            color: var(--text-dark);
            font-size: 22px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            justify-content: flex-end;
        }

        /* Chrome-Style Tab Styles */
        .tab-container {
            display: flex;
            gap: 4px;
            margin-bottom: -1px;
        }

        .tab-button {
            position: relative;
            padding: 12px 24px;
            background: #E8EAED;
            border: none;
            border-radius: 12px 12px 0 0;
            color: var(--text-medium);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s ease;
            box-shadow: none;
        }

        .tab-button:hover:not(.active) {
            background: #D3D6DA;
        }

        .tab-button.active {
            background: white;
            color: var(--text-dark);
            box-shadow:
                0 -2px 4px rgba(0, 0, 0, 0.05),
                0 0 0 1px rgba(0, 0, 0, 0.05);
            z-index: 1;
        }

        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: white;
        }

        .tab-panel {
            display: none;
            background: white;
            padding: 24px 32px;
            margin: 0 -32px -32px -32px;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 -1px 0 rgba(0, 0, 0, 0.05);
        }

        .tab-panel.active {
            display: block;
        }

        .section-divider {
            border-top: 1px solid var(--border-light);
            margin: 20px 0;
            padding-top: 20px;
        }

        /* Off-Cycle Wizard Styles (v4.0) */
        .wizard-modal {
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .wizard-progress {
            display: flex;
            justify-content: space-between;
            margin-bottom: 32px;
            padding: 0 20px;
        }

        .wizard-step {
            flex: 1;
            text-align: center;
            position: relative;
        }

        .wizard-step:not(:last-child)::after {
            content: '';
            position: absolute;
            top: 18px;
            left: 50%;
            width: 100%;
            height: 2px;
            background: var(--border-light);
            z-index: 0;
        }

        .wizard-step.active:not(:last-child)::after {
            background: var(--primary-purple);
        }

        .wizard-step-number {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--border-light);
            color: var(--text-medium);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
        }

        .wizard-step.active .wizard-step-number {
            background: var(--primary-purple);
            color: white;
        }

        .wizard-step.completed .wizard-step-number {
            background: var(--success-teal);
            color: white;
        }

        .wizard-step-label {
            font-size: 12px;
            color: var(--text-medium);
            font-weight: 500;
        }

        .wizard-step.active .wizard-step-label {
            color: var(--primary-purple);
            font-weight: 600;
        }

        .wizard-content {
            min-height: 300px;
            max-height: 50vh;
            overflow-y: auto;
            margin-bottom: 24px;
            flex: 1;
        }

        .wizard-panel {
            display: none;
        }

        .wizard-panel.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .wizard-buttons {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            padding-top: 24px;
            border-top: 1px solid var(--border-light);
        }

        .option-card {
            border: 2px solid var(--border-light);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .option-card:hover {
            border-color: var(--primary-purple-light);
            background: #f8f7ff;
        }

        .option-card.selected {
            border-color: var(--primary-purple);
            background: #f0efff;
        }

        .option-card h4 {
            margin: 0 0 8px 0;
            color: var(--text-dark);
            font-size: 16px;
        }

        .option-card p {
            margin: 0;
            color: var(--text-medium);
            font-size: 13px;
        }

        .period-selector {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 12px;
        }

        .period-checkbox {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .period-checkbox:hover {
            background: #fafafa;
        }

        .period-checkbox input[type="checkbox"] {
            margin-right: 12px;
        }

        .offcycle-row {
            background: #FEF3C7 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Payroll Calendar Generator <span style="font-size: 0.6em; color: var(--primary-purple); font-weight: 600;">v4.0</span></h1>
            <p>Create accurate payroll calendars with bank holidays and working day calculations</p>
        </div>

        <!-- Saved Configurations -->
        <div class="card">
            <div class="card-header">Saved Configurations</div>
            <div id="savedConfigs" class="config-grid">
                <p style="color: var(--text-medium);">No saved configurations yet. Create one below!</p>
            </div>
        </div>

        <!-- Client Information -->
        <div class="card">
            <div class="card-header">Client Information</div>
            <div class="form-row">
                <div class="form-group">
                    <label for="clientName">Client Name</label>
                    <input type="text" id="clientName" placeholder="Enter client name">
                </div>
                <div class="form-group">
                    <label for="employeeCountry">Employee Country</label>
                    <select id="employeeCountry">
                        <option value="">Select country...</option>
                    </select>
                    <span class="help-text">Country where employees are being paid</span>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="providerCountry">Payroll Provider Country <span style="color: var(--text-light); font-weight: 400; font-size: 13px;">(Optional)</span></label>
                    <select id="providerCountry">
                        <option value="">Select country...</option>
                    </select>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 12px;">
                        <input type="checkbox" id="providerCountryImpact" checked>
                        <label for="providerCountryImpact" style="font-size: 14px; font-weight: 400; cursor: pointer; margin: 0;">Bank holidays in this country impact task dates</label>
                    </div>
                    <span class="help-text">Your payroll team's location</span>
                </div>
                <div class="form-group">
                    <label for="clientTeamCountry">Client Payroll Team Country <span style="color: var(--text-light); font-weight: 400; font-size: 13px;">(Optional)</span></label>
                    <select id="clientTeamCountry">
                        <option value="">Select country...</option>
                    </select>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 12px;">
                        <input type="checkbox" id="clientTeamCountryImpact" checked>
                        <label for="clientTeamCountryImpact" style="font-size: 14px; font-weight: 400; cursor: pointer; margin: 0;">Bank holidays in this country impact task dates</label>
                    </div>
                    <span class="help-text">Client team's location</span>
                </div>
            </div>
        </div>

        <!-- Pay Frequency Configuration -->
        <div class="card">
            <div class="card-header">Pay Frequency Configuration</div>
            <div class="form-row">
                <div class="form-group">
                    <label for="payFrequency">Pay Frequency</label>
                    <select id="payFrequency" onchange="updatePayDateConfig()">
                        <option value="">Select frequency...</option>
                        <option value="monthly">Monthly</option>
                        <option value="semi-monthly">Semi-Monthly (twice per month)</option>
                        <option value="bi-weekly">Bi-Weekly (every 2 weeks)</option>
                        <option value="weekly">Weekly</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="calendarYear">Calendar Year</label>
                    <input type="number" id="calendarYear" min="2024" max="2030" value="2025">
                </div>
            </div>

            <div id="payDateConfig" class="hidden"></div>

            <div id="cutoffConfig" class="cutoff-mode-selector hidden">
                <label>Payroll Cut-Off Configuration</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="cutoffByDate" name="cutoffMode" value="date" onchange="updateCutoffMode()">
                        <label for="cutoffByDate">Specific Date</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="cutoffByOffset" name="cutoffMode" value="offset" checked onchange="updateCutoffMode()">
                        <label for="cutoffByOffset">Working Days Before Pay Date</label>
                    </div>
                </div>
                <div id="cutoffModeConfig" class="cutoff-config"></div>
            </div>
        </div>

        <!-- Payroll Tasks -->
        <div class="card">
            <div class="card-header" style="margin-bottom: 16px;">Payroll Tasks</div>
            <p class="help-text" style="margin-bottom: 24px;">
                Configure your payroll timeline. Set the cut-off date, then each subsequent task is calculated as working days after the previous milestone. If tasks overrun the pay date, the system will automatically adjust intermediate milestones.
            </p>

            <div class="form-group" style="margin-bottom: 24px; max-width: 400px;">
                <label for="calendarTimezone">Timezone for Due Times (Optional)</label>
                <select id="calendarTimezone" onchange="onTimezoneChange()">
                    <option value="">No timezone (times only)</option>
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Eastern Time (ET)</option>
                    <option value="America/Chicago">Central Time (CT)</option>
                    <option value="America/Denver">Mountain Time (MT)</option>
                    <option value="America/Los_Angeles">Pacific Time (PT)</option>
                    <option value="Europe/London">London (GMT/BST)</option>
                    <option value="Europe/Paris">Central European Time (CET)</option>
                    <option value="Europe/Berlin">Berlin (CET)</option>
                    <option value="Asia/Dubai">Dubai (GST)</option>
                    <option value="Asia/Singapore">Singapore (SGT)</option>
                    <option value="Asia/Hong_Kong">Hong Kong (HKT)</option>
                    <option value="Asia/Tokyo">Tokyo (JST)</option>
                    <option value="Australia/Sydney">Sydney (AEDT/AEST)</option>
                </select>
                <span class="help-text">Select timezone for task due times. Click the clock icon next to each task to set a specific due time.</span>
            </div>

            <div style="display: flex; justify-content: flex-end; margin-bottom: 12px;">
                <button class="secondary small" onclick="openConstraintsModal()" style="display: flex; align-items: center; gap: 8px;">
                    <span>Advanced Task Rules</span>
                    <span id="constraintsBadge" style="display: none; background: var(--warning-orange); color: white; font-size: 11px; font-weight: 700; padding: 2px 6px; border-radius: 10px; min-width: 18px; text-align: center;">0</span>
                </button>
            </div>

            <table class="task-table">
                <thead>
                    <tr>
                        <th>Task Name</th>
                        <th style="text-align: center; width: 100px;">Mandatory</th>
                        <th style="text-align: center;">Working Days</th>
                        <th>Description</th>
                        <th style="width: 150px; text-align: center;">Actions</th>
                    </tr>
                </thead>
                <tbody id="taskList"></tbody>
            </table>

            <div class="add-task-row">
                <select id="newTaskTemplate" onchange="populateTaskName()" style="flex: 1; padding: 12px 16px; border: 1.5px solid var(--border-light); border-radius: 8px; font-size: 15px;">
                    <option value="">-- Select pre-made task or enter custom --</option>
                    <option value="Updated Reports Due">Updated Reports Due</option>
                    <option value="Value Date on Bank File">Value Date on Bank File</option>
                    <option value="Payslips Available on Portal">Payslips Available on Portal</option>
                    <option value="3rd Party Payments">3rd Party Payments</option>
                    <option value="custom">Custom task...</option>
                </select>
                <input type="text" id="newTaskName" placeholder="Or type custom task name" style="flex: 1; display: none;">
                <input type="number" id="newTaskOffset" placeholder="Days" value="1" min="0">
                <select id="newTaskPosition" style="width: 100px; padding: 12px 16px; border: 1.5px solid var(--border-light); border-radius: 8px; font-size: 15px;">
                    <option value="after">After</option>
                    <option value="before">Before</option>
                </select>
                <select id="newTaskRelativeTo" style="flex: 1; padding: 12px 16px; border: 1.5px solid var(--border-light); border-radius: 8px; font-size: 15px;">
                    <!-- Populated dynamically -->
                </select>
                <button class="primary" onclick="addTask()">+ Add Task</button>
            </div>
        </div>

        <!-- Actions -->
        <div class="card">
            <div class="card-header">Actions</div>
            <div class="button-group">
                <button class="success" onclick="generateCalendar()">âœ“ Generate Calendar</button>
                <button class="primary" onclick="saveConfiguration()">ðŸ’¾ Save Configuration</button>
                <button class="secondary" onclick="exportToXLSX()">ðŸ“— Export to Excel</button>
                <button class="secondary" onclick="exportToPDF()">ðŸ“„ Export to PDF</button>
                <button class="secondary" onclick="resetForm()">âŸ² Reset Form</button>
            </div>
            <div id="message"></div>
        </div>

        <!-- Calendar Preview -->
        <div class="card hidden" id="calendarSection">
            <div class="card-header">Calendar Preview</div>

            <div class="legend">
                <div class="legend-items">
                    <div class="legend-item">
                        <span class="holiday-indicator"></span>
                        <span>Bank holiday affected this period</span>
                    </div>
                    <div class="legend-item">
                        <span class="adjustment-indicator"></span>
                        <span>Timeline auto-adjusted to fit within period</span>
                    </div>
                </div>
                <button class="add-offcycle-btn" onclick="openOffCycleWizard()">+ Add Off-Cycle(s)</button>
            </div>

            <div id="calendarPreview"></div>
        </div>
    </div>

    <script>
        const countries = [
            { code: 'US', name: 'United States' },
            { code: 'GB', name: 'United Kingdom' },
            { code: 'CA', name: 'Canada' },
            { code: 'AU', name: 'Australia' },
            { code: 'DE', name: 'Germany' },
            { code: 'FR', name: 'France' },
            { code: 'ES', name: 'Spain' },
            { code: 'IT', name: 'Italy' },
            { code: 'NL', name: 'Netherlands' },
            { code: 'BE', name: 'Belgium' },
            { code: 'IE', name: 'Ireland' },
            { code: 'SE', name: 'Sweden' },
            { code: 'NO', name: 'Norway' },
            { code: 'DK', name: 'Denmark' },
            { code: 'FI', name: 'Finland' },
            { code: 'PL', name: 'Poland' },
            { code: 'AT', name: 'Austria' },
            { code: 'CH', name: 'Switzerland' },
            { code: 'NZ', name: 'New Zealand' },
            { code: 'SG', name: 'Singapore' },
            { code: 'HK', name: 'Hong Kong' },
            { code: 'IN', name: 'India' },
            { code: 'JP', name: 'Japan' },
            { code: 'CN', name: 'China' },
            { code: 'BR', name: 'Brazil' },
            { code: 'MX', name: 'Mexico' },
            { code: 'ZA', name: 'South Africa' },
            { code: 'IL', name: 'Israel' },
            { code: 'AE', name: 'United Arab Emirates' },
            { code: 'SA', name: 'Saudi Arabia' },
            { code: 'BH', name: 'Bahrain' },
            { code: 'KW', name: 'Kuwait' },
            { code: 'QA', name: 'Qatar' },
            { code: 'OM', name: 'Oman' }
        ];

        // Weekend patterns by country (day numbers: 0=Sunday, 1=Monday, ..., 6=Saturday)
        const countryWeekends = {
            // Friday-Saturday weekends (Middle East)
            'IL': [5, 6],    // Israel: Friday, Saturday
            'AE': [5, 6],    // UAE: Friday, Saturday
            'SA': [5, 6],    // Saudi Arabia: Friday, Saturday
            'BH': [5, 6],    // Bahrain: Friday, Saturday
            'KW': [5, 6],    // Kuwait: Friday, Saturday
            'QA': [5, 6],    // Qatar: Friday, Saturday
            'OM': [5, 6],    // Oman: Friday, Saturday
            // Default: Saturday-Sunday weekends (most countries)
            'default': [0, 6]  // Sunday, Saturday
        };

        // Get weekend days for a specific country
        function getCountryWeekendDays(countryCode) {
            return countryWeekends[countryCode] || countryWeekends['default'];
        }

        const defaultTasks = [
            // Core tasks (cannot be deleted)
            { name: 'Payroll Cut Off', offset: 10, fromPrevious: false, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Working days before Pay Date', dueTime: '' },
            // Default system tasks (can be deleted)
            { name: 'Send changes to ICP', offset: 2, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Working days after Cut Off', dueTime: '' },
            { name: 'Reports back from ICP', offset: 2, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Working days after Send changes to ICP', dueTime: '' },
            // Core tasks
            { name: 'Payroll Reports Due', offset: 3, fromPrevious: true, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Working days after Reports back from ICP', dueTime: '' },
            // Default system tasks
            { name: 'Feedback from Client', offset: 2, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Working days after Reports Due', dueTime: '' },
            // Core tasks
            { name: 'Payroll Sign-Off Due', offset: 3, fromPrevious: true, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Working days after Feedback from Client', dueTime: '' },
            { name: 'Final Reports Due', offset: 2, fromPrevious: true, core: true, deletable: false, canBeBeforePayDate: true, beforePayDate: false, afterPayDate: false, description: 'Working days after Sign-Off', dueTime: '' },
            // Default system tasks
            { name: 'Net Pay Sent', offset: 1, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: true, beforePayDate: false, afterPayDate: false, description: 'Working days after Final Reports', dueTime: '' },
            // Core tasks
            { name: 'Pay Date', offset: 0, fromPrevious: false, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, afterPayDate: false, description: 'Pay date from Pay Date Configuration', dueTime: '' }
        ];
        // NOTE: Pay Date is ALWAYS the original pay date from the Pay Date Configuration section
        // It only moves if it falls on a weekend or bank holiday - NEVER based on task offsets

        let tasks = JSON.parse(JSON.stringify(defaultTasks));
        let bankHolidays = {};
        let generatedCalendar = [];
        let cutoffMode = 'offset';
        let cutoffConfig = { mode: 'offset', offset: 10 };
        let ignoredHolidays = []; // Array of holiday keys (country_date format) to ignore
        let payDateOverrides = {}; // Object mapping period index to override date
        let cutoffOverrides = {}; // Object mapping period index to override cutoff date
        let manualHolidays = {}; // Object mapping period index to { date: Date, name: string }
        let originalCutoffDates = []; // Store original cutoff dates to prevent recalculation when manual holidays are added
        let taskConstraints = []; // Array of {id, task1Index, task2Index, task1Name, task2Name} objects for same-date prevention
        let taskDateOverrides = {}; // Object mapping "periodIndex-taskName" to Date for manual constraint resolution

        // Off-Cycle Management (v4.0)
        let offCyclePeriods = []; // Array of off-cycle period configurations
        /* Off-cycle period object structure:
        {
            id: unique identifier (timestamp-based),
            placement: 'before' | 'after',
            relativeToPeriods: [array of period indices],
            payDates: {
                mode: 'offset' | 'manual',
                offsetDays: number (if mode is offset),
                dates: {periodIndex: Date} (if mode is manual or calculated from offset)
            },
            tasks: {
                mode: 'standard' | 'custom',
                selectedTasks: [array of task indices] (if custom),
                offsets: {
                    mode: 'standard' | 'custom',
                    customOffsets: {taskIndex: offsetValue} (if custom)
                }
            },
            advancedRules: [array of constraint objects matching taskConstraints format]
        }
        */

        function init() {
            populateCountryDropdowns();
            renderTasks();

            // Check if running from file:// protocol and warn user
            if (window.location.protocol === 'file:') {
                console.warn('âš ï¸ Running from file:// protocol - some browsers may block bank holiday API requests due to CORS restrictions');
                console.warn('ðŸ’¡ If bank holidays don\'t load, try one of these solutions:');
                console.warn('   1. Use Chrome or Firefox (most compatible)');
                console.warn('   2. Host the file on a web server');
                console.warn('   3. Manually add holidays using the "Add Manual Bank Holiday" feature');
            }

            loadSavedConfigurations();
        }

        function populateCountryDropdowns() {
            const selects = ['employeeCountry', 'providerCountry', 'clientTeamCountry'];
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                countries.forEach(country => {
                    const option = document.createElement('option');
                    option.value = country.code;
                    option.textContent = country.name;
                    select.appendChild(option);
                });
            });
        }

        function updatePayDateConfig() {
            const frequency = document.getElementById('payFrequency').value;
            const payConfig = document.getElementById('payDateConfig');
            const cutoffConfigDiv = document.getElementById('cutoffConfig');

            if (!frequency) {
                payConfig.classList.add('hidden');
                cutoffConfigDiv.classList.add('hidden');
                return;
            }

            payConfig.classList.remove('hidden');
            cutoffConfigDiv.classList.remove('hidden');

            let html = '';

            if (frequency === 'monthly') {
                html = `
                    <div class="form-group">
                        <label for="payDayOfMonth">Pay Day of Month</label>
                        <p class="day-picker-label">Select the day of the month for pay dates:</p>
                        ${generateDayPicker('payDayOfMonth', true)}
                        <span class="help-text">Adjusts to prior working day if weekend/holiday</span>
                    </div>
                `;
            } else if (frequency === 'semi-monthly') {
                html = `
                    <div class="form-row">
                        <div class="form-group">
                            <label for="firstPayDay">First Pay Date</label>
                            <p class="day-picker-label">Select the first pay day of the month:</p>
                            ${generateDayPicker('firstPayDay', false)}
                        </div>
                        <div class="form-group">
                            <label for="secondPayDay">Second Pay Date</label>
                            <p class="day-picker-label">Select the second pay day of the month:</p>
                            ${generateDayPicker('secondPayDay', true)}
                        </div>
                    </div>
                    <span class="help-text">Both dates adjust to prior working day if weekend/holiday</span>
                `;
            } else if (frequency === 'bi-weekly' || frequency === 'weekly') {
                const periodText = frequency === 'bi-weekly' ? 'every 2 weeks' : 'every week';
                html = `
                    <div class="form-row">
                        <div class="form-group">
                            <label for="payDayOfWeek">Pay Day of Week</label>
                            <select id="payDayOfWeek">
                                <option value="">Select day...</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                            </select>
                            <span class="help-text">Paid on this day ${periodText}</span>
                        </div>
                        <div class="form-group">
                            <label for="firstPayDate">First Pay Date of Year</label>
                            <input type="date" id="firstPayDate">
                            <span class="help-text">Starting reference date</span>
                        </div>
                    </div>
                `;
            }

            payConfig.innerHTML = html;
            updateCutoffMode();
        }

        function updateCutoffMode() {
            const frequency = document.getElementById('payFrequency').value;
            if (!frequency) return;

            cutoffMode = document.querySelector('input[name="cutoffMode"]:checked')?.value || 'offset';
            const container = document.getElementById('cutoffModeConfig');

            if (cutoffMode === 'date') {
                if (frequency === 'monthly') {
                    container.innerHTML = `
                        <div class="form-group">
                            <label for="cutoffDayOfMonth">Cut-Off Day of Month</label>
                            <p class="day-picker-label">Select the cut-off day of the month:</p>
                            ${generateDayPicker('cutoffDayOfMonth', false)}
                            <span class="help-text">Adjusts to prior working day if weekend/holiday</span>
                        </div>
                    `;
                } else if (frequency === 'semi-monthly') {
                    container.innerHTML = `
                        <div class="form-row">
                            <div class="form-group">
                                <label for="cutoffFirstDay">First Cut-Off Day</label>
                                <p class="day-picker-label">Select the first cut-off day:</p>
                                ${generateDayPicker('cutoffFirstDay', false)}
                            </div>
                            <div class="form-group">
                                <label for="cutoffSecondDay">Second Cut-Off Day</label>
                                <p class="day-picker-label">Select the second cut-off day:</p>
                                ${generateDayPicker('cutoffSecondDay', false)}
                            </div>
                        </div>
                        <span class="help-text">Both dates adjust to prior working day if weekend/holiday</span>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="form-group">
                            <label for="cutoffDayOfWeek">Cut-Off Day of Week</label>
                            <select id="cutoffDayOfWeek">
                                <option value="">Select day...</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                            </select>
                            <span class="help-text">Cut-off happens on this day each period</span>
                        </div>
                    `;
                }
            } else {
                container.innerHTML = `
                    <div class="form-group">
                        <label for="cutoffDaysOffset">Working Days Before Pay Date</label>
                        <input type="number" id="cutoffDaysOffset" value="10" min="1" placeholder="e.g., 10">
                        <span class="help-text">Number of working days before the pay date</span>
                    </div>
                `;
            }
        }

        function getOrdinal(n) {
            const s = ['th', 'st', 'nd', 'rd'];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        // Format date as "Thu, 27th Nov"
        function formatDateWithOrdinal(date) {
            const dayName = date.toLocaleDateString('en-GB', { weekday: 'short' });
            const day = date.getDate();
            const month = date.toLocaleDateString('en-GB', { month: 'short' });
            const dayWithOrdinal = getOrdinal(day);
            return `${dayName}, ${dayWithOrdinal} ${month}`;
        }

        // Generate calendar day picker HTML
        function generateDayPicker(pickerId, includeLastDay = false, selectedValue = null) {
            let html = '<div class="day-picker">';

            // Generate day buttons (1-31)
            for (let day = 1; day <= 31; day++) {
                const isSelected = selectedValue == day ? 'selected' : '';
                html += `<button type="button" class="day-picker-button ${isSelected}"
                         onclick="selectDay('${pickerId}', ${day})">${day}</button>`;
            }

            // Add "Last working day" button if requested
            if (includeLastDay) {
                const isSelected = selectedValue === 'last' ? 'selected' : '';
                html += `<button type="button" class="day-picker-button last-day ${isSelected}"
                         onclick="selectDay('${pickerId}', 'last')">Last working day of month</button>`;
            }

            html += '</div>';
            html += `<input type="hidden" id="${pickerId}" value="${selectedValue || ''}">`;
            return html;
        }

        // Handle day selection
        function selectDay(pickerId, value) {
            // Update hidden input
            document.getElementById(pickerId).value = value;

            // Update button states
            const picker = document.getElementById(pickerId).previousElementSibling;
            picker.querySelectorAll('.day-picker-button').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Find and select the clicked button
            const buttons = picker.querySelectorAll('.day-picker-button');
            buttons.forEach(btn => {
                if ((btn.textContent.trim() === String(value)) ||
                    (value === 'last' && btn.classList.contains('last-day'))) {
                    btn.classList.add('selected');
                }
            });
        }

        function renderTasks() {
            const tbody = document.getElementById('taskList');
            tbody.innerHTML = '';

            // Tasks are now sorted chronologically, just display in array order
            tasks.forEach((task, index) => {

                const tr = document.createElement('tr');
                tr.className = task.core ? 'task-row core' : 'task-row';

                // Use the stored task description (preserves the user's original selection)
                let descText;
                if (task.name === 'Pay Date') {
                    descText = 'From Pay Date Configuration (only moves for weekends/holidays)';
                } else if (task.description) {
                    // Use the stored description that reflects what the user originally specified
                    descText = task.description;
                } else {
                    // Fallback for tasks without stored descriptions (shouldn't happen)
                    descText = task.afterPayDate ? `${task.offset} working days after Pay Date` :
                               task.beforePayDate ? `${task.offset} working days before Pay Date` :
                               `${task.offset} working days after previous task`;
                }

                const timeTooltip = task.dueTime ? `Due time: ${formatTimeDisplay(task.dueTime)}` : 'Set due time';

                tr.innerHTML = `
                    <td>
                        <div class="task-name-cell">
                            <span>${task.name}${getConstraintIndicator(index)}</span>
                        </div>
                    </td>
                    <td style="text-align: center;">
                        ${task.core ?
                            '<span style="color: var(--success-teal); font-size: 18px; font-weight: 700;">âœ“</span>' :
                            ''
                        }
                    </td>
                    <td>
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <div style="flex: 0 0 auto;">
                                ${task.name === 'Pay Date' ?
                                    '<span style="color: var(--text-light); font-style: italic;">N/A</span>' :
                                    `<input type="number" class="task-offset-input" value="${task.offset}" min="0"
                                        onchange="updateTaskOffset(${index}, this.value)"
                                        ${task.name === 'Payroll Cut Off' ? 'disabled style="opacity: 0.5; cursor: not-allowed;" title="Cutoff is configured above"' : ''}>`
                                }
                            </div>
                            <button class="clock-icon-button ${task.dueTime ? 'has-time' : ''}"
                                    onclick="showTaskTimeModal(${index})"
                                    title="${timeTooltip}">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <polyline points="12 6 12 12 16 14"></polyline>
                                </svg>
                            </button>
                        </div>
                    </td>
                    <td style="color: var(--text-medium); font-size: 14px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span>${descText}</span>
                            ${task.canBeBeforePayDate ? `
                                <button class="secondary small" onclick="toggleBeforePayDate(${index})" style="white-space: nowrap;">
                                    ${task.beforePayDate ? 'â†“ After Previous' : 'â†‘ Before Pay Date'}
                                </button>
                            ` : ''}
                        </div>
                    </td>
                    <td>
                        ${task.deletable ? `
                            <div style="display: flex; align-items: center; justify-content: flex-end; gap: 12px; height: 100%;">
                                <button class="secondary small" onclick="moveTaskUp(${index})" ${index <= 1 ? 'disabled style="opacity: 0.3; cursor: not-allowed;"' : ''} title="Move task up">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                        <polyline points="18 15 12 9 6 15"></polyline>
                                    </svg>
                                </button>
                                <button class="secondary small" onclick="moveTaskDown(${index})" ${index >= tasks.length - 1 ? 'disabled style="opacity: 0.3; cursor: not-allowed;"' : ''} title="Move task down">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                        <polyline points="6 9 12 15 18 9"></polyline>
                                    </svg>
                                </button>
                                <button class="secondary small" onclick="editTask(${index})">Edit</button>
                                <button class="danger small" onclick="deleteTask(${index})">Delete</button>
                            </div>
                        ` : ''}
                    </td>
                `;

                tbody.appendChild(tr);
            });

            // Update the task dropdown in add-task-row
            updateTaskDropdown();
        }

        function updateTaskOffset(index, newValue) {
            const value = parseInt(newValue);
            if (!isNaN(value) && value >= 0) {
                tasks[index].offset = value;

                // Update the description to reflect the new offset
                const task = tasks[index];
                if (task.name !== 'Pay Date' && task.name !== 'Payroll Cut Off') {
                    if (task.beforePayDate) {
                        // Task is before Pay Date
                        task.description = value === 0
                            ? 'Same day as Pay Date'
                            : value === 1
                            ? '1 working day before Pay Date'
                            : `${value} working days before Pay Date`;
                    } else if (task.afterPayDate) {
                        // Task is after Pay Date
                        task.description = value === 0
                            ? 'Same day as Pay Date'
                            : value === 1
                            ? '1 working day after Pay Date'
                            : `${value} working days after Pay Date`;
                    } else {
                        // Task is calculated from previous task
                        const prevTaskIndex = index - 1;
                        if (prevTaskIndex >= 0) {
                            const prevTask = tasks[prevTaskIndex];
                            task.description = value === 0
                                ? `Same day as ${prevTask.name}`
                                : value === 1
                                ? `1 working day after ${prevTask.name}`
                                : `${value} working days after ${prevTask.name}`;
                        }
                    }
                }

                renderTasks();
            }
        }

        function toggleBeforePayDate(index) {
            if (tasks[index].canBeBeforePayDate) {
                const wasBeforePayDate = tasks[index].beforePayDate;
                tasks[index].beforePayDate = !tasks[index].beforePayDate;

                // Update description to reflect the change
                if (tasks[index].beforePayDate) {
                    tasks[index].description = tasks[index].offset === 0
                        ? 'Same day as Pay Date'
                        : `${tasks[index].offset} working days before Pay Date`;
                    console.log(`âœ“ "${tasks[index].name}" now calculated BEFORE Pay Date (${tasks[index].offset} days)`);
                } else {
                    // Revert to calculating from previous task
                    const prevTaskIndex = index - 1;
                    if (prevTaskIndex > 0) {
                        const prevTask = tasks[prevTaskIndex];
                        tasks[index].description = tasks[index].offset === 0
                            ? `Same day as ${prevTask.name}`
                            : `${tasks[index].offset} working days after ${prevTask.name}`;
                    }
                    console.log(`âœ“ "${tasks[index].name}" now calculated AFTER previous task (${tasks[index].offset} days)`);
                }

                renderTasks();

                // Regenerate calendar if one exists
                if (generatedCalendar.length > 0) {
                    generateCalendar(true); // Preserve cutoff overrides
                }
            }
        }

        function updateTaskDropdown() {
            const dropdown = document.getElementById('newTaskRelativeTo');
            dropdown.innerHTML = '';

            tasks.forEach((task, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = task.name;
                dropdown.appendChild(option);
            });

            // Default to last task (Pay Date)
            dropdown.value = tasks.length - 1;
        }

        function populateTaskName() {
            const templateSelect = document.getElementById('newTaskTemplate');
            const taskNameInput = document.getElementById('newTaskName');
            const selectedValue = templateSelect.value;

            if (selectedValue === 'custom') {
                // Show text input for custom task
                taskNameInput.style.display = 'block';
                taskNameInput.focus();
            } else {
                // Hide text input
                taskNameInput.style.display = 'none';
                taskNameInput.value = '';
            }
        }

        function sortTasksChronologically() {
            // Calculate dates for all tasks using a reference pay date
            // This allows us to sort them chronologically
            const referenceCutoff = new Date(2025, 0, 1); // Jan 1, 2025
            const referencePayDate = new Date(2025, 0, 31); // Jan 31, 2025
            const uniqueCountries = ['US']; // Use US for sorting calculation

            const taskDates = new Map();

            // Cut Off date (index 0)
            taskDates.set(0, new Date(referenceCutoff));

            // Calculate forward from cut-off for all tasks to maintain the chain
            // This ensures currentDate advances properly even for tasks that will be recalculated later
            let currentDate = new Date(referenceCutoff);
            for (let i = 1; i < tasks.length - 1; i++) {
                if (tasks[i].fromPrevious) {
                    // Calculate forward from previous task
                    currentDate = calculateWorkingDate(currentDate, tasks[i].offset, 'forward', uniqueCountries);
                    // Only set the date if this isn't a beforePayDate or afterPayDate task
                    // (those will be recalculated below)
                    if (!tasks[i].beforePayDate && !tasks[i].afterPayDate) {
                        taskDates.set(i, new Date(currentDate));
                    }
                }
            }

            // Calculate backward from pay date for beforePayDate tasks (overrides forward calculation)
            for (let i = 1; i < tasks.length - 1; i++) {
                if (tasks[i].beforePayDate) {
                    const taskDate = calculateWorkingDate(referencePayDate, tasks[i].offset, 'backward', uniqueCountries);
                    taskDates.set(i, new Date(taskDate));
                }
            }

            // Calculate forward from pay date for afterPayDate tasks (overrides forward calculation)
            for (let i = 1; i < tasks.length - 1; i++) {
                if (tasks[i].afterPayDate) {
                    const taskDate = calculateWorkingDate(referencePayDate, tasks[i].offset, 'forward', uniqueCountries);
                    taskDates.set(i, new Date(taskDate));
                }
            }

            // Pay Date (last index)
            taskDates.set(tasks.length - 1, new Date(referencePayDate));

            // Create array of tasks with their calculated dates and original indices
            const tasksWithDates = tasks.map((task, index) => ({
                task,
                date: taskDates.get(index),
                originalIndex: index
            }));

            // Separate cut-off, pay date, tasks before pay date, and tasks after pay date
            const cutOffTask = tasksWithDates[0];
            const payDateTask = tasksWithDates[tasksWithDates.length - 1];
            const allIntermediateTasks = tasksWithDates.slice(1, -1);

            // Split intermediate tasks into those BEFORE and AFTER pay date
            const tasksBeforePayDate = allIntermediateTasks.filter(t => !t.task.afterPayDate);
            const tasksAfterPayDate = allIntermediateTasks.filter(t => t.task.afterPayDate);

            // Sort each group by calculated date (ascending = chronological order)
            tasksBeforePayDate.sort((a, b) => a.date - b.date);
            tasksAfterPayDate.sort((a, b) => a.date - b.date);

            // Rebuild tasks array: Cut Off, tasks before Pay Date, Pay Date, tasks after Pay Date
            // This ensures tasks marked "after Pay Date" appear AFTER Pay Date in the list and calendar
            tasks = [
                cutOffTask.task,
                ...tasksBeforePayDate.map(t => t.task),
                payDateTask.task,
                ...tasksAfterPayDate.map(t => t.task)
            ];

            console.log('ðŸ“Š Tasks sorted chronologically - Pay Date at position:', tasks.indexOf(payDateTask.task),
                        '- Tasks after Pay Date:', tasksAfterPayDate.length);
        }

        function addTask() {
            const templateSelect = document.getElementById('newTaskTemplate');
            const taskNameInput = document.getElementById('newTaskName');

            // Get task name from either select or text input
            let name = '';
            if (templateSelect.value === 'custom') {
                name = taskNameInput.value.trim();
            } else if (templateSelect.value) {
                name = templateSelect.value;
            }

            if (!name) {
                showMessage('Please select a task or enter a custom task name', 'error');
                return;
            }
            const offset = parseInt(document.getElementById('newTaskOffset').value);
            const position = document.getElementById('newTaskPosition').value; // "before" or "after"
            const relativeToIndex = parseInt(document.getElementById('newTaskRelativeTo').value);

            if (isNaN(offset) || offset < 0) {
                showMessage('Please enter a valid number of working days (0 or more)', 'error');
                return;
            }

            // Pay Date is always the last task in the array
            const payDateIndex = tasks.length - 1;

            // Determine if this task can be set to "before pay date" (toggle available after adding)
            const canBeBeforePayDate = (name === 'Payslips Available on Portal' || name === 'Value Date on Bank File');

            // Determine if this task should be calculated BEFORE or AFTER Pay Date
            const isBeforePayDate = (position === 'before' && relativeToIndex === payDateIndex);
            const isAfterPayDate = (position === 'after' && relativeToIndex === payDateIndex);

            // Determine properties based on selection
            let description;
            let afterPayDate = false;
            let beforePayDate = false;
            let fromPrevious = true;

            if (isBeforePayDate) {
                // Task chronologically happens BEFORE Pay Date
                beforePayDate = true;
                fromPrevious = false;
                description = offset === 0 ? 'Same day as Pay Date' : `${offset} working days before Pay Date`;
                console.log(`ðŸ“Œ Adding task "${name}" that occurs BEFORE Pay Date (${offset} days).`);
            } else if (isAfterPayDate) {
                // Task chronologically happens AFTER Pay Date
                afterPayDate = true;
                fromPrevious = false;
                description = offset === 0 ? 'Same day as Pay Date' : `${offset} working days after Pay Date`;
                console.log(`ðŸ“Œ Adding task "${name}" that occurs AFTER Pay Date (${offset} days).`);
            } else {
                // Normal forward-calculated task
                if (relativeToIndex === 0) {
                    description = offset === 0 ? 'Same day as start' : `${offset} working days after start`;
                } else {
                    const relativeTask = tasks[relativeToIndex];
                    description = offset === 0 ? `Same day as ${relativeTask.name}` : `${offset} working days after ${relativeTask.name}`;
                }
            }

            // Create new task
            const newTask = {
                name,
                offset,
                fromPrevious,
                core: false,
                deletable: true,
                canBeBeforePayDate,
                beforePayDate,
                afterPayDate,
                description,
                dueTime: ''
            };

            // Determine insert position based on user's selection
            let insertIndex;
            if (beforePayDate || afterPayDate) {
                // For tasks relative to Pay Date, insert before Pay Date and sort later
                insertIndex = payDateIndex;
            } else if (position === 'after') {
                // Insert right after the selected task
                insertIndex = relativeToIndex + 1;
            } else if (position === 'before') {
                // Insert right before the selected task
                insertIndex = relativeToIndex;
            } else {
                // Default: insert before Pay Date
                insertIndex = payDateIndex;
            }

            // Insert task at the calculated position
            tasks.splice(insertIndex, 0, newTask);

            // Update the subsequent task's description if it references the previous task
            // This maintains a sequential chain when inserting tasks
            if (!beforePayDate && !afterPayDate && position === 'after') {
                const nextTaskIndex = insertIndex + 1;
                // Check if there's a task after the inserted one (not Pay Date)
                if (nextTaskIndex < tasks.length - 1) {
                    const nextTask = tasks[nextTaskIndex];
                    // If the next task was calculated from the previous task, update its description
                    if (nextTask.fromPrevious && !nextTask.beforePayDate && !nextTask.afterPayDate) {
                        // Update description to reference the newly inserted task
                        nextTask.description = nextTask.offset === 0
                            ? `Same day as ${newTask.name}`
                            : `${nextTask.offset} working days after ${newTask.name}`;
                        console.log(`ðŸ“ Updated "${nextTask.name}" to reference newly inserted task "${newTask.name}"`);
                    }
                }
            }

            // Only sort if this is a Pay Date relative task (beforePayDate or afterPayDate)
            // This ensures tasks are positioned correctly relative to Pay Date
            // For all other tasks, preserve the insertion order specified by the user
            if (beforePayDate || afterPayDate) {
                sortTasksChronologically();
            }

            renderTasks();
            // Reset form fields
            templateSelect.value = '';
            taskNameInput.value = '';
            taskNameInput.style.display = 'none';
            document.getElementById('newTaskOffset').value = '1';
            showMessage('Task added successfully', 'success');
        }

        function moveTaskUp(index) {
            // Can't move Payroll Cut Off or tasks above it
            if (index <= 1) return;

            // Update constraints before swap
            onTaskReordered(index, index - 1);

            // Swap with previous task
            [tasks[index], tasks[index - 1]] = [tasks[index - 1], tasks[index]];
            renderTasks();
            showMessage('Task moved up', 'success');
        }

        function moveTaskDown(index) {
            // Can't move last task (Pay Date) or tasks at/after it
            if (index >= tasks.length - 1) return;

            // Update constraints before swap
            onTaskReordered(index, index + 1);

            // Swap with next task
            [tasks[index], tasks[index + 1]] = [tasks[index + 1], tasks[index]];
            renderTasks();
            showMessage('Task moved down', 'success');
        }

        function editTask(index) {
            const task = tasks[index];
            const newName = prompt('Enter new task name:', task.name);

            if (newName && newName.trim()) {
                const trimmedName = newName.trim();
                tasks[index].name = trimmedName;
                onTaskRenamed(index, trimmedName); // Update constraint names
                renderTasks();
                showMessage('Task updated successfully', 'success');
            }
        }

        function deleteTask(index) {
            if (confirm('Are you sure you want to delete this task?')) {
                onTaskDeleted(index); // Update constraints before deletion
                tasks.splice(index, 1);
                renderTasks();
                showMessage('Task deleted successfully', 'success');
            }
        }

        async function fetchBankHolidays(countryCode, year) {
            try {
                console.log(`ðŸŒ Fetching bank holidays for ${countryCode} in ${year}...`);
                const url = `https://date.nager.at/api/v3/PublicHolidays/${year}/${countryCode}`;
                console.log(`   URL: ${url}`);

                const response = await fetch(url);

                console.log(`   Response status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const holidays = await response.json();
                console.log(`   âœ… Fetched ${holidays.length} holidays for ${countryCode}`);

                return holidays.map(h => {
                    let holidayName = h.localName || h.name;

                    // Add regional information for non-global holidays (e.g., UK regional holidays)
                    if (h.global === false && h.counties && h.counties.length > 0) {
                        // For UK: If England has the holiday, list as "United Kingdom" by default
                        if (countryCode === 'GB') {
                            const hasEngland = h.counties.includes('GB-ENG');
                            const ukRegions = ['GB-SCT', 'GB-ENG', 'GB-WLS', 'GB-NIR'];
                            const hasAllRegions = ukRegions.every(region => h.counties.includes(region));

                            if (hasAllRegions || hasEngland) {
                                // All of UK OR England has it - default to "United Kingdom"
                                // Don't add regional suffix
                            } else {
                                // Only Scotland, Wales, or Northern Ireland (without England) - show which regions
                                const regionMap = {
                                    'GB-SCT': 'Scotland',
                                    'GB-ENG': 'England',
                                    'GB-WLS': 'Wales',
                                    'GB-NIR': 'Northern Ireland'
                                };
                                const regions = h.counties.map(c => regionMap[c] || c).join(', ');
                                holidayName = `${holidayName} (${regions})`;
                            }
                        }
                        // For US: If more than 5 states, just say "United States"
                        else if (countryCode === 'US') {
                            if (h.counties.length > 5) {
                                // More than 5 states - don't list them all
                                // Don't add regional suffix
                            } else {
                                // 5 or fewer states - show which ones
                                const stateMap = {
                                    'US-AL': 'Alabama', 'US-AK': 'Alaska', 'US-AZ': 'Arizona',
                                    'US-AR': 'Arkansas', 'US-CA': 'California', 'US-CO': 'Colorado',
                                    'US-CT': 'Connecticut', 'US-DE': 'Delaware', 'US-FL': 'Florida',
                                    'US-GA': 'Georgia', 'US-HI': 'Hawaii', 'US-ID': 'Idaho',
                                    'US-IL': 'Illinois', 'US-IN': 'Indiana', 'US-IA': 'Iowa',
                                    'US-KS': 'Kansas', 'US-KY': 'Kentucky', 'US-LA': 'Louisiana',
                                    'US-ME': 'Maine', 'US-MD': 'Maryland', 'US-MA': 'Massachusetts',
                                    'US-MI': 'Michigan', 'US-MN': 'Minnesota', 'US-MS': 'Mississippi',
                                    'US-MO': 'Missouri', 'US-MT': 'Montana', 'US-NE': 'Nebraska',
                                    'US-NV': 'Nevada', 'US-NH': 'New Hampshire', 'US-NJ': 'New Jersey',
                                    'US-NM': 'New Mexico', 'US-NY': 'New York', 'US-NC': 'North Carolina',
                                    'US-ND': 'North Dakota', 'US-OH': 'Ohio', 'US-OK': 'Oklahoma',
                                    'US-OR': 'Oregon', 'US-PA': 'Pennsylvania', 'US-RI': 'Rhode Island',
                                    'US-SC': 'South Carolina', 'US-SD': 'South Dakota', 'US-TN': 'Tennessee',
                                    'US-TX': 'Texas', 'US-UT': 'Utah', 'US-VT': 'Vermont',
                                    'US-VA': 'Virginia', 'US-WA': 'Washington', 'US-WV': 'West Virginia',
                                    'US-WI': 'Wisconsin', 'US-WY': 'Wyoming', 'US-DC': 'District of Columbia'
                                };
                                const states = h.counties.map(c => stateMap[c] || c).join(', ');
                                holidayName = `${holidayName} (${states})`;
                            }
                        }
                        // For other countries with regional holidays
                        else {
                            const regions = h.counties.join(', ');
                            holidayName = `${holidayName} (${regions})`;
                        }
                    }

                    return {
                        date: h.date,
                        name: holidayName
                    };
                });
            } catch (error) {
                console.error(`âŒ Error fetching holidays for ${countryCode}:`, error);

                // Provide specific guidance based on error type
                let errorMsg = `Warning: Could not fetch bank holidays for ${countryCode}.`;

                if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    errorMsg += ' This is likely due to CORS/network restrictions.';
                    if (window.location.protocol === 'file:') {
                        errorMsg += ' TIP: Some browsers block API requests when opening HTML files directly. Try using Chrome, or host the file on a web server.';
                    }
                } else {
                    errorMsg += ` Error: ${error.message}.`;
                }

                errorMsg += ' You can manually add holidays using the "Add Manual Bank Holiday" feature in the pay date override modal.';

                showMessage(errorMsg, 'warning');
                return [];
            }
        }

        function isWeekend(date, relevantCountries) {
            const day = date.getDay();

            // Check if this day is a weekend in ANY of the relevant countries
            for (const countryCode of relevantCountries) {
                const weekendDays = getCountryWeekendDays(countryCode);
                if (weekendDays.includes(day)) {
                    return true;
                }
            }

            return false;
        }

        function formatDateToString(date) {
            // Format date as YYYY-MM-DD without timezone conversion
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function isBankHoliday(date, countryCode) {
            const dateStr = formatDateToString(date);
            const holidayKey = `${countryCode}_${dateStr}`;

            // Check if this holiday is ignored
            if (ignoredHolidays.includes(holidayKey)) {
                return false;
            }

            return bankHolidays[countryCode]?.some(h => h.date === dateStr);
        }

        function getHolidayName(date, countryCode) {
            const dateStr = formatDateToString(date);
            const holiday = bankHolidays[countryCode]?.find(h => h.date === dateStr);
            return holiday ? holiday.name : '';
        }

        function isNonWorkingDay(date, relevantCountries) {
            for (const country of relevantCountries) {
                if (isBankHoliday(date, country)) return true;
            }
            return false;
        }

        function calculateWorkingDate(startDate, offset, direction, relevantCountries) {
            let current = new Date(startDate);
            let remainingDays = Math.abs(offset);
            const dir = direction === 'forward' ? 1 : -1;

            if (offset === 0) return current;

            while (remainingDays > 0) {
                current.setDate(current.getDate() + dir);
                const isWE = isWeekend(current, relevantCountries);
                const isNWD = isNonWorkingDay(current, relevantCountries);

                if (isNWD) {
                    // Log when skipping bank holidays
                    const dateStr = formatDateToString(current);
                    for (const country of relevantCountries) {
                        const holidayName = getHolidayName(current, country);
                        if (holidayName) {
                            console.log(`â­ï¸  Skipping bank holiday: ${dateStr} - ${holidayName} (${country})`);
                            break;
                        }
                    }
                }

                if (!isWE && !isNWD) {
                    remainingDays--;
                }
            }

            return current;
        }

        function countWorkingDaysBetween(startDate, endDate, relevantCountries) {
            let count = 0;
            let current = new Date(startDate);
            const end = new Date(endDate);

            while (current < end) {
                current.setDate(current.getDate() + 1);
                if (!isWeekend(current, relevantCountries) && !isNonWorkingDay(current, relevantCountries)) {
                    count++;
                }
            }

            return count;
        }

        function moveToPriorWorkingDay(date, relevantCountries) {
            let current = new Date(date);
            const original = new Date(date);
            let moveCount = 0;
            let adjustmentReason = null;

            // Track what caused the adjustment (check original date)
            if (isWeekend(original, relevantCountries) || isNonWorkingDay(original, relevantCountries)) {
                if (isNonWorkingDay(original, relevantCountries)) {
                    adjustmentReason = {
                        type: 'holiday',
                        date: new Date(original),
                        holidayName: getHolidayName(original, relevantCountries)
                    };
                } else {
                    adjustmentReason = {
                        type: 'weekend',
                        date: new Date(original)
                    };
                }
            }

            while (isWeekend(current, relevantCountries) || isNonWorkingDay(current, relevantCountries)) {
                current.setDate(current.getDate() - 1);
                moveCount++;
            }
            if (moveCount > 0) {
                console.log(`  Moved ${original.toDateString()} â†’ ${current.toDateString()} (${moveCount} days back)`);
            }

            return {
                date: current,
                wasAdjusted: moveCount > 0,
                originalDate: moveCount > 0 ? original : null,
                daysShifted: moveCount,
                reason: adjustmentReason
            };
        }

        function getPayDates(frequency, year, config, employeeCountryArray) {
            const payDates = [];

            if (frequency === 'monthly') {
                const dayOfMonth = config.payDayOfMonth;
                for (let month = 0; month < 12; month++) {
                    let payDate;
                    if (dayOfMonth === 'last') {
                        payDate = new Date(year, month + 1, 0);
                    } else {
                        const day = parseInt(dayOfMonth);
                        payDate = new Date(year, month, day);
                        if (payDate.getMonth() !== month) {
                            payDate = new Date(year, month + 1, 0);
                        }
                    }
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    const adjustment = moveToPriorWorkingDay(payDate, employeeCountryArray);
                    payDates.push({
                        date: adjustment.date,
                        originalDate: adjustment.originalDate,
                        wasAdjusted: adjustment.wasAdjusted,
                        adjustmentReason: adjustment.reason,
                        daysShifted: adjustment.daysShifted,
                        label: `${new Date(year, month, 1).toLocaleDateString('en-GB', { month: 'long' })} ${year}`,
                        month: month
                    });
                }
            } else if (frequency === 'semi-monthly') {
                const firstDay = parseInt(config.firstPayDay);
                const secondDay = config.secondPayDay;

                for (let month = 0; month < 12; month++) {
                    let payDate1 = new Date(year, month, firstDay);
                    if (payDate1.getMonth() !== month) {
                        payDate1 = new Date(year, month + 1, 0);
                    }
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    const adjustment1 = moveToPriorWorkingDay(payDate1, employeeCountryArray);

                    payDates.push({
                        date: adjustment1.date,
                        originalDate: adjustment1.originalDate,
                        wasAdjusted: adjustment1.wasAdjusted,
                        adjustmentReason: adjustment1.reason,
                        daysShifted: adjustment1.daysShifted,
                        label: `${new Date(year, month, 1).toLocaleDateString('en-GB', { month: 'long' })} ${year} P1`,
                        month: month,
                        periodInMonth: 1
                    });

                    let payDate2;
                    if (secondDay === 'last') {
                        payDate2 = new Date(year, month + 1, 0);
                    } else {
                        payDate2 = new Date(year, month, parseInt(secondDay));
                        if (payDate2.getMonth() !== month) {
                            payDate2 = new Date(year, month + 1, 0);
                        }
                    }
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    const adjustment2 = moveToPriorWorkingDay(payDate2, employeeCountryArray);

                    payDates.push({
                        date: adjustment2.date,
                        originalDate: adjustment2.originalDate,
                        wasAdjusted: adjustment2.wasAdjusted,
                        adjustmentReason: adjustment2.reason,
                        daysShifted: adjustment2.daysShifted,
                        label: `${new Date(year, month, 1).toLocaleDateString('en-GB', { month: 'long' })} ${year} P2`,
                        month: month,
                        periodInMonth: 2
                    });
                }
            } else if (frequency === 'bi-weekly' || frequency === 'weekly') {
                let currentDate = new Date(config.firstPayDate);
                const increment = frequency === 'bi-weekly' ? 14 : 7;
                let payPeriodNum = 1;

                while (currentDate.getFullYear() === year) {
                    let payDate = new Date(currentDate);
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    const adjustment = moveToPriorWorkingDay(payDate, employeeCountryArray);
                    payDates.push({
                        date: adjustment.date,
                        originalDate: adjustment.originalDate,
                        wasAdjusted: adjustment.wasAdjusted,
                        adjustmentReason: adjustment.reason,
                        daysShifted: adjustment.daysShifted,
                        label: `Period ${payPeriodNum} (${adjustment.date.toLocaleDateString('en-GB', { month: 'short', day: 'numeric', year: 'numeric' })})`,
                        month: adjustment.date.getMonth()
                    });
                    currentDate.setDate(currentDate.getDate() + increment);
                    payPeriodNum++;
                }
            }

            return payDates;
        }

        function getCutoffDates(frequency, year, payDates, cutoffConfig, relevantCountries) {
            const cutoffDates = [];

            if (cutoffConfig.mode === 'offset') {
                payDates.forEach(payPeriod => {
                    const cutoffDate = calculateWorkingDate(
                        payPeriod.date,
                        cutoffConfig.offset || 10,
                        'backward',
                        relevantCountries
                    );
                    cutoffDates.push(cutoffDate);
                });
            } else {
                if (frequency === 'monthly') {
                    const dayOfMonth = cutoffConfig.cutoffDayOfMonth;
                    for (let month = 0; month < 12; month++) {
                        let cutoffDate = new Date(year, month, parseInt(dayOfMonth));
                        if (cutoffDate.getMonth() !== month) {
                            cutoffDate = new Date(year, month + 1, 0);
                        }
                        cutoffDate = moveToPriorWorkingDay(cutoffDate, relevantCountries).date;
                        cutoffDates.push(cutoffDate);
                    }
                } else if (frequency === 'semi-monthly') {
                    for (let month = 0; month < 12; month++) {
                        let cutoff1 = new Date(year, month, parseInt(cutoffConfig.cutoffFirstDay));
                        if (cutoff1.getMonth() !== month) {
                            cutoff1 = new Date(year, month + 1, 0);
                        }
                        cutoff1 = moveToPriorWorkingDay(cutoff1, relevantCountries).date;
                        cutoffDates.push(cutoff1);

                        let cutoff2 = new Date(year, month, parseInt(cutoffConfig.cutoffSecondDay));
                        if (cutoff2.getMonth() !== month) {
                            cutoff2 = new Date(year, month + 1, 0);
                        }
                        cutoff2 = moveToPriorWorkingDay(cutoff2, relevantCountries).date;
                        cutoffDates.push(cutoff2);
                    }
                } else {
                    payDates.forEach(payPeriod => {
                        const targetDay = parseInt(cutoffConfig.cutoffDayOfWeek);
                        let cutoffDate = new Date(payPeriod.date);

                        while (cutoffDate.getDay() !== targetDay || cutoffDate >= payPeriod.date) {
                            cutoffDate.setDate(cutoffDate.getDate() - 1);
                        }

                        cutoffDate = moveToPriorWorkingDay(cutoffDate, relevantCountries).date;
                        cutoffDates.push(cutoffDate);
                    });
                }
            }

            return cutoffDates;
        }

        // Validate task constraints: Check if any constrained task pairs are on the same date
        // FIX v3.7: Moved to global scope so it can be called from both generateCalendar and renderCalendar
        function validateTaskConstraints(periodTasks, periodIndex) {
            const violations = [];

            // Group tasks by period for this validation
            const periodTaskMap = {};
            periodTasks.forEach(pt => {
                if (!periodTaskMap[pt.task]) {
                    periodTaskMap[pt.task] = pt;
                }
            });

            // Check each constraint
            taskConstraints.forEach(constraint => {
                const task1Name = constraint.task1Name;
                const task2Name = constraint.task2Name;

                const task1Data = periodTaskMap[task1Name];
                const task2Data = periodTaskMap[task2Name];

                if (task1Data && task2Data) {
                    // Compare dates (ignore time)
                    const date1 = new Date(task1Data.date).toDateString();
                    const date2 = new Date(task2Data.date).toDateString();

                    if (date1 === date2) {
                        violations.push({
                            task1: task1Name,
                            task2: task2Name,
                            date: date1
                        });
                        console.log(`âš ï¸ Constraint violation in period ${periodIndex}: ${task1Name} and ${task2Name} both on ${date1}`);
                    }
                }
            });

            return violations;
        }

        async function generateCalendar(preserveCutoffs = false) {
            // Reset original cutoffs unless we're regenerating with overrides/ignores
            if (!preserveCutoffs) {
                originalCutoffDates = [];
                console.log('ðŸ”„ Reset original cutoffs (fresh generation)');
            }

            // FIX v3.7: Clear stale violation cache at the start of calendar generation
            window.constraintViolations = {};

            const clientName = document.getElementById('clientName').value.trim();
            const employeeCountry = document.getElementById('employeeCountry').value;
            const providerCountry = document.getElementById('providerCountry').value;
            const clientTeamCountry = document.getElementById('clientTeamCountry').value;
            const payFrequency = document.getElementById('payFrequency').value;
            const year = parseInt(document.getElementById('calendarYear').value);

            if (!clientName || !employeeCountry || !payFrequency) {
                showMessage('Please fill in all required fields (Client Name, Employee Country, Pay Frequency)', 'error');
                return;
            }

            let config = {};
            if (payFrequency === 'monthly') {
                config.payDayOfMonth = document.getElementById('payDayOfMonth')?.value;
                if (!config.payDayOfMonth) {
                    showMessage('Please select the pay day of month', 'error');
                    return;
                }
            } else if (payFrequency === 'semi-monthly') {
                config.firstPayDay = document.getElementById('firstPayDay')?.value;
                config.secondPayDay = document.getElementById('secondPayDay')?.value;
                if (!config.firstPayDay || !config.secondPayDay) {
                    showMessage('Please select both pay dates', 'error');
                    return;
                }
            } else if (payFrequency === 'bi-weekly' || payFrequency === 'weekly') {
                config.payDayOfWeek = document.getElementById('payDayOfWeek')?.value;
                config.firstPayDate = document.getElementById('firstPayDate')?.value;
                if (!config.payDayOfWeek || !config.firstPayDate) {
                    showMessage('Please select pay day and first pay date', 'error');
                    return;
                }
            }

            cutoffMode = document.querySelector('input[name="cutoffMode"]:checked')?.value || 'offset';
            cutoffConfig = { mode: cutoffMode };

            if (cutoffMode === 'offset') {
                const offsetValue = document.getElementById('cutoffDaysOffset')?.value;
                if (!offsetValue) {
                    showMessage('Please enter the cut-off days offset', 'error');
                    return;
                }
                cutoffConfig.offset = parseInt(offsetValue);
                tasks[0].offset = cutoffConfig.offset;
                tasks[0].description = `${cutoffConfig.offset} working days before Pay Date`;
            } else {
                if (payFrequency === 'monthly') {
                    cutoffConfig.cutoffDayOfMonth = document.getElementById('cutoffDayOfMonth')?.value;
                    if (!cutoffConfig.cutoffDayOfMonth) {
                        showMessage('Please select the cut-off day of month', 'error');
                        return;
                    }
                } else if (payFrequency === 'semi-monthly') {
                    cutoffConfig.cutoffFirstDay = document.getElementById('cutoffFirstDay')?.value;
                    cutoffConfig.cutoffSecondDay = document.getElementById('cutoffSecondDay')?.value;
                    if (!cutoffConfig.cutoffFirstDay || !cutoffConfig.cutoffSecondDay) {
                        showMessage('Please select both cut-off dates', 'error');
                        return;
                    }
                } else {
                    cutoffConfig.cutoffDayOfWeek = document.getElementById('cutoffDayOfWeek')?.value;
                    if (!cutoffConfig.cutoffDayOfWeek) {
                        showMessage('Please select the cut-off day of week', 'error');
                        return;
                    }
                }
                tasks[0].description = 'Specific date (see calendar)';
            }

            renderTasks();

            showMessage('Generating calendar... Fetching bank holidays...', 'loading');

            // Build list of countries to consider for bank holidays
            const countriesForHolidays = [employeeCountry]; // Employee country always included

            // Check if provider country is selected and if its holidays should impact
            const providerImpact = document.getElementById('providerCountryImpact')?.checked ?? true;
            if (providerCountry && providerImpact) {
                countriesForHolidays.push(providerCountry);
            }

            // Check if client team country is selected and if its holidays should impact
            const clientTeamImpact = document.getElementById('clientTeamCountryImpact')?.checked ?? true;
            if (clientTeamCountry && clientTeamImpact) {
                countriesForHolidays.push(clientTeamCountry);
            }

            const uniqueCountries = [...new Set(countriesForHolidays)];
            bankHolidays = {};

            for (const country of uniqueCountries) {
                bankHolidays[country] = await fetchBankHolidays(country, year);
            }

            // Pay dates only check employee country for weekends/holidays
            const payDates = getPayDates(payFrequency, year, config, [employeeCountry]);

            // Calculate cutoff dates - but reuse original cutoffs if they exist (prevents recalculation when manual holidays are added)
            let cutoffDates;
            if (originalCutoffDates.length === payDates.length) {
                // Reuse stored cutoff dates (manual holidays won't affect cutoff)
                cutoffDates = originalCutoffDates;
                console.log('â™»ï¸ Reusing original cutoff dates (manual holidays will not affect cutoff calculation)');
            } else {
                // Calculate fresh cutoff dates and store them
                cutoffDates = getCutoffDates(payFrequency, year, payDates, cutoffConfig, uniqueCountries);
                originalCutoffDates = cutoffDates.map(date => new Date(date)); // Store a copy
                console.log('ðŸ“… Calculated and stored original cutoff dates');
            }

            generatedCalendar = [];
            const periodManualHolidays = []; // Track manual holidays by period for proper cleanup

            payDates.forEach((payPeriod, periodIndex) => {
                let cutoffDate = cutoffDates[periodIndex];

                // Check if there's a cutoff override for this period
                if (cutoffOverrides[periodIndex]) {
                    cutoffDate = new Date(cutoffOverrides[periodIndex]);
                    console.log(`âœï¸ Cutoff override applied for period ${periodIndex}: ${cutoffDate.toDateString()}`);
                }

                // Check if there's a pay date override for this period
                let payDate = payPeriod.date;
                if (payDateOverrides[periodIndex]) {
                    payDate = new Date(payDateOverrides[periodIndex]);
                    console.log(`âœï¸ Pay date override applied for period ${periodIndex}: ${payDate.toDateString()}`);
                }

                // Add manual holiday for this period if one exists (temporarily, for this period's calculations only)
                let manualHolidayDateStr = null;
                if (manualHolidays[periodIndex]) {
                    const manualHoliday = manualHolidays[periodIndex];
                    manualHolidayDateStr = formatDateToString(manualHoliday.date);

                    // Add to employee country bank holidays (this affects working day calculations)
                    if (!bankHolidays[employeeCountry]) {
                        bankHolidays[employeeCountry] = [];
                    }

                    // Check if it's not already in the list
                    const exists = bankHolidays[employeeCountry].some(h => h.date === manualHolidayDateStr);
                    if (!exists) {
                        bankHolidays[employeeCountry].push({
                            date: manualHolidayDateStr,
                            localName: manualHoliday.name,
                            name: manualHoliday.name,
                            isManual: true // Flag to indicate this is a manually added holiday
                        });
                        // Track this for later
                        periodManualHolidays.push({
                            periodIndex,
                            dateStr: manualHolidayDateStr,
                            name: manualHoliday.name
                        });
                        console.log(`ðŸ–ï¸ Manual holiday added for period ${periodIndex}: ${manualHoliday.name} on ${manualHolidayDateStr}`);
                    }
                }

                // Find the Pay Date index (may not be at the end anymore due to afterPayDate tasks)
                const payDateIndex = tasks.findIndex(t => t.name === 'Pay Date');

                // Find earliest beforePayDate task to establish the boundary for forward tasks
                // Forward tasks must complete BEFORE any beforePayDate tasks start
                const beforePayDateTasks = tasks.filter(t => t.beforePayDate);
                let forwardTaskDeadline = payDate; // Default: forward tasks can go up to pay date

                if (beforePayDateTasks.length > 0) {
                    // Find the maximum offset among beforePayDate tasks
                    const maxBeforePayDateOffset = Math.max(...beforePayDateTasks.map(t => t.offset));
                    // Calculate the earliest date needed by beforePayDate tasks
                    const earliestBeforePayDate = calculateWorkingDate(payDate, maxBeforePayDateOffset, 'backward', uniqueCountries);
                    forwardTaskDeadline = earliestBeforePayDate;
                    console.log(`ðŸ“ Forward tasks must complete by ${earliestBeforePayDate.toDateString()} (${maxBeforePayDateOffset} days before pay date for beforePayDate tasks)`);
                }

                // Calculate available working days between cut-off and forward task deadline
                const availableWorkingDays = countWorkingDaysBetween(cutoffDate, forwardTaskDeadline, uniqueCountries);

                // Calculate required working days ONLY for tasks calculated FORWARD from cutoff
                // Exclude: Cut-Off (index 0), Pay Date, afterPayDate tasks, AND beforePayDate tasks
                // Note: beforePayDate tasks are calculated backward from pay date, so they don't consume forward timeline
                let requiredDays = 0;
                for (let i = 1; i < payDateIndex; i++) {
                    // Only count tasks that are calculated forward from previous task
                    if (!tasks[i].afterPayDate && !tasks[i].beforePayDate) {
                        requiredDays += tasks[i].offset;
                    }
                }

                // Debug logging
                const forwardTasks = tasks.slice(1, payDateIndex).filter(t => !t.afterPayDate && !t.beforePayDate);
                const tasksAfterPayDate = tasks.filter(t => t.afterPayDate);
                console.log(`Period ${periodIndex} (${payPeriod.label}):`, {
                    cutoffDate: cutoffDate.toDateString(),
                    forwardTaskDeadline: forwardTaskDeadline.toDateString(),
                    payDate: payDate.toDateString(),
                    availableWorkingDays: availableWorkingDays,
                    requiredDays: requiredDays,
                    forwardTasks: forwardTasks.map((t) => `${t.name}: ${t.offset} days`),
                    beforePayDateTasks: beforePayDateTasks.map((t) => `${t.name}: ${t.offset} days BEFORE Pay Date (protected)`),
                    tasksAfterPayDate: tasksAfterPayDate.map((t) => `${t.name}: ${t.offset} days AFTER Pay Date`),
                    note: beforePayDateTasks.length > 0
                        ? `Forward tasks must complete by ${forwardTaskDeadline.toDateString()} to avoid collision with beforePayDate tasks`
                        : 'No beforePayDate tasks - forward tasks can use full timeline to pay date'
                });

                // Check if we need to adjust
                const needsAdjustment = requiredDays > availableWorkingDays;
                const isAtCapacity = requiredDays === availableWorkingDays;
                let adjustedOffsets = tasks.map(t => t.offset);
                let adjustedTasks = [];

                if (isAtCapacity && requiredDays > 0) {
                    console.log(`âš¡ Timeline at 100% capacity: ${requiredDays} days required = ${availableWorkingDays} days available (no buffer)`);
                }

                if (needsAdjustment) {
                    console.log(`âš ï¸ Adjustment needed! Shortage: ${requiredDays - availableWorkingDays} days`);

                    // CRITICAL: "Before Pay Date" and "After Pay Date" tasks are PROTECTED and never adjusted
                    // - beforePayDate tasks: critical tasks (e.g., bank file uploads) that must maintain their offset from pay date
                    // - afterPayDate tasks: tasks that occur after pay date and don't affect the timeline before pay date
                    // We adjust OTHER tasks instead to make room for these critical timelines

                    const shortage = requiredDays - availableWorkingDays;
                    let remaining = shortage;

                    // Log protected tasks
                    const protectedTasks = tasks.filter((t, i) => i > 0 && i < tasks.length - 1 && (t.beforePayDate || t.afterPayDate));
                    if (protectedTasks.length > 0) {
                        console.log(`ðŸ”’ Protected tasks (will NOT be adjusted):`);
                        protectedTasks.forEach(t => {
                            if (t.beforePayDate) {
                                console.log(`   - ${t.name}: ${t.offset} days before Pay Date (beforePayDate = true)`);
                            } else if (t.afterPayDate) {
                                console.log(`   - ${t.name}: ${t.offset} days after Pay Date (afterPayDate = true)`);
                            }
                        });
                    }

                    // Tier 0: Constraint Awareness - Log constrained tasks
                    if (taskConstraints.length > 0) {
                        console.log(`âš¡ Task Constraints (${taskConstraints.length}):`);
                        taskConstraints.forEach(constraint => {
                            console.log(`   - ${constraint.task1Name} â‰  ${constraint.task2Name} (cannot be on same date)`);
                        });
                    }

                    // Priority 1: Payroll Sign-Off Due (if not a protected task and no constraint violation)
                    const signOffIndex = tasks.findIndex(t => t.name === 'Payroll Sign-Off Due');
                    if (remaining > 0 && signOffIndex > 0 && !tasks[signOffIndex].beforePayDate && !tasks[signOffIndex].afterPayDate && tasks[signOffIndex].offset > 1) {
                        const reduce = Math.min(remaining, tasks[signOffIndex].offset - 1);
                        const newOffset = adjustedOffsets[signOffIndex] - reduce;

                        // Check if reduction would violate a constraint
                        if (!wouldViolateConstraint(signOffIndex, newOffset, adjustedOffsets, tasks)) {
                            adjustedOffsets[signOffIndex] = newOffset;
                            remaining -= reduce;
                            if (reduce > 0) {
                                adjustedTasks.push(tasks[signOffIndex].name);
                                console.log(`  Reduced ${tasks[signOffIndex].name}: ${tasks[signOffIndex].offset} â†’ ${adjustedOffsets[signOffIndex]}`);
                            }
                        } else {
                            console.log(`  âš ï¸ Skipping ${tasks[signOffIndex].name} reduction (would violate constraint)`);
                        }
                    }

                    // Priority 2: Feedback from Client (if not a protected task and no constraint violation)
                    const feedbackIndex = tasks.findIndex(t => t.name === 'Feedback from Client');
                    if (remaining > 0 && feedbackIndex > 0 && !tasks[feedbackIndex].beforePayDate && !tasks[feedbackIndex].afterPayDate && tasks[feedbackIndex].offset > 1) {
                        const reduce = Math.min(remaining, tasks[feedbackIndex].offset - 1);
                        const newOffset = adjustedOffsets[feedbackIndex] - reduce;

                        // Check if reduction would violate a constraint
                        if (!wouldViolateConstraint(feedbackIndex, newOffset, adjustedOffsets, tasks)) {
                            adjustedOffsets[feedbackIndex] = newOffset;
                            remaining -= reduce;
                            if (reduce > 0) {
                                adjustedTasks.push(tasks[feedbackIndex].name);
                                console.log(`  Reduced ${tasks[feedbackIndex].name}: ${tasks[feedbackIndex].offset} â†’ ${adjustedOffsets[feedbackIndex]}`);
                            }
                        } else {
                            console.log(`  âš ï¸ Skipping ${tasks[feedbackIndex].name} reduction (would violate constraint)`);
                        }
                    }

                    // Priority 3: Payroll Reports Due (if not a protected task and no constraint violation)
                    const reportsIndex = tasks.findIndex(t => t.name === 'Payroll Reports Due');
                    if (remaining > 0 && reportsIndex > 0 && !tasks[reportsIndex].beforePayDate && !tasks[reportsIndex].afterPayDate && tasks[reportsIndex].offset > 1) {
                        const reduce = Math.min(remaining, tasks[reportsIndex].offset - 1);
                        const newOffset = adjustedOffsets[reportsIndex] - reduce;

                        // Check if reduction would violate a constraint
                        if (!wouldViolateConstraint(reportsIndex, newOffset, adjustedOffsets, tasks)) {
                            adjustedOffsets[reportsIndex] = newOffset;
                            remaining -= reduce;
                            if (reduce > 0) {
                                adjustedTasks.push(tasks[reportsIndex].name);
                                console.log(`  Reduced ${tasks[reportsIndex].name}: ${tasks[reportsIndex].offset} â†’ ${adjustedOffsets[reportsIndex]}`);
                            }
                        } else {
                            console.log(`  âš ï¸ Skipping ${tasks[reportsIndex].name} reduction (would violate constraint)`);
                        }
                    }

                    // Priority 4: Adjust ALL other tasks EXCEPT protected tasks (beforePayDate and afterPayDate)
                    // This ensures critical tasks maintain their required offset from pay date
                    if (remaining > 0) {
                        console.log(`âš ï¸ Still ${remaining} days short after priority adjustments. Adjusting other non-critical tasks...`);

                        // Collect all adjustable tasks (exclude cutoff, pay date, protected tasks, and already adjusted)
                        const adjustableIndices = [];
                        for (let i = 1; i < tasks.length - 1; i++) {
                            if (adjustedOffsets[i] > 0 &&
                                !tasks[i].beforePayDate &&  // NEVER adjust beforePayDate tasks
                                !tasks[i].afterPayDate &&   // NEVER adjust afterPayDate tasks
                                !adjustedTasks.includes(tasks[i].name)) {
                                adjustableIndices.push(i);
                            }
                        }

                        // Sort: prefer non-constrained tasks first
                        if (taskConstraints.length > 0) {
                            const constrainedTaskIndices = new Set();
                            taskConstraints.forEach(c => {
                                constrainedTaskIndices.add(c.task1Index);
                                constrainedTaskIndices.add(c.task2Index);
                            });

                            adjustableIndices.sort((a, b) => {
                                const aConstrained = constrainedTaskIndices.has(a);
                                const bConstrained = constrainedTaskIndices.has(b);
                                if (aConstrained === bConstrained) return 0;
                                return aConstrained ? 1 : -1; // Non-constrained tasks first
                            });
                        }

                        if (adjustableIndices.length === 0) {
                            console.log(`âš ï¸ No adjustable tasks available! All remaining tasks are protected (beforePayDate or afterPayDate).`);
                        }

                        // Reduce offsets proportionally across all adjustable tasks
                        while (remaining > 0 && adjustableIndices.length > 0) {
                            for (let idx of adjustableIndices) {
                                if (remaining <= 0) break;
                                if (adjustedOffsets[idx] > 0) {
                                    const newOffset = adjustedOffsets[idx] - 1;

                                    // Check if reduction would violate a constraint
                                    if (!wouldViolateConstraint(idx, newOffset, adjustedOffsets, tasks)) {
                                        adjustedOffsets[idx] = newOffset;
                                        remaining -= 1;
                                        if (!adjustedTasks.includes(tasks[idx].name)) {
                                            adjustedTasks.push(tasks[idx].name);
                                        }
                                        console.log(`  Reduced ${tasks[idx].name}: ${tasks[idx].offset} â†’ ${adjustedOffsets[idx]}`);
                                    } else {
                                        console.log(`  âš ï¸ Skipping ${tasks[idx].name} reduction (would violate constraint)`);
                                    }
                                }
                            }
                            // Remove tasks that have been reduced to 0
                            adjustableIndices.splice(0, adjustableIndices.length,
                                ...adjustableIndices.filter(idx => adjustedOffsets[idx] > 0));
                        }
                    }

                    if (remaining > 0) {
                        console.log(`âš ï¸ Still ${remaining} days short after all adjustments!`);
                        console.log(`   This may be because all remaining tasks are protected (beforePayDate or afterPayDate).`);
                        console.log(`   Consider: 1) Moving pay date later, 2) Reducing offsets on protected tasks, or 3) Removing non-essential tasks.`);
                    }
                }

                // Helper function: Determine which of two tasks comes earlier in sequence
                function isEarlierTask(task1Index, task2Index, tasksArray) {
                    // For tasks in the same array, lower index = earlier (unless one is beforePayDate)
                    const task1 = tasksArray[task1Index];
                    const task2 = tasksArray[task2Index];

                    // Both beforePayDate: compare by proximity to pay date (larger offset = earlier)
                    if (task1.beforePayDate && task2.beforePayDate) {
                        return task1.offset > task2.offset;
                    }

                    // One is beforePayDate, one is forward: forward task is earlier
                    if (task1.beforePayDate && !task2.beforePayDate && !task2.afterPayDate) return false;
                    if (task2.beforePayDate && !task1.beforePayDate && !task1.afterPayDate) return true;

                    // Both afterPayDate: compare by offset (smaller offset = earlier, closer to pay date)
                    if (task1.afterPayDate && task2.afterPayDate) {
                        return task1.offset < task2.offset;
                    }

                    // Default: use array position
                    return task1Index < task2Index;
                }

                // Helper function: Check if reducing a task's offset would violate a constraint
                function wouldViolateConstraint(taskIndex, newOffset, currentOffsets, tasksArray) {
                    // Simplified prediction: check if any constrained task pair would have same offset
                    for (const constraint of taskConstraints) {
                        if (constraint.task1Index === taskIndex || constraint.task2Index === taskIndex) {
                            const otherIndex = constraint.task1Index === taskIndex ? constraint.task2Index : constraint.task1Index;

                            // If adjusting this task would make offsets equal, might cause same-date
                            const thisNewOffset = (taskIndex === constraint.task1Index || taskIndex === constraint.task2Index) ? newOffset : currentOffsets[taskIndex];
                            const otherOffset = currentOffsets[otherIndex];

                            // Same offset = likely same date (simplified check)
                            if (thisNewOffset === otherOffset) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                // Resolve constraint conflict: Move earlier task back to create separation
                function resolveConstraintConflict(earlierTaskIndex, laterTaskIndex, periodTasks, tasksArray) {
                    // Resolution principle: Later task keeps its date, earlier task moves back
                    console.log(`ðŸ”§ Resolving constraint: moving earlier task (index ${earlierTaskIndex}) back`);

                    // Increase earlier task's offset by 1 to create separation
                    if (earlierTaskIndex >= 0 && earlierTaskIndex < tasksArray.length) {
                        tasksArray[earlierTaskIndex].offset += 1;
                        console.log(`   â†‘ Increased "${tasksArray[earlierTaskIndex].name}" offset to ${tasksArray[earlierTaskIndex].offset}`);
                        return true;
                    }

                    return false;
                }

                // Helper function: Recalculate period dates with current task offsets
                // Used for initial calculation and after automatic constraint resolution
                function recalculatePeriodDates(periodIdx, tasksArr, adjOffsets, cutoff, pay, countries, payPeriod, adjustedTasksList = []) {
                    const periodTasks = [];
                    let currentDate = new Date(cutoff);

                    // Add cutoff task
                    periodTasks.push({
                        period: periodIdx,
                        periodLabel: payPeriod.label,
                        task: tasksArr[0].name,
                        date: new Date(cutoff),
                        month: payPeriod.month,
                        periodInMonth: payPeriod.periodInMonth,
                        adjusted: false
                    });

                    // Calculate dates using three-pass method
                    const taskDates = new Map();
                    taskDates.set(0, new Date(cutoff));

                    // First pass: Forward from previous task
                    for (let i = 1; i < tasksArr.length; i++) {
                        if (tasksArr[i].name === 'Pay Date') continue;
                        if (!tasksArr[i].beforePayDate && !tasksArr[i].afterPayDate) {
                            const offsetToUse = adjOffsets[i];
                            currentDate = calculateWorkingDate(currentDate, offsetToUse, 'forward', countries);
                            taskDates.set(i, new Date(currentDate));
                        }
                    }

                    // Second pass: Backward from pay date
                    for (let i = tasksArr.length - 1; i >= 1; i--) {
                        if (tasksArr[i].name === 'Pay Date') continue;
                        if (tasksArr[i].beforePayDate) {
                            const offsetToUse = adjOffsets[i];
                            const taskDate = calculateWorkingDate(pay, offsetToUse, 'backward', countries);
                            taskDates.set(i, new Date(taskDate));
                        }
                    }

                    // Third pass: Forward from pay date
                    for (let i = 1; i < tasksArr.length; i++) {
                        if (tasksArr[i].name === 'Pay Date') continue;
                        if (tasksArr[i].afterPayDate) {
                            const offsetToUse = adjOffsets[i];
                            const taskDate = calculateWorkingDate(pay, offsetToUse, 'forward', countries);
                            taskDates.set(i, new Date(taskDate));
                        }
                    }

                    // Build periodTasks array
                    for (let i = 1; i < tasksArr.length; i++) {
                        if (tasksArr[i].name === 'Pay Date') continue;

                        const wasAdjusted = adjustedTasksList.includes(tasksArr[i].name) ||
                                          (tasksArr[i].offset !== adjOffsets[i]);

                        periodTasks.push({
                            period: periodIdx,
                            periodLabel: payPeriod.label,
                            task: tasksArr[i].name,
                            date: taskDates.get(i),
                            month: payPeriod.month,
                            periodInMonth: payPeriod.periodInMonth,
                            adjusted: wasAdjusted,
                            originalOffset: tasksArr[i].offset,
                            adjustedOffset: adjOffsets[i]
                        });
                    }

                    // Add Pay Date
                    const payDateTaskIndex = tasksArr.findIndex(t => t.name === 'Pay Date');
                    periodTasks.push({
                        period: periodIdx,
                        periodLabel: payPeriod.label,
                        task: tasksArr[payDateTaskIndex].name,
                        date: new Date(pay),
                        month: payPeriod.month,
                        periodInMonth: payPeriod.periodInMonth,
                        adjusted: false,
                        originalOffset: tasksArr[payDateTaskIndex].offset,
                        adjustedOffset: tasksArr[payDateTaskIndex].offset
                    });

                    return periodTasks;
                }

                // Generate tasks with adjusted offsets
                let currentDate = new Date(cutoffDate);
                const periodTasks = [];

                periodTasks.push({
                    period: periodIndex,
                    periodLabel: payPeriod.label,
                    task: tasks[0].name,
                    date: new Date(cutoffDate),
                    month: payPeriod.month,
                    periodInMonth: payPeriod.periodInMonth,
                    adjusted: false
                });

                // First pass: Generate tasks that are calculated from previous (forward)
                // We'll handle "before pay date" and "after pay date" tasks separately
                const taskDates = new Map();
                taskDates.set(0, new Date(cutoffDate));

                for (let i = 1; i < tasks.length; i++) {
                    if (tasks[i].name === 'Pay Date') continue; // Skip Pay Date
                    if (!tasks[i].beforePayDate && !tasks[i].afterPayDate) {
                        // Calculate forward from previous task
                        const offsetToUse = adjustedOffsets[i];
                        currentDate = calculateWorkingDate(currentDate, offsetToUse, 'forward', uniqueCountries);
                        taskDates.set(i, new Date(currentDate));
                    }
                }

                // Second pass: Generate tasks that are calculated before pay date (backward)
                for (let i = tasks.length - 1; i >= 1; i--) {
                    if (tasks[i].name === 'Pay Date') continue; // Skip Pay Date
                    if (tasks[i].beforePayDate) {
                        // Calculate backward from pay date
                        const offsetToUse = adjustedOffsets[i];
                        const taskDate = calculateWorkingDate(payDate, offsetToUse, 'backward', uniqueCountries);
                        taskDates.set(i, new Date(taskDate));
                        console.log(`ðŸ“… ${tasks[i].name} calculated ${offsetToUse} working days before pay date: ${taskDate.toDateString()}`);
                    }
                }

                // Third pass: Generate tasks that occur AFTER pay date (forward from pay date)
                for (let i = 1; i < tasks.length; i++) {
                    if (tasks[i].name === 'Pay Date') continue; // Skip Pay Date
                    if (tasks[i].afterPayDate) {
                        // Calculate forward from pay date
                        const offsetToUse = adjustedOffsets[i];
                        const taskDate = calculateWorkingDate(payDate, offsetToUse, 'forward', uniqueCountries);
                        taskDates.set(i, new Date(taskDate));
                        console.log(`ðŸ“… ${tasks[i].name} calculated ${offsetToUse} working days AFTER pay date: ${taskDate.toDateString()}`);
                    }
                }

                // Add all tasks to periodTasks (except Cut-Off and Pay Date which are handled separately)
                for (let i = 1; i < tasks.length; i++) {
                    // Skip Pay Date - it's added separately below
                    if (tasks[i].name === 'Pay Date') continue;

                    // Check if this task was adjusted (either in array OR offset changed)
                    const wasAdjusted = adjustedTasks.includes(tasks[i].name) ||
                                       (tasks[i].offset !== adjustedOffsets[i]);

                    if (wasAdjusted) {
                        console.log(`âœ“ Period ${periodIndex}: Task "${tasks[i].name}" was adjusted: ${tasks[i].offset}â†’${adjustedOffsets[i]}`);
                    }

                    const taskEntry = {
                        period: periodIndex,
                        periodLabel: payPeriod.label,
                        task: tasks[i].name,
                        date: taskDates.get(i),
                        month: payPeriod.month,
                        periodInMonth: payPeriod.periodInMonth,
                        adjusted: wasAdjusted,
                        originalOffset: tasks[i].offset,
                        adjustedOffset: adjustedOffsets[i]
                    };

                    periodTasks.push(taskEntry);
                }

                // Validate chronological order - log warning if tasks are out of order
                for (let i = 1; i < tasks.length - 1; i++) {
                    const currentTaskDate = taskDates.get(i);
                    const previousTaskDate = taskDates.get(i - 1);

                    if (currentTaskDate < previousTaskDate) {
                        console.warn(`âš ï¸ WARNING: Task "${tasks[i].name}" (${currentTaskDate.toDateString()}) is EARLIER than previous task "${tasks[i-1].name}" (${previousTaskDate.toDateString()}). This may indicate an issue with beforePayDate tasks.`);
                    }
                }

                // PAY DATE: Always use the ORIGINAL pay date, never calculate it
                // The pay date only moves if it falls on a weekend/holiday (already handled in getPayDates)
                // Find Pay Date task dynamically (it may not be at the end due to afterPayDate tasks)
                const payDateTaskIndex = tasks.findIndex(t => t.name === 'Pay Date');
                periodTasks.push({
                    period: periodIndex,
                    periodLabel: payPeriod.label,
                    task: tasks[payDateTaskIndex].name,
                    date: new Date(payDate),  // Use ORIGINAL pay date, not calculated
                    month: payPeriod.month,
                    periodInMonth: payPeriod.periodInMonth,
                    adjusted: false,  // Pay date never adjusted, it's fixed
                    originalOffset: tasks[payDateTaskIndex].offset,
                    adjustedOffset: tasks[payDateTaskIndex].offset,
                    // Store pay date adjustment info for display
                    payDateWasAdjusted: payPeriod.wasAdjusted,
                    payDateOriginal: payPeriod.originalDate,
                    payDateAdjustmentReason: payPeriod.adjustmentReason,
                    payDateDaysShifted: payPeriod.daysShifted
                });

                console.log(`âœ“ Pay Date set to original: ${payDate.toDateString()}`);

                // Apply manual task date overrides if any exist for this period
                periodTasks.forEach(taskEntry => {
                    const overrideKey = `${periodIndex}-${taskEntry.task}`;
                    if (taskDateOverrides[overrideKey]) {
                        console.log(`âœï¸ Applying manual override for "${taskEntry.task}" in period ${periodIndex}`);
                        taskEntry.date = new Date(taskDateOverrides[overrideKey]);
                        taskEntry.manuallyOverridden = true; // Flag for visual indicator
                    }
                });

                generatedCalendar.push(...periodTasks);

                // Validate task constraints for this period
                if (taskConstraints.length > 0) {
                    let violations = validateTaskConstraints(periodTasks, periodIndex);
                    if (violations.length > 0) {
                        // Store violations in a global map for display during rendering
                        if (!window.constraintViolations) {
                            window.constraintViolations = {};
                        }
                        window.constraintViolations[periodIndex] = violations;

                        // NEW v3.2: Attempt automatic resolution
                        console.log(`ðŸ”§ Attempting to resolve ${violations.length} constraint violation(s) in period ${periodIndex}...`);

                        let resolutionAttempts = 0;
                        const maxAttempts = 5; // Prevent infinite loop
                        let currentViolations = violations;
                        const resolvedConstraints = new Set(); // Track which constraints we've tried to resolve

                        while (currentViolations.length > 0 && resolutionAttempts < maxAttempts) {
                            resolutionAttempts++;
                            let madeChanges = false;

                            for (const violation of currentViolations) {
                                // Create a unique key for this constraint (order-independent)
                                const constraintKey = [violation.task1, violation.task2].sort().join('|');

                                // Skip if we've already tried to resolve this constraint
                                if (resolvedConstraints.has(constraintKey)) continue;

                                // Find task indices for this violation
                                const task1Index = tasks.findIndex(t => t.name === violation.task1);
                                const task2Index = tasks.findIndex(t => t.name === violation.task2);

                                if (task1Index === -1 || task2Index === -1) continue;

                                // Determine protection status - "before pay date" tasks are CRITICAL
                                const task1Protected = tasks[task1Index].beforePayDate === true;
                                const task2Protected = tasks[task2Index].beforePayDate === true;

                                let adjustedIndex = -1;
                                let adjustmentDirection = '';

                                // Business priority: protect "before pay date" tasks at all costs
                                if (task1Protected && task2Protected) {
                                    // Both tasks are critical - cannot auto-resolve
                                    console.log(`   âš ï¸ Cannot resolve: Both "${tasks[task1Index].name}" and "${tasks[task2Index].name}" are critical (before pay date)`);
                                    resolvedConstraints.add(constraintKey);
                                    continue;
                                } else if (task1Protected) {
                                    // Task 1 is critical - adjust task 2 by moving it earlier
                                    adjustedIndex = task2Index;
                                    adjustmentDirection = 'decrease';
                                } else if (task2Protected) {
                                    // Task 2 is critical - adjust task 1 by moving it earlier
                                    adjustedIndex = task1Index;
                                    adjustmentDirection = 'decrease';
                                } else {
                                    // Neither protected - adjust the later task in list (move it earlier)
                                    adjustedIndex = task1Index > task2Index ? task1Index : task2Index;
                                    adjustmentDirection = 'decrease';
                                }

                                // Check if adjustment is possible
                                const originalOffset = adjustedOffsets[adjustedIndex];

                                if (adjustmentDirection === 'decrease') {
                                    // For "after previous task" tasks, decreasing offset moves them earlier
                                    if (originalOffset <= 1) {
                                        console.log(`   âš ï¸ Cannot adjust "${tasks[adjustedIndex].name}" - already at minimum offset (1 day)`);
                                        resolvedConstraints.add(constraintKey);
                                        continue;
                                    }
                                    adjustedOffsets[adjustedIndex] -= 1;
                                    console.log(`   Attempt ${resolutionAttempts}: Decreased "${tasks[adjustedIndex].name}" offset: ${originalOffset} â†’ ${adjustedOffsets[adjustedIndex]} (moved earlier)`);
                                } else {
                                    // Fallback: increase offset (shouldn't normally reach here)
                                    adjustedOffsets[adjustedIndex] += 1;
                                    console.log(`   Attempt ${resolutionAttempts}: Increased "${tasks[adjustedIndex].name}" offset: ${originalOffset} â†’ ${adjustedOffsets[adjustedIndex]}`);
                                }

                                madeChanges = true;
                                resolvedConstraints.add(constraintKey);

                                // Mark this task as adjusted
                                if (!adjustedTasks.includes(tasks[adjustedIndex].name)) {
                                    adjustedTasks.push(tasks[adjustedIndex].name);
                                }
                            }

                            if (madeChanges) {
                                // Recalculate dates for this period with new offsets
                                const recalculatedTasks = recalculatePeriodDates(
                                    periodIndex,
                                    tasks,
                                    adjustedOffsets,
                                    cutoffDate,
                                    payDate,
                                    uniqueCountries,
                                    payPeriod,
                                    adjustedTasks
                                );

                                // Update periodTasks with recalculated dates
                                periodTasks.length = 0;
                                periodTasks.push(...recalculatedTasks);

                                // Validate again
                                currentViolations = validateTaskConstraints(periodTasks, periodIndex);

                                if (currentViolations.length === 0) {
                                    console.log(`   âœ… All constraints resolved after ${resolutionAttempts} attempt(s)`);
                                    delete window.constraintViolations[periodIndex];
                                } else {
                                    console.log(`   âš ï¸ ${currentViolations.length} violation(s) remaining`);
                                }
                            } else {
                                // No more changes can be made
                                break;
                            }
                        }

                        // FIX v3.7: Always update generatedCalendar with latest task dates,
                        // even if some violations remain (ensures calendar shows current state)
                        const startIndex = generatedCalendar.findIndex(t => t.period === periodIndex);
                        if (startIndex !== -1) {
                            const endIndex = generatedCalendar.findLastIndex(t => t.period === periodIndex);
                            generatedCalendar.splice(startIndex, endIndex - startIndex + 1, ...periodTasks);
                        }

                        if (currentViolations.length > 0) {
                            console.log(`   âŒ Could not resolve all constraints after ${resolutionAttempts} attempt(s)`);
                            console.log(`   Suggestion: Manually adjust task offsets, move pay date later, or remove constraints`);
                            // Keep violations in window.constraintViolations for display
                        } else {
                            console.log(`   âœ… All constraints resolved and calendar updated`);
                        }
                    }
                }

                // IMPORTANT: Remove manual holiday immediately after processing this period
                // This prevents it from affecting subsequent periods
                if (manualHolidayDateStr) {
                    bankHolidays[employeeCountry] = bankHolidays[employeeCountry].filter(h => h.date !== manualHolidayDateStr);
                    console.log(`ðŸ§¹ Cleaned up manual holiday for period ${periodIndex} (prevents cross-period contamination)`);
                }
            });

            // ========================================
            // OFF-CYCLE GENERATION (v4.0)
            // ========================================
            if (offCyclePeriods.length > 0) {
                console.log(`ðŸ”„ Generating ${offCyclePeriods.length} off-cycle configuration(s)...`);

                offCyclePeriods.forEach((offCycleConfig, configIndex) => {
                    console.log(`  Processing off-cycle config #${configIndex + 1}:`, offCycleConfig);

                    offCycleConfig.relativeToPeriods.forEach(relativePeriodIdx => {
                        // Find the actual period in generatedCalendar (skip existing off-cycles)
                        const onCyclePeriods = generatedCalendar.filter(entry => !entry.isOffCycle);
                        const referencePeriodTasks = onCyclePeriods.filter(entry => entry.period === relativePeriodIdx);

                        if (referencePeriodTasks.length === 0) {
                            console.warn(`âš ï¸ Reference period ${relativePeriodIdx} not found, skipping off-cycle`);
                            return;
                        }

                        const referencePayDateEntry = referencePeriodTasks.find(entry => entry.task === 'Pay Date');
                        if (!referencePayDateEntry) {
                            console.warn(`âš ï¸ Pay Date not found for period ${relativePeriodIdx}, skipping off-cycle`);
                            return;
                        }

                        const referencePayDate = referencePayDateEntry.date;
                        const referenceLabel = referencePeriodTasks[0].periodLabel;

                        // Calculate off-cycle pay date
                        let offCyclePayDate;
                        if (offCycleConfig.payDates.mode === 'manual' && offCycleConfig.payDates.dates[relativePeriodIdx]) {
                            offCyclePayDate = new Date(offCycleConfig.payDates.dates[relativePeriodIdx]);
                        } else {
                            // Use offset mode
                            offCyclePayDate = new Date(referencePayDate);
                            const offsetDays = offCycleConfig.payDates.offsetDays || 7;
                            if (offCycleConfig.placement === 'before') {
                                offCyclePayDate.setDate(offCyclePayDate.getDate() - offsetDays);
                            } else {
                                offCyclePayDate.setDate(offCyclePayDate.getDate() + offsetDays);
                            }
                        }

                        // Adjust for weekends/holidays
                        const adjustedPayDate = moveToPriorWorkingDay(offCyclePayDate, uniqueCountries);
                        offCyclePayDate = adjustedPayDate.date;

                        // Determine off-cycle period index (using decimal notation)
                        let offCyclePeriodIndex;
                        if (offCycleConfig.placement === 'before') {
                            offCyclePeriodIndex = relativePeriodIdx - 0.5;
                        } else {
                            offCyclePeriodIndex = relativePeriodIdx + 0.5;
                        }

                        // Generate off-cycle label - use custom name if provided
                        let offCycleLabel;
                        if (offCycleConfig.customName && offCycleConfig.customName.trim()) {
                            offCycleLabel = offCycleConfig.customName.trim();
                        } else {
                            offCycleLabel = `${referenceLabel} ${offCycleConfig.placement === 'before' ? 'Pre' : 'Post'}-Off-Cycle`;
                        }

                        // Determine which tasks to include
                        let offCycleTasks = [];
                        if (offCycleConfig.tasks.mode === 'custom' && offCycleConfig.tasks.selectedTasks.length > 0) {
                            offCycleTasks = offCycleConfig.tasks.selectedTasks.map(idx => tasks[idx]);
                            // v4.0: Always include Pay Date for off-cycles (it's configured in Step 3, not Step 4)
                            const payDateTask = tasks.find(t => t.name === 'Pay Date');
                            if (payDateTask && !offCycleTasks.includes(payDateTask)) {
                                offCycleTasks.unshift(payDateTask); // Add at beginning
                            }
                        } else {
                            // Use all tasks
                            offCycleTasks = [...tasks];
                        }

                        // Get task offsets
                        const offCycleOffsets = {};
                        offCycleTasks.forEach((task, idx) => {
                            const taskIndex = tasks.indexOf(task);
                            if (offCycleConfig.tasks.offsets.mode === 'custom' && offCycleConfig.tasks.offsets.customOffsets[taskIndex] !== undefined) {
                                offCycleOffsets[taskIndex] = offCycleConfig.tasks.offsets.customOffsets[taskIndex];
                            } else {
                                offCycleOffsets[taskIndex] = task.offset;
                            }
                        });

                        // Calculate cutoff date for off-cycle
                        let offCycleCutoffDate = new Date(offCyclePayDate);
                        const cutoffOffset = offCycleOffsets[0] || 10; // Use Payroll Cut Off offset
                        for (let i = 0; i < cutoffOffset; i++) {
                            offCycleCutoffDate.setDate(offCycleCutoffDate.getDate() - 1);
                            while (isWeekend(offCycleCutoffDate, uniqueCountries) || isNonWorkingDay(offCycleCutoffDate, uniqueCountries)) {
                                offCycleCutoffDate.setDate(offCycleCutoffDate.getDate() - 1);
                            }
                        }

                        // Generate task entries for off-cycle
                        const offCyclePeriodTasks = [];

                        offCycleTasks.forEach((task, idx) => {
                            const taskIndex = tasks.indexOf(task);
                            const taskOffset = offCycleOffsets[taskIndex];
                            let taskDate;

                            // v4.0: Check if a specific date was provided for this task
                            // Priority order:
                            // 1. Period-specific date (for individual config): "periodIdx_taskIndex"
                            // 2. First period's date (for apply-to-all): "firstPeriodIdx_taskIndex"
                            // 3. Simple key (backwards compatibility): "taskIndex"
                            const compositeKey = `${relativePeriodIdx}_${taskIndex}`;
                            const firstPeriodKey = `${offCycleConfig.relativeToPeriods[0]}_${taskIndex}`;
                            const hasSpecificDate = offCycleConfig.tasks.offsets.specificDates &&
                                                   (offCycleConfig.tasks.offsets.specificDates[compositeKey] ||
                                                    offCycleConfig.tasks.offsets.specificDates[firstPeriodKey] ||
                                                    offCycleConfig.tasks.offsets.specificDates[taskIndex]);

                            if (hasSpecificDate) {
                                // Use the specific date provided
                                const storedDate = offCycleConfig.tasks.offsets.specificDates[compositeKey] ||
                                                  offCycleConfig.tasks.offsets.specificDates[firstPeriodKey] ||
                                                  offCycleConfig.tasks.offsets.specificDates[taskIndex];

                                // v4.0: If using first period's date as reference (apply-to-all scenario),
                                // calculate the equivalent date for this period based on the offset from first OFF-CYCLE's pay date
                                if (offCycleConfig.tasks.offsets.specificDates[firstPeriodKey] && !offCycleConfig.tasks.offsets.specificDates[compositeKey]) {
                                    // This is an apply-to-all scenario
                                    // Calculate what the first off-cycle's pay date would be
                                    const firstRelativePeriodIdx = offCycleConfig.relativeToPeriods[0];
                                    const firstRefPeriod = generatedCalendar.find(e => e.period === firstRelativePeriodIdx && e.task === 'Pay Date' && !e.isOffCycle);

                                    if (firstRefPeriod) {
                                        let firstOffCyclePayDate;
                                        if (offCycleConfig.payDates.mode === 'manual' && offCycleConfig.payDates.dates[firstRelativePeriodIdx]) {
                                            firstOffCyclePayDate = new Date(offCycleConfig.payDates.dates[firstRelativePeriodIdx]);
                                        } else {
                                            // Calculate from reference period and offset
                                            firstOffCyclePayDate = new Date(firstRefPeriod.date);
                                            const offsetDays = offCycleConfig.payDates.offsetDays || 7;
                                            if (offCycleConfig.placement === 'before') {
                                                firstOffCyclePayDate.setDate(firstOffCyclePayDate.getDate() - offsetDays);
                                            } else {
                                                firstOffCyclePayDate.setDate(firstOffCyclePayDate.getDate() + offsetDays);
                                            }
                                        }

                                        // Adjust for weekends/holidays
                                        const adjustedFirst = moveToPriorWorkingDay(firstOffCyclePayDate, uniqueCountries);
                                        firstOffCyclePayDate = adjustedFirst.date;

                                        // Calculate the working days offset between the stored date and first off-cycle's pay date
                                        const storedTaskDate = new Date(storedDate);

                                        // Calculate working days difference
                                        let daysDiff = 0;
                                        let isBeforePayDate = storedTaskDate < firstOffCyclePayDate;
                                        let tempDate = new Date(isBeforePayDate ? storedTaskDate : firstOffCyclePayDate);
                                        let endDate = new Date(isBeforePayDate ? firstOffCyclePayDate : storedTaskDate);

                                        while (tempDate < endDate) {
                                            tempDate.setDate(tempDate.getDate() + 1);
                                            if (!isWeekend(tempDate, uniqueCountries) && !isNonWorkingDay(tempDate, uniqueCountries)) {
                                                daysDiff++;
                                            }
                                        }

                                        // Apply the same working days offset to current off-cycle's pay date
                                        taskDate = new Date(offCyclePayDate);
                                        if (isBeforePayDate) {
                                            // Task was before pay date in first off-cycle
                                            for (let i = 0; i < daysDiff; i++) {
                                                taskDate.setDate(taskDate.getDate() - 1);
                                                while (isWeekend(taskDate, uniqueCountries) || isNonWorkingDay(taskDate, uniqueCountries)) {
                                                    taskDate.setDate(taskDate.getDate() - 1);
                                                }
                                            }
                                        } else {
                                            // Task was after pay date in first off-cycle
                                            for (let i = 0; i < daysDiff; i++) {
                                                taskDate.setDate(taskDate.getDate() + 1);
                                                while (isWeekend(taskDate, uniqueCountries) || isNonWorkingDay(taskDate, uniqueCountries)) {
                                                    taskDate.setDate(taskDate.getDate() + 1);
                                                }
                                            }
                                        }
                                    } else {
                                        // Fallback: use stored date directly
                                        taskDate = new Date(storedDate);
                                    }
                                } else {
                                    // Use the stored date directly (period-specific or simple key)
                                    taskDate = new Date(storedDate);
                                }
                            } else if (task.name === 'Pay Date') {
                                taskDate = new Date(offCyclePayDate);
                            } else if (task.name === 'Payroll Cut Off') {
                                taskDate = new Date(offCycleCutoffDate);
                            } else {
                                // Calculate based on offset and anchor
                                if (task.beforePayDate) {
                                    taskDate = new Date(offCyclePayDate);
                                    for (let i = 0; i < Math.abs(taskOffset); i++) {
                                        taskDate.setDate(taskDate.getDate() - 1);
                                        while (isWeekend(taskDate, uniqueCountries) || isNonWorkingDay(taskDate, uniqueCountries)) {
                                            taskDate.setDate(taskDate.getDate() - 1);
                                        }
                                    }
                                } else if (task.afterPayDate) {
                                    taskDate = new Date(offCyclePayDate);
                                    for (let i = 0; i < Math.abs(taskOffset); i++) {
                                        taskDate.setDate(taskDate.getDate() + 1);
                                        while (isWeekend(taskDate, uniqueCountries) || isNonWorkingDay(taskDate, uniqueCountries)) {
                                            taskDate.setDate(taskDate.getDate() + 1);
                                        }
                                    }
                                } else {
                                    // Default: offset from cutoff
                                    taskDate = new Date(offCycleCutoffDate);
                                    const offsetFromCutoff = taskOffset - cutoffOffset;
                                    if (offsetFromCutoff < 0) {
                                        for (let i = 0; i < Math.abs(offsetFromCutoff); i++) {
                                            taskDate.setDate(taskDate.getDate() - 1);
                                            while (isWeekend(taskDate, uniqueCountries) || isNonWorkingDay(taskDate, uniqueCountries)) {
                                                taskDate.setDate(taskDate.getDate() - 1);
                                            }
                                        }
                                    } else {
                                        for (let i = 0; i < offsetFromCutoff; i++) {
                                            taskDate.setDate(taskDate.getDate() + 1);
                                            while (isWeekend(taskDate, uniqueCountries) || isNonWorkingDay(taskDate, uniqueCountries)) {
                                                taskDate.setDate(taskDate.getDate() + 1);
                                            }
                                        }
                                    }
                                }
                            }

                            offCyclePeriodTasks.push({
                                period: offCyclePeriodIndex,
                                periodLabel: offCycleLabel,
                                task: task.name,
                                date: taskDate,
                                month: taskDate.getMonth(),
                                periodInMonth: 1,
                                adjusted: false,
                                originalOffset: taskOffset,
                                adjustedOffset: taskOffset,
                                isOffCycle: true,
                                offCycleConfigId: offCycleConfig.id
                            });
                        });

                        // Add off-cycle tasks to generated calendar
                        generatedCalendar.push(...offCyclePeriodTasks);

                        console.log(`  âœ… Generated off-cycle ${offCycleLabel} with ${offCyclePeriodTasks.length} tasks`);
                    });
                });

                // Sort generatedCalendar by period index to maintain proper order
                generatedCalendar.sort((a, b) => {
                    if (a.period !== b.period) return a.period - b.period;
                    // Within same period, sort by date
                    return a.date - b.date;
                });

                console.log(`âœ… Off-cycle generation complete. Total calendar entries: ${generatedCalendar.length}`);
            }

            // Re-add all manual holidays before rendering so they show up in the UI
            if (periodManualHolidays.length > 0) {
                if (!bankHolidays[employeeCountry]) {
                    bankHolidays[employeeCountry] = [];
                }
                periodManualHolidays.forEach(mh => {
                    const exists = bankHolidays[employeeCountry].some(h => h.date === mh.dateStr);
                    if (!exists) {
                        bankHolidays[employeeCountry].push({
                            date: mh.dateStr,
                            localName: mh.name,
                            name: mh.name,
                            isManual: true
                        });
                    }
                });
                console.log(`ðŸ“Œ Re-added ${periodManualHolidays.length} manual holiday(ies) for UI rendering`);
            }

            renderCalendar(uniqueCountries, year, payFrequency);

            // DO NOT clean up manual holidays - they need to persist for Excel/PDF export
            // Duplicate prevention is handled in the re-add code above (checks if exists before adding)
            console.log(`âœ… Manual holidays kept in bankHolidays array for export functionality`);

            showMessage('Calendar generated successfully!', 'success');
        }

        function ignoreHoliday(holidayKey) {
            if (!ignoredHolidays.includes(holidayKey)) {
                ignoredHolidays.push(holidayKey);
            }
            // Regenerate calendar without ignored holidays
            generateCalendar(true); // Preserve cutoffs when ignoring holidays
        }

        function restoreHoliday(holidayKey) {
            const index = ignoredHolidays.indexOf(holidayKey);
            if (index > -1) {
                ignoredHolidays.splice(index, 1);
            }
            // Regenerate calendar with restored holiday
            generateCalendar(true); // Preserve cutoffs when restoring holidays
        }

        function renderCalendar(uniqueCountries, year, frequency) {
            const section = document.getElementById('calendarSection');
            const preview = document.getElementById('calendarPreview');

            if (generatedCalendar.length === 0) {
                section.classList.add('hidden');
                return;
            }

            section.classList.remove('hidden');

            const calendarByPeriod = {};
            generatedCalendar.forEach(entry => {
                if (!calendarByPeriod[entry.period]) {
                    calendarByPeriod[entry.period] = {
                        label: entry.periodLabel,
                        tasks: {},
                        holidays: [],
                        month: entry.month,
                        periodInMonth: entry.periodInMonth,
                        hasHolidayImpact: false,
                        hasAdjustment: false,
                        adjustedTasks: [],
                        overriddenTasks: [], // Track manually overridden tasks
                        payDateAdjustment: null, // Store pay date adjustment info if shifted due to holiday
                        isOffCycle: entry.isOffCycle || false, // v4.0: Track if this is an off-cycle period
                        offCycleConfigId: entry.offCycleConfigId // v4.0: Store off-cycle config ID for editing
                    };
                }
                calendarByPeriod[entry.period].tasks[entry.task] = entry.date;

                // Track if this task was manually overridden
                if (entry.manuallyOverridden) {
                    calendarByPeriod[entry.period].overriddenTasks.push(entry.task);
                }

                // Store pay date adjustment info if this is the Pay Date task and it was adjusted
                if (entry.task === 'Pay Date' && entry.payDateWasAdjusted) {
                    calendarByPeriod[entry.period].payDateAdjustment = {
                        originalDate: entry.payDateOriginal,
                        adjustedDate: entry.date,
                        daysShifted: entry.payDateDaysShifted,
                        reason: entry.payDateAdjustmentReason
                    };
                }

                if (entry.adjusted) {
                    calendarByPeriod[entry.period].hasAdjustment = true;
                    const adjustedTask = {
                        name: entry.task,
                        originalOffset: entry.originalOffset,
                        adjustedOffset: entry.adjustedOffset
                    };
                    calendarByPeriod[entry.period].adjustedTasks.push(adjustedTask);
                    console.log(`ðŸ“Š Adding adjusted task to display:`, {
                        period: entry.period,
                        task: adjustedTask.name,
                        original: adjustedTask.originalOffset,
                        adjusted: adjustedTask.adjustedOffset
                    });
                }
            });

            // Assign holidays and check for impact
            uniqueCountries.forEach(country => {
                if (bankHolidays[country]) {
                    bankHolidays[country].forEach(holiday => {
                        const holidayDate = new Date(holiday.date);

                        Object.keys(calendarByPeriod).forEach(period => {
                            const periodData = calendarByPeriod[period];

                            // Determine if holiday falls within this pay period
                            let isInPeriod = false;

                            if (frequency === 'monthly') {
                                // For monthly: Only include holidays from the same calendar month
                                isInPeriod = (holidayDate.getMonth() === periodData.month && holidayDate.getFullYear() === year);
                            } else if (frequency === 'semi-monthly') {
                                // For semi-monthly: Check both month AND which period (P1 or P2)
                                if (holidayDate.getMonth() === periodData.month && holidayDate.getFullYear() === year) {
                                    const payDate = periodData.tasks['Pay Date'];

                                    if (periodData.periodInMonth === 1) {
                                        // P1: Include holidays from start of month up to P1 pay date
                                        isInPeriod = (holidayDate <= payDate);
                                    } else if (periodData.periodInMonth === 2) {
                                        // P2: Include holidays after P1 pay date through end of month
                                        // Find P1 pay date for this month
                                        const p1Period = Object.values(calendarByPeriod).find(p =>
                                            p.month === periodData.month && p.periodInMonth === 1
                                        );
                                        if (p1Period && p1Period.tasks['Pay Date']) {
                                            const p1PayDate = p1Period.tasks['Pay Date'];
                                            isInPeriod = (holidayDate > p1PayDate);
                                        }
                                    }
                                }
                            } else {
                                // For bi-weekly/weekly: Each period runs from day after previous pay date to current pay date
                                const payDate = periodData.tasks['Pay Date'];
                                if (payDate) {
                                    // Find the previous period's pay date
                                    const allPeriods = Object.keys(calendarByPeriod).map(p => ({
                                        period: p,
                                        payDate: calendarByPeriod[p].tasks['Pay Date']
                                    })).sort((a, b) => a.payDate - b.payDate);

                                    const currentIndex = allPeriods.findIndex(p => p.period === period);

                                    if (currentIndex === 0) {
                                        // First period: from start of year (or reasonable start) to pay date
                                        const periodStart = new Date(year, 0, 1);
                                        isInPeriod = (holidayDate >= periodStart && holidayDate <= payDate);
                                    } else {
                                        // Other periods: from day after previous pay date to current pay date
                                        const previousPayDate = allPeriods[currentIndex - 1].payDate;
                                        const periodStart = new Date(previousPayDate);
                                        periodStart.setDate(periodStart.getDate() + 1); // Day after previous pay date
                                        isInPeriod = (holidayDate >= periodStart && holidayDate <= payDate);
                                    }
                                }
                            }

                            if (isInPeriod) {
                                // Show all holidays within the pay period boundaries
                                // (holidays affect working day calculations even if outside task date range)
                                const countryName = countries.find(c => c.code === country)?.name || country;
                                const dateStr = holidayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });

                                // Mark as impacted - any holiday in the period affects working day calculations
                                periodData.hasHolidayImpact = true;

                                // Add indicator if this is a manually added holiday
                                const manualIndicator = holiday.isManual ? ' [Manual]' : '';

                                periodData.holidays.push({
                                    date: holidayDate,
                                    countryCode: country,
                                    holidayKey: `${country}_${holiday.date}`,
                                    display: `${dateStr}: ${holiday.name} (${countryName})${manualIndicator}`,
                                    name: holiday.name,
                                    isManual: holiday.isManual || false
                                });
                            }
                        });
                    });
                }
            });

            Object.values(calendarByPeriod).forEach(periodData => {
                const uniqueHolidays = Array.from(new Set(periodData.holidays.map(h => h.display)))
                    .map(display => periodData.holidays.find(h => h.display === display));
                periodData.holidays = uniqueHolidays.sort((a, b) => a.date - b.date);
            });

            // Sort tasks chronologically for display (based on dates in first period)
            // This ensures columns appear in chronological order while preserving workflow logic in the array
            const firstPeriod = Object.values(calendarByPeriod)[0];
            const taskOrder = tasks
                .map(task => ({
                    name: task.name,
                    date: firstPeriod && firstPeriod.tasks[task.name] ? firstPeriod.tasks[task.name] : new Date(9999, 0, 1)
                }))
                .sort((a, b) => a.date - b.date)
                .map(t => t.name);

            let html = '<table class="calendar-table"><thead><tr><th>Pay Period</th>';
            taskOrder.forEach(taskName => {
                html += `<th>${taskName}</th>`;
            });
            html += '<th>Bank Holidays and Processing Adjustments</th></tr></thead><tbody>';

            // v4.0: Sort period keys numerically to ensure off-cycles appear in correct order
            // (before = period - 0.5 appears above, after = period + 0.5 appears below)
            const sortedPeriods = Object.keys(calendarByPeriod)
                .map(p => parseFloat(p))
                .sort((a, b) => a - b);

            sortedPeriods.forEach(period => {
                const periodData = calendarByPeriod[period];
                const payDateTaskObj = periodData.tasks['Pay Date'];
                const payDateStr = payDateTaskObj ? formatDateToString(payDateTaskObj) : '';

                const hasOverride = payDateOverrides[period] !== undefined;

                // v4.0: Add off-cycle row class for styling
                const rowClass = periodData.isOffCycle ? ' class="offcycle-row"' : '';

                html += `<tr${rowClass}><td>
                    <div class="period-label" style="position: relative;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>${periodData.label}</div>
                            <button class="icon-button" onclick="showUnifiedEditModal(${period})" title="Edit period settings" style="margin-left: 8px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>
                        ${(periodData.hasHolidayImpact || periodData.hasAdjustment || hasOverride) ?
                            `<div style="font-size: 11px; margin-top: 4px;">
                                ${periodData.hasHolidayImpact ? '<span class="holiday-indicator"></span>' : ''}
                                ${periodData.hasAdjustment ? '<span class="adjustment-indicator"></span>' : ''}
                                ${hasOverride ? '<span class="override-indicator" title="Pay date overridden">âœï¸</span>' : ''}
                            </div>` : ''}
                    </div>
                </td>`;

                taskOrder.forEach(taskName => {
                    const task = tasks.find(t => t.name === taskName);
                    const taskDate = periodData.tasks[taskName];
                    if (taskDate) {
                        const dateStr = taskDate.toLocaleDateString('en-GB', {
                            day: 'numeric',
                            month: 'short'
                        });
                        const dayName = taskDate.toLocaleDateString('en-GB', { weekday: 'short' });

                        // Format time display
                        const timeDisplay = task.dueTime ? `<span class="time-display" style="display: block; font-size: 11px; color: var(--text-medium); margin-top: 2px;">${formatTimeDisplay(task.dueTime)}</span>` : '';

                        // Pay Date column (centered display, no edit icon - editing moved to period label icon)
                        if (task.name === 'Pay Date') {
                            html += `<td style="text-align: center;">
                                <span class="date-display">${dateStr}</span>
                                <span class="day-display">${dayName}</span>
                                ${timeDisplay}
                            </td>`;
                        } else {
                            // Check if this task has been manually overridden
                            const isOverridden = periodData.overriddenTasks && periodData.overriddenTasks.includes(taskName);
                            const overrideIndicator = isOverridden ? '<span style="color: var(--warning-orange); margin-left: 4px;" title="Date manually overridden">âœï¸</span>' : '';

                            html += `<td>
                                <span class="date-display">${dateStr}${overrideIndicator}</span>
                                <span class="day-display">${dayName}</span>
                                ${timeDisplay}
                            </td>`;
                        }
                    } else {
                        html += '<td>-</td>';
                    }
                });

                // Display pay date adjustment ONLY if it was due to a bank holiday (not weekends)
                let payDateAdjustmentDisplay = '';
                if (periodData.payDateAdjustment && periodData.payDateAdjustment.reason && periodData.payDateAdjustment.reason.type === 'holiday') {
                    const adj = periodData.payDateAdjustment;
                    const originalDateStr = adj.originalDate.toLocaleDateString('en-GB', {
                        day: 'numeric',
                        month: 'short'
                    });
                    const adjustedDateStr = adj.adjustedDate.toLocaleDateString('en-GB', {
                        day: 'numeric',
                        month: 'short'
                    });
                    const reasonText = ` due to ${adj.reason.holidayName}`;

                    payDateAdjustmentDisplay = `
                        <div style="background: #FFF4E6; border-left: 4px solid #FF9800; padding: 12px; margin-bottom: 12px; border-radius: 4px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                <span style="font-size: 18px;">âš ï¸</span>
                                <strong style="color: #E65100;">Pay Date Adjusted</strong>
                            </div>
                            <div style="color: var(--text-medium); font-size: 13px; line-height: 1.4;">
                                Originally scheduled for <strong>${originalDateStr}</strong>,
                                moved to <strong>${adjustedDateStr}</strong>${reasonText}
                            </div>
                        </div>
                    `;
                }

                const holidaysList = periodData.holidays.map(h => {
                    const isIgnored = ignoredHolidays.includes(h.holidayKey);
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; ${isIgnored ? 'opacity: 0.5; text-decoration: line-through;' : ''}">
                            <span>${h.display}</span>
                            ${!isIgnored ?
                                `<button class="secondary small" style="margin-left: 8px; padding: 4px 8px; font-size: 11px;" onclick="ignoreHoliday('${h.holidayKey}')">Ignore</button>` :
                                `<button class="secondary small" style="margin-left: 8px; padding: 4px 8px; font-size: 11px;" onclick="restoreHoliday('${h.holidayKey}')">Restore</button>`
                            }
                        </div>
                    `;
                }).join('');

                // Add adjusted tasks information with improved formatting
                let adjustmentInfo = '';
                console.log(`ðŸ” Period ${period} adjustedTasks:`, periodData.adjustedTasks);
                if (periodData.adjustedTasks && periodData.adjustedTasks.length > 0) {
                    console.log(`âœ“ Displaying ${periodData.adjustedTasks.length} adjusted tasks for period ${period}`);
                    adjustmentInfo = `<div style="margin-top: 8px; padding: 8px; background-color: #FEF3C7; border-left: 3px solid #F97316; border-radius: 3px;">
                        <strong style="color: #EA580C;">âš ï¸ Adjusted Tasks:</strong><br>` +
                        periodData.adjustedTasks.map(adj =>
                            `<span style="color: #292524;">${adj.name}: <strong style="color: #EA580C;">${adj.originalOffset}â†’${adj.adjustedOffset} days</strong></span>`
                        ).join('<br>') + '</div>';
                } else {
                    console.log(`âš ï¸ No adjusted tasks to display for period ${period}`);
                }

                // Check for constraint violations in this period
                // FIX v3.7: Re-validate against CURRENT generatedCalendar data instead of using cached violations
                let constraintWarning = '';
                if (taskConstraints.length > 0) {
                    // Get current period tasks from generatedCalendar
                    // IMPORTANT: period from Object.keys() is a STRING, but t.period is a NUMBER
                    const periodNum = parseInt(period);
                    const currentPeriodTasks = generatedCalendar.filter(t => t.period === periodNum);
                    console.log(`ðŸ” Period ${period}: Checking ${taskConstraints.length} constraint(s) against ${currentPeriodTasks.length} tasks`);

                    // Re-validate with current data to avoid stale cache issues
                    const currentViolations = validateTaskConstraints(currentPeriodTasks, periodNum);
                    console.log(`ðŸ” Period ${period}: Found ${currentViolations.length} violation(s)`, currentViolations);

                    if (currentViolations.length > 0) {
                        constraintWarning = `<div style="margin-top: ${holidaysList || adjustmentInfo ? '12px' : '0'}; padding: 10px; background-color: #FEF3C7; border-left: 3px solid #F97316; border-radius: 3px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <strong style="color: #EA580C;">âš ï¸ Task Rule Violations:</strong>
                            <button class="icon-button" onclick="showUnifiedEditModal(${period}, 'taskDates')" title="Edit task dates" style="margin-left: 8px;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                </svg>
                            </button>
                        </div>`;
                        currentViolations.forEach(v => {
                            constraintWarning += `<span style="color: #292524; font-size: 13px;"><strong>${v.task1}</strong> and <strong>${v.task2}</strong> are both on <strong>${v.date}</strong></span><br>`;
                        });
                        constraintWarning += `</div>`;
                        console.log(`âš ï¸ Constraint violations displayed for period ${period}:`, currentViolations);
                    }
                }

                const cellContent = `${payDateAdjustmentDisplay}${holidaysList || (adjustmentInfo || constraintWarning || payDateAdjustmentDisplay ? '' : '-')}${adjustmentInfo}${constraintWarning}`;
                console.log(`ðŸ“ Final cell content for period ${period}:`, {
                    hasHolidays: holidaysList.length > 0,
                    hasAdjustments: adjustmentInfo.length > 0,
                    holidaysListLength: holidaysList.length,
                    adjustmentInfoLength: adjustmentInfo.length
                });
                if (adjustmentInfo.length > 0) {
                    console.log(`ðŸ“‹ Adjustment HTML for period ${period}:`, adjustmentInfo);
                    console.log(`ðŸ“‹ Full cell HTML for period ${period}:`, cellContent);
                }

                html += `<td>${cellContent}</td></tr>`;
            });

            html += '</tbody></table>';
            preview.innerHTML = html;
        }

        function exportToXLSX() {
            try {
                if (generatedCalendar.length === 0) {
                    showMessage('Please generate a calendar first', 'error');
                    return;
                }

                if (typeof XLSX === 'undefined') {
                    showMessage('Excel library not loaded. Please refresh the page.', 'error');
                    return;
                }

                const clientName = document.getElementById('clientName').value.trim();
                const year = parseInt(document.getElementById('calendarYear').value);

                const calendarByPeriod = {};
            generatedCalendar.forEach(entry => {
                if (!calendarByPeriod[entry.period]) {
                    calendarByPeriod[entry.period] = {
                        label: entry.periodLabel,
                        tasks: {},
                        holidays: [],
                        month: entry.month,
                        periodInMonth: entry.periodInMonth,
                        hasHolidayImpact: false,
                        hasAdjustment: false,
                        adjustedTasks: [],
                        payDateAdjustment: null, // Store pay date adjustment info if shifted due to holiday
                        isOffCycle: entry.isOffCycle || false, // v4.0: Track if this is an off-cycle period
                        offCycleConfigId: entry.offCycleConfigId // v4.0: Store off-cycle config ID
                    };
                }
                calendarByPeriod[entry.period].tasks[entry.task] = entry.date;

                if (entry.adjusted) {
                    calendarByPeriod[entry.period].hasAdjustment = true;
                    const adjustedTask = {
                        name: entry.task,
                        originalOffset: entry.originalOffset,
                        adjustedOffset: entry.adjustedOffset
                    };
                    calendarByPeriod[entry.period].adjustedTasks.push(adjustedTask);
                    console.log(`ðŸ“Š Adding adjusted task to display:`, {
                        period: entry.period,
                        task: adjustedTask.name,
                        original: adjustedTask.originalOffset,
                        adjusted: adjustedTask.adjustedOffset
                    });
                }
            });

            // Assign holidays to periods and check for impact
            const employeeCountry = document.getElementById('employeeCountry')?.value;
            const providerCountry = document.getElementById('providerCountry')?.value;
            const clientTeamCountry = document.getElementById('clientTeamCountry')?.value;

            const countriesForHolidays = [employeeCountry]; // Employee country always included

            // Check if provider country is selected and if its holidays should impact
            const providerImpact = document.getElementById('providerCountryImpact')?.checked ?? true;
            if (providerCountry && providerImpact) {
                countriesForHolidays.push(providerCountry);
            }

            // Check if client team country is selected and if its holidays should impact
            const clientTeamImpact = document.getElementById('clientTeamCountryImpact')?.checked ?? true;
            if (clientTeamCountry && clientTeamImpact) {
                countriesForHolidays.push(clientTeamCountry);
            }

            const uniqueCountries = [...new Set(countriesForHolidays)];
            const frequency = document.getElementById('payFrequency').value;

            uniqueCountries.forEach(country => {
                if (bankHolidays[country]) {
                    bankHolidays[country].forEach(holiday => {
                        const holidayDate = new Date(holiday.date);

                        Object.keys(calendarByPeriod).forEach(period => {
                            const periodData = calendarByPeriod[period];

                            // Determine if holiday falls within this pay period
                            let isInPeriod = false;

                            if (frequency === 'monthly') {
                                // For monthly: Only include holidays from the same calendar month
                                isInPeriod = (holidayDate.getMonth() === periodData.month && holidayDate.getFullYear() === year);
                            } else if (frequency === 'semi-monthly') {
                                // For semi-monthly: Check both month AND which period (P1 or P2)
                                if (holidayDate.getMonth() === periodData.month && holidayDate.getFullYear() === year) {
                                    const payDate = periodData.tasks['Pay Date'];

                                    if (periodData.periodInMonth === 1) {
                                        // P1: Include holidays from start of month up to P1 pay date
                                        isInPeriod = (holidayDate <= payDate);
                                    } else if (periodData.periodInMonth === 2) {
                                        // P2: Include holidays after P1 pay date through end of month
                                        // Find P1 pay date for this month
                                        const p1Period = Object.values(calendarByPeriod).find(p =>
                                            p.month === periodData.month && p.periodInMonth === 1
                                        );
                                        if (p1Period && p1Period.tasks['Pay Date']) {
                                            const p1PayDate = p1Period.tasks['Pay Date'];
                                            isInPeriod = (holidayDate > p1PayDate);
                                        }
                                    }
                                }
                            } else {
                                // For bi-weekly/weekly: Each period runs from day after previous pay date to current pay date
                                const payDate = periodData.tasks['Pay Date'];
                                if (payDate) {
                                    // Find the previous period's pay date
                                    const allPeriods = Object.keys(calendarByPeriod).map(p => ({
                                        period: p,
                                        payDate: calendarByPeriod[p].tasks['Pay Date']
                                    })).sort((a, b) => a.payDate - b.payDate);

                                    const currentIndex = allPeriods.findIndex(p => p.period === period);

                                    if (currentIndex === 0) {
                                        // First period: from start of year (or reasonable start) to pay date
                                        const periodStart = new Date(year, 0, 1);
                                        isInPeriod = (holidayDate >= periodStart && holidayDate <= payDate);
                                    } else {
                                        // Other periods: from day after previous pay date to current pay date
                                        const previousPayDate = allPeriods[currentIndex - 1].payDate;
                                        const periodStart = new Date(previousPayDate);
                                        periodStart.setDate(periodStart.getDate() + 1); // Day after previous pay date
                                        isInPeriod = (holidayDate >= periodStart && holidayDate <= payDate);
                                    }
                                }
                            }

                            if (isInPeriod) {
                                // Show all holidays within the pay period boundaries
                                // (holidays affect working day calculations even if outside task date range)
                                const countryName = countries.find(c => c.code === country)?.name || country;
                                const dateStr = holidayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });

                                // Mark as impacted - any holiday in the period affects working day calculations
                                periodData.hasHolidayImpact = true;

                                // Add indicator if this is a manually added holiday
                                const manualIndicator = holiday.isManual ? ' [Manual]' : '';

                                periodData.holidays.push({
                                    date: holidayDate,
                                    countryCode: country,
                                    holidayKey: `${country}_${holiday.date}`,
                                    display: `${dateStr}: ${holiday.name} (${countryName})${manualIndicator}`,
                                    name: holiday.name,
                                    isManual: holiday.isManual || false
                                });
                            }
                        });
                    });
                }
            });

            // Remove duplicate holidays
            Object.values(calendarByPeriod).forEach(periodData => {
                const uniqueHolidays = Array.from(new Set(periodData.holidays.map(h => h.display)))
                    .map(display => periodData.holidays.find(h => h.display === display));
                periodData.holidays = uniqueHolidays.sort((a, b) => a.date - b.date);
            });

            // Sort tasks chronologically for Excel (based on dates in first period)
            const firstPeriod = Object.values(calendarByPeriod)[0];
            const taskOrder = tasks
                .map(task => ({
                    task: task,
                    date: firstPeriod && firstPeriod.tasks[task.name] ? firstPeriod.tasks[task.name] : new Date(9999, 0, 1)
                }))
                .sort((a, b) => a.date - b.date)
                .map(t => t.task);

            // Build data with separate indicator column - include time in header if present
            const tzAbbr = getTimezoneAbbr();
            const taskHeaders = taskOrder.map(t => {
                if (t.dueTime) {
                    const timeStr = formatTimeDisplay(t.dueTime);
                    return tzAbbr ? `${t.name} at ${timeStr} ${tzAbbr}` : `${t.name} at ${timeStr}`;
                }
                return t.name;
            });
            const data = [['Pay Period', 'Status', ...taskHeaders, 'Bank Holidays and Processing Adjustments']];

            // v4.0: Sort period keys numerically to ensure off-cycles appear in correct order
            const sortedPeriods = Object.keys(calendarByPeriod)
                .map(p => parseFloat(p))
                .sort((a, b) => a - b);

            sortedPeriods.forEach(period => {
                const periodData = calendarByPeriod[period];

                // Create status indicators
                let statusIndicators = [];
                if (periodData.hasHolidayImpact) {
                    statusIndicators.push('ðŸŸ¡ Holiday');
                }
                if (periodData.hasAdjustment) {
                    statusIndicators.push('ðŸŸ  Adjusted');
                }
                const statusText = statusIndicators.length > 0 ? statusIndicators.join('\n') : '-';

                const row = [periodData.label, statusText];

                taskOrder.forEach(task => {
                    const taskDate = periodData.tasks[task.name];
                    if (taskDate) {
                        // Format as "Thu, 27th Nov"
                        row.push(formatDateWithOrdinal(taskDate));
                    } else {
                        row.push('-');
                    }
                });

                // Add holidays column with adjustment info (excluding ignored holidays)
                // Format: Line 1: adjustments (if any), Line 2: holidays (if any)
                const lines = [];

                // Line 1: Adjusted tasks (if any) - with clear label
                if (periodData.adjustedTasks && periodData.adjustedTasks.length > 0) {
                    const adjustments = 'âš ï¸ Adjusted: ' + periodData.adjustedTasks.map(adj =>
                        `${adj.name} (${adj.originalOffset}â†’${adj.adjustedOffset} days)`
                    ).join(', ');
                    lines.push(adjustments);
                }

                // Line 2: Bank holidays (if any)
                const holidaysList = periodData.holidays
                    .filter(h => !ignoredHolidays.includes(h.holidayKey))
                    .map(h => h.display)
                    .join(', ');
                if (holidaysList) {
                    lines.push(holidaysList);
                }

                row.push(lines.length > 0 ? lines.join('\n') : '-');

                data.push(row);
            });

            const ws = XLSX.utils.aoa_to_sheet(data);

            // Style the header row with shading and bold
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const address = XLSX.utils.encode_col(C) + "1";
                if (!ws[address]) continue;

                const isFirstCol = (C === range.s.c);
                const isLastCol = (C === range.e.c);

                ws[address].s = {
                    font: {
                        bold: true,
                        color: { rgb: "FFFFFF" },
                        name: 'Arial',
                        size: 12
                    },
                    fill: {
                        fgColor: { rgb: "0070C0" },
                        patternType: "solid"
                    },  // Blue shading for headers (RGB: 0, 112, 192)
                    alignment: {
                        horizontal: "center",
                        vertical: "center",
                        wrapText: true
                    },
                    border: {
                        top: { style: "medium", color: { rgb: "000000" } },
                        bottom: { style: "medium", color: { rgb: "000000" } },
                        left: isFirstCol ? { style: "medium", color: { rgb: "000000" } } : { style: "thin", color: { rgb: "D3D3D1" } },
                        right: { style: isLastCol ? "medium" : "thin", color: { rgb: isLastCol ? "000000" : "D3D3D1" } }
                    }
                };
            }

            // Style data rows with uniform styling
            // v4.0: Use sorted periods to maintain correct order for off-cycle styling
            const periodDataArray = sortedPeriods.map(p => calendarByPeriod[p]);
            for (let R = range.s.r + 1; R <= range.e.r; ++R) {
                const period = R - 1;
                const periodData = periodDataArray[period];
                if (!periodData) continue;

                const isLastRow = (R === range.e.r);
                // v4.0: Check if this is an off-cycle period for yellow background
                const isOffCycle = periodData.isOffCycle || false;
                const bgColor = isOffCycle ? "FEF3C7" : "FFFFFF"; // Yellow for off-cycles, white for regular

                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const address = XLSX.utils.encode_col(C) + (R + 1);
                    if (!ws[address]) continue;

                    const isFirstCol = (C === range.s.c);
                    const isLastCol = (C === range.e.c);

                    // Uniform styling for all cells with appropriate fill color
                    ws[address].s = {
                        alignment: {
                            horizontal: "center",
                            vertical: "center",
                            wrapText: true
                        },
                        font: {
                            name: 'Arial',
                            size: 11,
                            color: { rgb: "000000" }  // Explicit black text color for readability
                        },
                        fill: {
                            fgColor: { rgb: bgColor },
                            patternType: "solid"
                        },  // Yellow for off-cycles (#FEF3C7), white for regular periods
                        border: {
                            bottom: isLastRow ? { style: "medium", color: { rgb: "000000" } } : undefined,
                            left: isFirstCol ? { style: "medium", color: { rgb: "000000" } } : { style: "thin", color: { rgb: "D3D3D1" } },
                            right: { style: isLastCol ? "medium" : "thin", color: { rgb: isLastCol ? "000000" : "D3D3D1" } }
                        }
                    };

                    // First column (Pay Period) - left aligned, bold
                    if (C === 0) {
                        ws[address].s.alignment.horizontal = "left";
                        ws[address].s.font.bold = true;
                    }

                    // Second column (Status) - center aligned
                    if (C === 1) {
                        ws[address].s.alignment.horizontal = "center";
                        ws[address].s.alignment.vertical = "center";
                    }

                    // Last column (Bank Holidays and Processing Adjustments) - left aligned
                    if (C === range.e.c) {
                        ws[address].s.alignment.horizontal = "left";
                        ws[address].s.alignment.vertical = "top";
                    }
                }
            }

            // Set column widths for uniform appearance
            ws['!cols'] = [
                { wch: 20 },  // Pay Period column
                { wch: 14 },  // Status column
                ...tasks.map(() => ({ wch: 18 })),  // Task columns (wider for "Thu, 27th Nov")
                { wch: 75 }  // Bank Holidays and Processing Adjustments column (550 pixels)
            ];

            // Set row heights
            ws['!rows'] = [{ hpt: 60 }]; // Header row (45 pixels)
            // Data rows: Let Excel auto-size based on content (especially for multi-line holidays column)

            // Fill cells outside the calendar content with solid white to hide gridlines
            const fillRows = 100; // Fill 100 rows beyond data
            const fillCols = 50; // Fill 50 columns beyond data
            const maxRow = range.e.r + fillRows;
            const maxCol = range.e.c + fillCols;

            for (let R = 0; R <= maxRow; R++) {
                for (let C = 0; C <= maxCol; C++) {
                    const address = XLSX.utils.encode_col(C) + (R + 1);
                    // Only fill cells that don't already have styling (outside calendar content)
                    if (!ws[address]) {
                        ws[address] = {
                            v: '',
                            t: 's',
                            s: {
                                fill: {
                                    fgColor: { rgb: "FFFFFF" },
                                    patternType: "solid"
                                }
                            }
                        };
                    }
                }
            }

            // Update the range to include filled cells
            ws['!ref'] = XLSX.utils.encode_range({
                s: { r: 0, c: 0 },
                e: { r: maxRow, c: maxCol }
            });

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Payroll Calendar");

                XLSX.writeFile(wb, `${clientName}_Payroll_Calendar_${year}.xlsx`, { cellStyles: true, bookType: 'xlsx' });
                showMessage('Calendar exported to Excel successfully!', 'success');
            } catch (error) {
                console.error('Excel export error:', error);
                showMessage('Failed to export to Excel: ' + error.message, 'error');
            }
        }

        function exportToPDF() {
            if (generatedCalendar.length === 0) {
                showMessage('Please generate a calendar first', 'error');
                return;
            }

            const clientName = document.getElementById('clientName').value.trim();
            const year = parseInt(document.getElementById('calendarYear').value);

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('l', 'mm', 'a4');

            // Title
            doc.setFontSize(20);
            doc.setTextColor(55, 53, 47);
            doc.text(`${clientName} - Payroll Calendar ${year}`, 15, 20);

            const calendarByPeriod = {};
            generatedCalendar.forEach(entry => {
                if (!calendarByPeriod[entry.period]) {
                    calendarByPeriod[entry.period] = {
                        label: entry.periodLabel,
                        tasks: {},
                        isOffCycle: entry.isOffCycle || false // v4.0: Track if this is an off-cycle period
                    };
                }
                calendarByPeriod[entry.period].tasks[entry.task] = entry.date;
            });

            const tableData = [];
            // v4.0: Sort period keys numerically to ensure off-cycles appear in correct order
            const sortedPeriods = Object.keys(calendarByPeriod)
                .map(p => parseFloat(p))
                .sort((a, b) => a - b);

            sortedPeriods.forEach(period => {
                const periodData = calendarByPeriod[period];
                const row = [periodData.label];

                tasks.forEach(task => {
                    const taskDate = periodData.tasks[task.name];
                    if (taskDate) {
                        row.push(taskDate.toLocaleDateString('en-GB', {
                            day: 'numeric',
                            month: 'short',
                            year: 'numeric'
                        }));
                    } else {
                        row.push('-');
                    }
                });

                tableData.push(row);
            });

            // Include time in PDF header if present
            const pdfTzAbbr = getTimezoneAbbr();
            const pdfTaskHeaders = tasks.map(t => {
                if (t.dueTime) {
                    const timeStr = formatTimeDisplay(t.dueTime);
                    return pdfTzAbbr ? `${t.name} at ${timeStr} ${pdfTzAbbr}` : `${t.name} at ${timeStr}`;
                }
                return t.name;
            });

            // v4.0: Build array to track which rows are off-cycles for styling
            const offCycleRows = sortedPeriods.map(p => calendarByPeriod[p].isOffCycle || false);

            doc.autoTable({
                head: [['Pay Period', ...pdfTaskHeaders]],
                body: tableData,
                startY: 30,
                theme: 'grid',
                headStyles: {
                    fillColor: [55, 53, 47],
                    textColor: [255, 255, 255],
                    fontStyle: 'bold',
                    halign: 'center'
                },
                bodyStyles: {
                    textColor: [55, 53, 47]
                },
                alternateRowStyles: {
                    fillColor: [250, 250, 250]
                },
                columnStyles: {
                    0: { fontStyle: 'bold', fillColor: [250, 250, 250] }
                },
                // v4.0: Apply yellow background to off-cycle rows
                didParseCell: function(data) {
                    if (data.section === 'body' && offCycleRows[data.row.index]) {
                        data.cell.styles.fillColor = [254, 243, 199]; // #FEF3C7 yellow for off-cycles
                    }
                }
            });

            doc.save(`${clientName}_Payroll_Calendar_${year}.pdf`);
            showMessage('Calendar exported to PDF successfully!', 'success');
        }

        function saveConfiguration() {
            const clientName = document.getElementById('clientName').value.trim();
            const employeeCountry = document.getElementById('employeeCountry').value;
            const providerCountry = document.getElementById('providerCountry').value;
            const clientTeamCountry = document.getElementById('clientTeamCountry').value;
            const payFrequency = document.getElementById('payFrequency').value;
            const year = parseInt(document.getElementById('calendarYear').value);

            if (!clientName || !employeeCountry || !payFrequency) {
                showMessage('Please fill in all required fields (Client Name, Employee Country, Pay Frequency)', 'error');
                return;
            }

            let frequencyConfig = { type: payFrequency };
            if (payFrequency === 'monthly') {
                frequencyConfig.payDayOfMonth = document.getElementById('payDayOfMonth')?.value;
            } else if (payFrequency === 'semi-monthly') {
                frequencyConfig.firstPayDay = document.getElementById('firstPayDay')?.value;
                frequencyConfig.secondPayDay = document.getElementById('secondPayDay')?.value;
            } else if (payFrequency === 'bi-weekly' || payFrequency === 'weekly') {
                frequencyConfig.payDayOfWeek = document.getElementById('payDayOfWeek')?.value;
                frequencyConfig.firstPayDate = document.getElementById('firstPayDate')?.value;
            }

            const timezone = document.getElementById('calendarTimezone')?.value || '';

            const config = {
                id: Date.now(),
                clientName,
                employeeCountry,
                providerCountry,
                clientTeamCountry,
                payFrequency: frequencyConfig,
                cutoffConfig,
                year,
                timezone,
                tasks: tasks.filter(t => !t.core),
                taskOffsets: tasks.map(t => ({ name: t.name, offset: t.offset, dueTime: t.dueTime || '' })),
                taskConstraints: taskConstraints,
                offCyclePeriods: offCyclePeriods, // v4.0: Save off-cycle configurations
                savedDate: new Date().toISOString()
            };

            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            configs.push(config);
            localStorage.setItem('payrollConfigs', JSON.stringify(configs));

            loadSavedConfigurations();
            showMessage('Configuration saved successfully!', 'success');
        }

        function loadSavedConfigurations() {
            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            const container = document.getElementById('savedConfigs');

            if (configs.length === 0) {
                container.innerHTML = '<p style="color: var(--text-medium);">No saved configurations yet. Create one below!</p>';
                return;
            }

            container.innerHTML = '';

            configs.forEach(config => {
                const card = document.createElement('div');
                card.className = 'config-card';

                const countryName = countries.find(c => c.code === config.employeeCountry)?.name || config.employeeCountry;
                const freqType = config.payFrequency?.type || 'N/A';

                card.innerHTML = `
                    <h3>${config.clientName}</h3>
                    <p>ðŸŒ ${countryName}</p>
                    <p>ðŸ“… ${freqType}</p>
                    <p>ðŸ“† ${config.year}</p>
                    <div class="config-actions">
                        <button class="primary small" onclick="loadConfiguration(${config.id})">Load</button>
                        <button class="danger small" onclick="deleteConfiguration(${config.id})">Delete</button>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function loadConfiguration(id) {
            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            const config = configs.find(c => c.id === id);

            if (!config) return;

            document.getElementById('clientName').value = config.clientName;
            document.getElementById('employeeCountry').value = config.employeeCountry;
            document.getElementById('providerCountry').value = config.providerCountry;
            document.getElementById('clientTeamCountry').value = config.clientTeamCountry;
            document.getElementById('calendarYear').value = config.year;
            document.getElementById('calendarTimezone').value = config.timezone || '';

            const freqConfig = config.payFrequency || {};
            document.getElementById('payFrequency').value = freqConfig.type || '';
            updatePayDateConfig();

            setTimeout(() => {
                if (freqConfig.type === 'monthly') {
                    document.getElementById('payDayOfMonth').value = freqConfig.payDayOfMonth || '';
                } else if (freqConfig.type === 'semi-monthly') {
                    document.getElementById('firstPayDay').value = freqConfig.firstPayDay || '';
                    document.getElementById('secondPayDay').value = freqConfig.secondPayDay || '';
                } else if (freqConfig.type === 'bi-weekly' || freqConfig.type === 'weekly') {
                    document.getElementById('payDayOfWeek').value = freqConfig.payDayOfWeek || '';
                    document.getElementById('firstPayDate').value = freqConfig.firstPayDate || '';
                }

                if (config.cutoffConfig) {
                    cutoffConfig = config.cutoffConfig;
                    const modeRadio = document.getElementById(cutoffConfig.mode === 'date' ? 'cutoffByDate' : 'cutoffByOffset');
                    if (modeRadio) {
                        modeRadio.checked = true;
                        updateCutoffMode();

                        setTimeout(() => {
                            if (cutoffConfig.mode === 'offset') {
                                document.getElementById('cutoffDaysOffset').value = cutoffConfig.offset || 10;
                            }
                        }, 100);
                    }
                }
            }, 100);

            tasks = [...JSON.parse(JSON.stringify(defaultTasks))];
            if (config.taskOffsets) {
                config.taskOffsets.forEach((savedTask, i) => {
                    if (tasks[i]) {
                        tasks[i].offset = savedTask.offset;
                        tasks[i].dueTime = savedTask.dueTime || '';
                    }
                });
            }
            if (config.tasks) {
                tasks.push(...config.tasks);
            }

            // Restore task constraints (filter out invalid ones referencing non-existent tasks)
            if (config.taskConstraints) {
                taskConstraints = config.taskConstraints.filter(c =>
                    c.task1Index >= 0 && c.task1Index < tasks.length &&
                    c.task2Index >= 0 && c.task2Index < tasks.length
                );
                if (taskConstraints.length < config.taskConstraints.length) {
                    console.log(`âš ï¸ Filtered out ${config.taskConstraints.length - taskConstraints.length} invalid constraint(s)`);
                }
                updateConstraintCount();
            } else {
                taskConstraints = [];
            }

            // v4.0: Restore off-cycle periods
            if (config.offCyclePeriods && Array.isArray(config.offCyclePeriods)) {
                // Restore dates from JSON strings
                offCyclePeriods = config.offCyclePeriods.map(ocp => ({
                    ...ocp,
                    payDates: {
                        ...ocp.payDates,
                        dates: Object.keys(ocp.payDates.dates || {}).reduce((acc, key) => {
                            acc[key] = new Date(ocp.payDates.dates[key]);
                            return acc;
                        }, {})
                    }
                }));
                console.log(`âœ… Restored ${offCyclePeriods.length} off-cycle configuration(s)`);
            } else {
                offCyclePeriods = [];
            }

            renderTasks();
            showMessage('Configuration loaded successfully!', 'success');
        }

        function deleteConfiguration(id) {
            if (!confirm('Are you sure you want to delete this configuration?')) return;

            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            const filtered = configs.filter(c => c.id !== id);
            localStorage.setItem('payrollConfigs', JSON.stringify(filtered));

            loadSavedConfigurations();
            showMessage('Configuration deleted', 'success');
        }

        function resetForm() {
            if (!confirm('Are you sure? This will clear all unsaved data.')) return;

            document.getElementById('clientName').value = '';
            document.getElementById('employeeCountry').value = '';
            document.getElementById('providerCountry').value = '';
            document.getElementById('clientTeamCountry').value = '';
            document.getElementById('payFrequency').value = '';
            document.getElementById('calendarYear').value = new Date().getFullYear();
            document.getElementById('calendarTimezone').value = '';

            updatePayDateConfig();

            tasks = JSON.parse(JSON.stringify(defaultTasks));
            cutoffConfig = { mode: 'offset', offset: 10 };
            taskConstraints = [];
            offCyclePeriods = []; // v4.0: Clear off-cycle configurations
            updateConstraintCount();
            renderTasks();

            generatedCalendar = [];
            document.getElementById('calendarSection').classList.add('hidden');

            showMessage('Form reset successfully', 'success');
        }

        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;

            if (type !== 'loading') {
                setTimeout(() => {
                    messageDiv.className = 'message hidden';
                }, 5000);
            }
        }

        function showPayDateOverride(periodIndex, currentPayDate) {
            // Ensure periodIndex is a number
            periodIndex = parseInt(periodIndex);

            const modal = document.getElementById('payDateOverrideModal');
            const input = document.getElementById('overridePayDateInput');
            const cutoffInput = document.getElementById('overrideCutoffInput');
            const periodLabel = document.getElementById('overridePeriodLabel');
            const removeBtn = document.getElementById('removeOverrideBtn');

            // Find the period label and cutoff date from generated calendar
            const periodEntry = generatedCalendar.find(e => e.period === periodIndex);
            if (periodEntry) {
                periodLabel.textContent = periodEntry.periodLabel;

                // Find the cutoff task for this period
                const cutoffTask = generatedCalendar.find(e => e.period === periodIndex && e.task === 'Payroll Cut Off');
                if (cutoffTask && cutoffTask.date) {
                    cutoffInput.value = formatDateForInput(cutoffTask.date);
                }
            }

            input.value = currentPayDate;
            input.dataset.periodIndex = periodIndex;

            // Reset cutoff editor to collapsed state
            const cutoffSection = document.getElementById('cutoffEditorSection');
            const cutoffToggleIcon = document.getElementById('cutoffEditorToggleIcon');
            cutoffSection.style.display = 'none';
            cutoffToggleIcon.textContent = 'â–¶';

            // Reset bank holiday editor to collapsed state and populate if manual holiday exists
            const bankHolidaySection = document.getElementById('bankHolidayEditorSection');
            const bankHolidayToggleIcon = document.getElementById('bankHolidayEditorToggleIcon');
            const manualHolidayDateInput = document.getElementById('manualHolidayDate');
            const manualHolidayNameInput = document.getElementById('manualHolidayName');

            bankHolidaySection.style.display = 'none';
            bankHolidayToggleIcon.textContent = 'â–¶';

            // Populate manual holiday if one exists for this period
            if (manualHolidays[periodIndex]) {
                manualHolidayDateInput.value = formatDateForInput(manualHolidays[periodIndex].date);
                manualHolidayNameInput.value = manualHolidays[periodIndex].name;
            } else {
                // Default to the pay date's month for convenience
                manualHolidayDateInput.value = currentPayDate;
                manualHolidayNameInput.value = '';
            }

            // Show/hide remove button based on whether there's an override
            const hasOverride = payDateOverrides[periodIndex] !== undefined ||
                               cutoffOverrides[periodIndex] !== undefined ||
                               manualHolidays[periodIndex] !== undefined;
            removeBtn.style.display = hasOverride ? 'inline-block' : 'none';

            modal.style.display = 'flex';
        }

        function toggleCutoffEditor() {
            const section = document.getElementById('cutoffEditorSection');
            const icon = document.getElementById('cutoffEditorToggleIcon');

            if (section.style.display === 'none') {
                section.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                section.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }

        function toggleBankHolidayEditor() {
            const section = document.getElementById('bankHolidayEditorSection');
            const icon = document.getElementById('bankHolidayEditorToggleIcon');

            if (section.style.display === 'none') {
                section.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                section.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }

        function closePayDateOverride() {
            const modal = document.getElementById('payDateOverrideModal');
            const cutoffSection = document.getElementById('cutoffEditorSection');
            const cutoffToggleIcon = document.getElementById('cutoffEditorToggleIcon');
            const bankHolidaySection = document.getElementById('bankHolidayEditorSection');
            const bankHolidayToggleIcon = document.getElementById('bankHolidayEditorToggleIcon');

            // Reset the cutoff editor section
            cutoffSection.style.display = 'none';
            cutoffToggleIcon.textContent = 'â–¶';

            // Reset the bank holiday editor section
            bankHolidaySection.style.display = 'none';
            bankHolidayToggleIcon.textContent = 'â–¶';

            modal.style.display = 'none';
        }

        function applyPayDateOverride() {
            const payDateInput = document.getElementById('overridePayDateInput');
            const cutoffInput = document.getElementById('overrideCutoffInput');
            const periodIndex = parseInt(payDateInput.dataset.periodIndex);
            const newPayDate = payDateInput.value;
            const newCutoff = cutoffInput.value;

            if (!newPayDate) {
                showMessage('Please select a new pay date', 'error');
                return;
            }

            // Store the pay date override
            payDateOverrides[periodIndex] = new Date(newPayDate);

            // Handle cutoff override
            const cutoffSection = document.getElementById('cutoffEditorSection');
            const isCutoffSectionExpanded = cutoffSection.style.display !== 'none';

            if (isCutoffSectionExpanded) {
                // User has expanded the cutoff section
                if (newCutoff) {
                    // Store the cutoff override
                    cutoffOverrides[periodIndex] = new Date(newCutoff);
                } else {
                    // User cleared the cutoff field, remove any existing override
                    delete cutoffOverrides[periodIndex];
                }
            }
            // If cutoff section was never expanded, leave existing override unchanged

            // Handle manual bank holiday
            const bankHolidaySection = document.getElementById('bankHolidayEditorSection');
            const isBankHolidaySectionExpanded = bankHolidaySection.style.display !== 'none';

            if (isBankHolidaySectionExpanded) {
                const manualHolidayDate = document.getElementById('manualHolidayDate').value;
                const manualHolidayName = document.getElementById('manualHolidayName').value;

                if (manualHolidayDate && manualHolidayName) {
                    // Store the manual holiday
                    manualHolidays[periodIndex] = {
                        date: new Date(manualHolidayDate),
                        name: manualHolidayName
                    };
                } else if (!manualHolidayDate && !manualHolidayName) {
                    // Both fields cleared, remove manual holiday
                    delete manualHolidays[periodIndex];
                }
            }
            // If bank holiday section was never expanded, leave existing manual holiday unchanged

            // Close modal
            closePayDateOverride();

            // Regenerate calendar with overrides (preserve cutoffs)
            generateCalendar(true);

            showMessage('Override applied successfully', 'success');
        }

        function removePayDateOverride(periodIndex) {
            delete payDateOverrides[periodIndex];
            delete cutoffOverrides[periodIndex];
            delete manualHolidays[periodIndex];
            generateCalendar(true); // Preserve cutoffs when removing override
        }

        // ===== CONSTRAINT OVERRIDE MODAL FUNCTIONS =====

        function showConstraintOverrideModal(periodIndex) {
            periodIndex = parseInt(periodIndex);

            const modal = document.getElementById('constraintOverrideModal');
            const periodLabel = document.getElementById('constraintOverridePeriodLabel');

            // Find the period label from generated calendar
            const periodEntry = generatedCalendar.find(e => e.period === periodIndex);
            if (periodEntry) {
                periodLabel.textContent = periodEntry.periodLabel;
            }

            // Populate the task list for this period
            populateConstraintOverrideModal(periodIndex);

            modal.style.display = 'flex';
        }

        function closeConstraintOverrideModal() {
            const modal = document.getElementById('constraintOverrideModal');
            modal.style.display = 'none';
        }

        // ========== UNIFIED EDIT MODAL FUNCTIONS (v3.8) ==========

        function showUnifiedEditModal(periodIndex, defaultTab = 'periodSettings') {
            console.log('ðŸ”§ showUnifiedEditModal called with:', { periodIndex, defaultTab });

            // Ensure periodIndex is a number (use parseFloat to preserve decimal indices for off-cycles)
            periodIndex = parseFloat(periodIndex);

            const modal = document.getElementById('unifiedEditModal');
            const periodLabel = document.getElementById('unifiedPeriodLabel');
            const payDateInput = document.getElementById('overridePayDateInput');
            const cutoffInput = document.getElementById('overrideCutoffInput');
            const removePeriodBtn = document.getElementById('removePeriodOverrideBtn');

            console.log('ðŸ”§ Modal elements found:', {
                modal: !!modal,
                periodLabel: !!periodLabel,
                payDateInput: !!payDateInput,
                cutoffInput: !!cutoffInput
            });

            // Find the period label from generated calendar
            const periodEntry = generatedCalendar.find(e => e.period === periodIndex);
            if (periodEntry) {
                // v4.0: Add off-cycle badge if this is an off-cycle period
                const isOffCycle = periodEntry.isOffCycle || false;
                if (isOffCycle) {
                    periodLabel.innerHTML = `${periodEntry.periodLabel} <span style="background: #FEF3C7; padding: 2px 8px; border-radius: 4px; font-size: 11px; color: #92400E; font-weight: 600; margin-left: 8px;">OFF-CYCLE</span>`;
                } else {
                    periodLabel.textContent = periodEntry.periodLabel;
                }

                // Find the pay date for this period
                const payDateTask = generatedCalendar.find(e => e.period === periodIndex && e.task === 'Pay Date');
                if (payDateTask && payDateTask.date) {
                    payDateInput.value = formatDateForInput(payDateTask.date);
                }

                // Find the cutoff task for this period
                const cutoffTask = generatedCalendar.find(e => e.period === periodIndex && e.task === 'Payroll Cut Off');
                if (cutoffTask && cutoffTask.date) {
                    cutoffInput.value = formatDateForInput(cutoffTask.date);
                }
            }

            // Store periodIndex for later use
            payDateInput.dataset.periodIndex = periodIndex;

            // Populate manual holiday if one exists for this period
            const manualHolidayDateInput = document.getElementById('manualHolidayDate');
            const manualHolidayNameInput = document.getElementById('manualHolidayName');

            if (manualHolidays[periodIndex]) {
                manualHolidayDateInput.value = formatDateForInput(manualHolidays[periodIndex].date);
                manualHolidayNameInput.value = manualHolidays[periodIndex].name;
            } else {
                manualHolidayDateInput.value = '';
                manualHolidayNameInput.value = '';
            }

            // Show/hide remove button based on whether there are overrides
            const hasOverride = payDateOverrides[periodIndex] !== undefined ||
                               cutoffOverrides[periodIndex] !== undefined ||
                               manualHolidays[periodIndex] !== undefined;
            removePeriodBtn.style.display = hasOverride ? 'inline-block' : 'none';

            // Populate task dates tab
            populateConstraintOverrideModal(periodIndex);

            // Switch to the appropriate tab
            switchEditTab(defaultTab);

            // Show modal
            modal.style.display = 'flex';
        }

        function closeUnifiedEditModal() {
            const modal = document.getElementById('unifiedEditModal');
            modal.style.display = 'none';
        }

        function switchEditTab(tabName) {
            // Hide all tab panels
            document.getElementById('periodSettingsTab').classList.remove('active');
            document.getElementById('taskDatesTab').classList.remove('active');

            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(btn => btn.classList.remove('active'));

            // Show selected tab panel
            if (tabName === 'periodSettings') {
                document.getElementById('periodSettingsTab').classList.add('active');
                tabButtons[0].classList.add('active');
            } else if (tabName === 'taskDates') {
                document.getElementById('taskDatesTab').classList.add('active');
                tabButtons[1].classList.add('active');
            }
        }

        function applyPeriodSettings() {
            const periodIndex = parseFloat(document.getElementById('overridePayDateInput').dataset.periodIndex);
            const newPayDate = document.getElementById('overridePayDateInput').value;
            const newCutoff = document.getElementById('overrideCutoffInput').value;
            const manualHolidayDate = document.getElementById('manualHolidayDate').value;
            const manualHolidayName = document.getElementById('manualHolidayName').value;

            let hasChanges = false;

            // Handle pay date override
            if (newPayDate) {
                const currentPayDate = generatedCalendar.find(e => e.period === periodIndex && e.task === 'Pay Date');
                if (currentPayDate && formatDateForInput(currentPayDate.date) !== newPayDate) {
                    payDateOverrides[periodIndex] = newPayDate;
                    hasChanges = true;
                    console.log(`âœï¸ Pay date override set for period ${periodIndex}: ${newPayDate}`);
                }
            }

            // Handle cutoff override
            if (newCutoff) {
                const currentCutoff = generatedCalendar.find(e => e.period === periodIndex && e.task === 'Payroll Cut Off');
                if (currentCutoff && formatDateForInput(currentCutoff.date) !== newCutoff) {
                    cutoffOverrides[periodIndex] = newCutoff;
                    hasChanges = true;
                    console.log(`âœï¸ Cutoff date override set for period ${periodIndex}: ${newCutoff}`);
                }
            }

            // Handle manual bank holiday
            if (manualHolidayDate && manualHolidayName.trim()) {
                const holidayDateObj = new Date(manualHolidayDate + 'T12:00:00');
                manualHolidays[periodIndex] = {
                    date: holidayDateObj,
                    name: manualHolidayName.trim()
                };
                hasChanges = true;
                console.log(`ðŸ–ï¸ Manual holiday added for period ${periodIndex}: ${manualHolidayName} on ${manualHolidayDate}`);
            } else if (!manualHolidayDate && !manualHolidayName.trim() && manualHolidays[periodIndex]) {
                // Remove manual holiday if both fields are empty
                delete manualHolidays[periodIndex];
                hasChanges = true;
                console.log(`ðŸ—‘ï¸ Manual holiday removed for period ${periodIndex}`);
            }

            if (hasChanges) {
                // FIX v3.7: Clear stale violation cache before regenerating
                window.constraintViolations = {};

                // Regenerate calendar to apply overrides
                generateCalendar(true);
                closeUnifiedEditModal();
                showMessage('Period settings applied', 'success');
            } else {
                closeUnifiedEditModal();
                showMessage('No changes made', 'info');
            }
        }

        function removePeriodOverrides() {
            const periodIndex = parseFloat(document.getElementById('overridePayDateInput').dataset.periodIndex);

            // Remove all period-level overrides
            delete payDateOverrides[periodIndex];
            delete cutoffOverrides[periodIndex];
            delete manualHolidays[periodIndex];

            console.log(`ðŸ—‘ï¸ All period overrides removed for period ${periodIndex}`);

            // FIX v3.7: Clear stale violation cache before regenerating
            window.constraintViolations = {};

            // Regenerate calendar
            generateCalendar(true);
            closeUnifiedEditModal();
            showMessage('Period overrides removed', 'success');
        }

        // ========== END UNIFIED EDIT MODAL FUNCTIONS ==========

        function populateConstraintOverrideModal(periodIndex) {
            const taskList = document.getElementById('taskOverrideList');
            const periodTasks = generatedCalendar.filter(e => e.period === periodIndex);

            // Sort tasks chronologically
            const sortedTasks = [...periodTasks].sort((a, b) => a.date - b.date);

            // Get countries for working day calculations
            const uniqueCountries = Array.from(new Set([
                document.getElementById('employeeCountry').value,
                document.getElementById('providerCountry').value,
                document.getElementById('clientTeamCountry').value
            ].filter(c => c)));

            // Build horizontal card layout
            let html = '<div style="display: flex; gap: 16px; padding: 8px;">';

            sortedTasks.forEach((taskEntry, index) => {
                // Check if task is protected/critical
                const taskDef = tasks.find(t => t.name === taskEntry.task);
                const isBeforePayDate = taskDef && taskDef.beforePayDate === true;
                const isPayDate = taskEntry.task === 'Pay Date';
                const isCutOff = taskEntry.task === 'Payroll Cut Off';

                // Critical tasks: before pay date, Pay Date itself, or Payroll Cut Off
                const isProtected = isBeforePayDate || isPayDate || isCutOff;

                // Check if there's an existing override for this task
                const overrideKey = `${periodIndex}-${taskEntry.task}`;
                const hasOverride = taskDateOverrides[overrideKey] !== undefined;
                const displayDate = hasOverride
                    ? formatDateForInput(taskDateOverrides[overrideKey])
                    : formatDateForInput(taskEntry.date);

                // Get existing time if task has it
                const displayTime = taskDef && taskDef.dueTime ? taskDef.dueTime : '';

                // Calculate working days from previous task
                let workingDaysInfo = '';
                if (index > 0) {
                    const prevTask = sortedTasks[index - 1];
                    const prevDate = hasOverride && sortedTasks[index - 1].task === prevTask.task
                        ? (taskDateOverrides[`${periodIndex}-${prevTask.task}`] || prevTask.date)
                        : prevTask.date;
                    const currentDate = hasOverride ? taskDateOverrides[overrideKey] : taskEntry.date;

                    const workingDays = countWorkingDaysBetween(new Date(prevDate), new Date(currentDate), uniqueCountries);
                    workingDaysInfo = `<div class="working-days-display" data-task-name="${taskEntry.task}" style="color: var(--text-medium); font-size: 12px; margin-top: 4px; font-weight: 500;">
                        ${workingDays} working day${workingDays !== 1 ? 's' : ''}
                    </div>`;
                }

                html += `
                    <div style="flex: 0 0 auto; min-width: 200px; max-width: 220px; border: 1px solid var(--border-light); border-radius: 6px; padding: 12px; background: ${isProtected ? '#FEF3C7' : 'var(--bg-primary)'};">
                        <div style="font-weight: 600; font-size: 14px; margin-bottom: 8px; color: var(--text-dark);">
                            ${taskEntry.task}
                        </div>
                        ${isProtected ? '<div style="color: var(--danger-red); font-size: 11px; margin-bottom: 8px;">ðŸ”’ CRITICAL</div>' : ''}
                        ${hasOverride ? '<div style="color: var(--warning-orange); font-size: 11px; margin-bottom: 8px;">âœï¸ Overridden</div>' : ''}

                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 11px; color: var(--text-medium); display: block; margin-bottom: 4px;">Date</label>
                            <input
                                type="date"
                                class="task-date-input"
                                data-task-name="${taskEntry.task}"
                                data-period-index="${periodIndex}"
                                data-task-index="${index}"
                                data-is-before-pay-date="${isBeforePayDate}"
                                data-original-offset="${taskDef ? taskDef.offset : 0}"
                                value="${displayDate}"
                                style="width: 100%; padding: 6px; font-size: 13px; border: 1px solid var(--border-light); border-radius: 4px;">
                        </div>

                        <div style="margin-bottom: 8px;">
                            <label style="font-size: 11px; color: var(--text-medium); display: block; margin-bottom: 4px;">Time (Optional)</label>
                            <input
                                type="time"
                                class="task-time-input"
                                data-task-name="${taskEntry.task}"
                                data-period-index="${periodIndex}"
                                value="${displayTime}"
                                style="width: 100%; padding: 6px; font-size: 13px; border: 1px solid var(--border-light); border-radius: 4px;">
                        </div>

                        ${workingDaysInfo}

                        ${isProtected ? '<div style="font-size: 10px; color: var(--text-medium); margin-top: 8px; line-height: 1.3;">Critical task timing should not change.</div>' : ''}
                    </div>
                `;
            });

            html += '</div>';
            taskList.innerHTML = html;

            // Add event listeners for real-time working days updates and validation
            const dateInputs = taskList.querySelectorAll('.task-date-input');
            dateInputs.forEach(input => {
                input.addEventListener('change', (e) => {
                    validateNonWorkingDay(e.target, uniqueCountries);
                    validateBeforePayDateOffset(e.target);
                    updateWorkingDaysDisplay(periodIndex, uniqueCountries);
                    validateTaskOrder();
                });

                // Run initial validation on existing dates
                validateNonWorkingDay(input, uniqueCountries);
                validateBeforePayDateOffset(input);
            });

            // Run initial order validation
            validateTaskOrder();
        }

        function validateNonWorkingDay(input, countries) {
            const selectedDate = new Date(input.value);
            const taskName = input.dataset.taskName;

            // Check if date is weekend or bank holiday
            const isWE = isWeekend(selectedDate, countries);
            const isNWD = isNonWorkingDay(selectedDate, countries);

            if (isWE || isNWD) {
                // Find the reason
                let reason = '';
                if (isWE) {
                    const dayName = selectedDate.toLocaleDateString('en-GB', { weekday: 'long' });
                    reason = `${dayName} (Weekend)`;
                } else {
                    // Get holiday name
                    for (const country of countries) {
                        const holidayName = getHolidayName(selectedDate, country);
                        if (holidayName) {
                            const countryName = document.querySelector(`option[value="${country}"]`)?.textContent || country;
                            reason = `${holidayName} (${countryName} Bank Holiday)`;
                            break;
                        }
                    }
                }

                // Show warning in the card
                const card = input.closest('div[style*="border"]');
                let warningDiv = card.querySelector('.non-working-day-warning');

                if (!warningDiv) {
                    warningDiv = document.createElement('div');
                    warningDiv.className = 'non-working-day-warning';
                    warningDiv.style.cssText = 'background-color: #FEE2E2; border: 1px solid #DC2626; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px; color: #991B1B;';
                    card.appendChild(warningDiv);
                }

                warningDiv.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 4px;">âš ï¸ Non-Working Day</div>
                    <div style="margin-bottom: 6px;">${reason}</div>
                    <div style="font-size: 10px; line-height: 1.3;">This date will be used as-is. Tasks normally avoid non-working days.</div>
                `;

                // Add warning border to input
                input.style.borderColor = '#DC2626';
                input.style.borderWidth = '2px';
            } else {
                // Remove warning if it exists
                const card = input.closest('div[style*="border"]');
                const warningDiv = card.querySelector('.non-working-day-warning');
                if (warningDiv) {
                    warningDiv.remove();
                }

                // Reset input border
                input.style.borderColor = 'var(--border-light)';
                input.style.borderWidth = '1px';
            }
        }

        function validateTaskOrder() {
            const taskList = document.getElementById('taskOverrideList');
            const dateInputs = Array.from(taskList.querySelectorAll('.task-date-input'));

            // Get original indices to maintain task definition order
            const tasksWithDates = dateInputs.map((input, originalIndex) => ({
                input,
                date: new Date(input.value),
                taskName: input.dataset.taskName,
                originalIndex
            }));

            // Check if dates are in order
            let hasOrderError = false;
            for (let i = 1; i < tasksWithDates.length; i++) {
                const prevTask = tasksWithDates[i - 1];
                const currTask = tasksWithDates[i];

                if (currTask.date < prevTask.date) {
                    hasOrderError = true;

                    // Highlight both tasks with error
                    [prevTask.input, currTask.input].forEach(input => {
                        input.style.borderColor = '#DC2626';
                        input.style.borderWidth = '2px';
                        input.style.backgroundColor = '#FEE2E2';
                    });
                } else {
                    // Remove error styling if order is correct
                    if (!currTask.input.style.borderColor || currTask.input.style.borderColor === 'rgb(220, 38, 38)') {
                        // Only reset if it was an order error (not a non-working day warning)
                        const card = currTask.input.closest('div[style*="border"]');
                        const hasNonWorkingWarning = card ? card.querySelector('.non-working-day-warning') : null;
                        if (!hasNonWorkingWarning) {
                            currTask.input.style.borderColor = 'var(--border-light)';
                            currTask.input.style.borderWidth = '1px';
                            currTask.input.style.backgroundColor = '';
                        }
                    }
                }
            }

            // Update or remove order error message
            const modal = document.getElementById('unifiedEditModal');
            let errorDiv = modal ? modal.querySelector('.task-order-error') : null;

            if (hasOrderError && modal) {
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.className = 'task-order-error';
                    errorDiv.style.cssText = 'background-color: #FEE2E2; border: 2px solid #DC2626; border-radius: 6px; padding: 12px; margin: 16px 0; font-size: 13px; color: #991B1B;';

                    const taskListContainer = modal.querySelector('#taskOverrideList');
                    if (taskListContainer && taskListContainer.parentElement) {
                        const modalButtons = taskListContainer.parentElement.querySelector('.modal-buttons');
                        if (modalButtons) {
                            taskListContainer.parentElement.insertBefore(errorDiv, modalButtons);
                        }
                    }
                }

                if (errorDiv) {
                    errorDiv.innerHTML = `
                        <div style="font-weight: 600; margin-bottom: 6px; font-size: 14px;">ðŸš« Task Order Error</div>
                        <div style="margin-bottom: 6px;">Tasks must be in chronological order from left to right.</div>
                        <div style="font-size: 11px; line-height: 1.4; opacity: 0.9;">Please adjust the dates so that each task occurs on or after the previous task. Tasks with red borders are out of order.</div>
                    `;
                }
            } else {
                if (errorDiv) {
                    errorDiv.remove();
                }
            }

            return !hasOrderError;
        }

        function validateBeforePayDateOffset(input) {
            // Check if this is a "before pay date" task
            if (input.dataset.isBeforePayDate !== 'true') return;

            const taskName = input.dataset.taskName;
            const originalOffset = parseInt(input.dataset.originalOffset);
            const selectedDate = new Date(input.value);

            // Find the pay date for this period
            const taskList = document.getElementById('taskOverrideList');
            const payDateInput = Array.from(taskList.querySelectorAll('.task-date-input')).find(
                inp => inp.dataset.taskName === 'Pay Date'
            );

            if (!payDateInput) return;

            const payDate = new Date(payDateInput.value);

            // Calculate working days between selected date and pay date
            const uniqueCountries = Array.from(new Set([
                document.getElementById('employeeCountry').value,
                document.getElementById('providerCountry').value,
                document.getElementById('clientTeamCountry').value
            ].filter(c => c)));

            const workingDays = countWorkingDaysBetween(selectedDate, payDate, uniqueCountries);

            // Check if it matches the original offset
            if (workingDays !== originalOffset) {
                // Show warning in the card
                const card = input.closest('div[style*="border"]');
                let warningDiv = card.querySelector('.offset-warning');

                if (!warningDiv) {
                    warningDiv = document.createElement('div');
                    warningDiv.className = 'offset-warning';
                    warningDiv.style.cssText = 'background-color: #FEF3C7; border: 1px solid #F59E0B; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px; color: #92400E;';
                    card.appendChild(warningDiv);
                }

                warningDiv.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 4px;">âš ï¸ Offset Changed</div>
                    <div style="margin-bottom: 4px;">Original: ${originalOffset} working days before pay date</div>
                    <div style="margin-bottom: 6px;">Current: ${workingDays} working days before pay date</div>
                    <div style="font-size: 10px; line-height: 1.3;">This task was configured with a specific offset from pay date.</div>
                `;

                // Add warning border to input (orange for warning, not error)
                input.style.borderColor = '#F59E0B';
                input.style.borderWidth = '2px';
            } else {
                // Remove warning if it exists
                const card = input.closest('div[style*="border"]');
                const warningDiv = card.querySelector('.offset-warning');
                if (warningDiv) {
                    warningDiv.remove();
                }

                // Reset input border (unless it has other warnings)
                const hasNonWorkingWarning = card.querySelector('.non-working-day-warning');
                if (!hasNonWorkingWarning) {
                    input.style.borderColor = 'var(--border-light)';
                    input.style.borderWidth = '1px';
                }
            }
        }

        function updateWorkingDaysDisplay(periodIndex, countries) {
            const taskList = document.getElementById('taskOverrideList');
            const dateInputs = Array.from(taskList.querySelectorAll('.task-date-input'));

            // Sort inputs by their current date values
            const sortedInputs = dateInputs.sort((a, b) => {
                const dateA = new Date(a.value);
                const dateB = new Date(b.value);
                return dateA - dateB;
            });

            // Update working days display for each task
            sortedInputs.forEach((input, index) => {
                if (index === 0) return; // Skip first task (no previous task)

                const prevDate = new Date(sortedInputs[index - 1].value);
                const currentDate = new Date(input.value);
                const workingDays = countWorkingDaysBetween(prevDate, currentDate, countries);

                const taskName = input.dataset.taskName;
                const displayElement = taskList.querySelector(`.working-days-display[data-task-name="${taskName}"]`);
                if (displayElement) {
                    displayElement.textContent = `${workingDays} working day${workingDays !== 1 ? 's' : ''}`;
                }
            });
        }

        function applyTaskOverrides() {
            // First, validate task order
            const isOrderValid = validateTaskOrder();
            if (!isOrderValid) {
                showMessage('Cannot save: Tasks must be in chronological order', 'error');
                return;
            }

            // Check for non-working day warnings
            const taskList = document.getElementById('taskOverrideList');
            const nonWorkingDayWarnings = taskList.querySelectorAll('.non-working-day-warning');

            if (nonWorkingDayWarnings.length > 0) {
                const dateInputs = Array.from(taskList.querySelectorAll('.task-date-input'));
                const nonWorkingTasks = [];

                dateInputs.forEach(input => {
                    const card = input.closest('div[style*="border"]');
                    if (card.querySelector('.non-working-day-warning')) {
                        const taskName = input.dataset.taskName;
                        const date = new Date(input.value);
                        const dateStr = date.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
                        nonWorkingTasks.push(`${taskName} (${dateStr})`);
                    }
                });

                const taskListText = nonWorkingTasks.map(t => `  â€¢ ${t}`).join('\n');
                const message = `âš ï¸ Warning: The following tasks are scheduled on non-working days:\n\n${taskListText}\n\nThese dates will be used as-is and may affect your workflow.\n\nDo you want to proceed?`;

                if (!confirm(message)) {
                    return; // User cancelled
                }
            }

            const dateInputs = document.querySelectorAll('#taskOverrideList .task-date-input');
            const timeInputs = document.querySelectorAll('#taskOverrideList .task-time-input');
            let hasChanges = false;

            // Process date overrides
            dateInputs.forEach(input => {
                const periodIndex = parseFloat(input.dataset.periodIndex);
                const taskName = input.dataset.taskName;
                const overrideKey = `${periodIndex}-${taskName}`;
                const newDate = input.value;

                if (!newDate) {
                    // If empty, remove override
                    if (taskDateOverrides[overrideKey]) {
                        delete taskDateOverrides[overrideKey];
                        hasChanges = true;
                    }
                } else {
                    // Find the original date for this task
                    const originalTask = generatedCalendar.find(
                        e => e.period === periodIndex && e.task === taskName
                    );

                    if (originalTask) {
                        const originalDateStr = formatDateForInput(originalTask.date);

                        // Only store override if it's different from original
                        if (newDate !== originalDateStr) {
                            taskDateOverrides[overrideKey] = new Date(newDate);
                            hasChanges = true;
                        } else {
                            // Same as original, remove any existing override
                            if (taskDateOverrides[overrideKey]) {
                                delete taskDateOverrides[overrideKey];
                                hasChanges = true;
                            }
                        }
                    }
                }
            });

            // Process time overrides - apply to task definitions
            timeInputs.forEach(input => {
                const taskName = input.dataset.taskName;
                const newTime = input.value;
                const taskDef = tasks.find(t => t.name === taskName);

                if (taskDef) {
                    const originalTime = taskDef.dueTime || '';
                    if (newTime !== originalTime) {
                        taskDef.dueTime = newTime;
                        hasChanges = true;
                    }
                }
            });

            if (hasChanges) {
                // FIX v3.7: Clear stale violation cache before regenerating
                window.constraintViolations = {};

                // Regenerate calendar to apply overrides
                generateCalendar(true);
                showMessage('Task date & time overrides applied', 'success');
            }

            closeUnifiedEditModal(); // v4.0: Fixed - was closing wrong modal
        }

        function removeAllTaskOverrides() {
            // Get current period index from the modal
            const inputs = document.querySelectorAll('#taskOverrideList .task-date-input');
            if (inputs.length === 0) return;

            const periodIndex = parseFloat(inputs[0].dataset.periodIndex);

            // Remove all overrides for this period
            const keysToRemove = Object.keys(taskDateOverrides).filter(
                key => key.startsWith(`${periodIndex}-`)
            );

            keysToRemove.forEach(key => delete taskDateOverrides[key]);

            if (keysToRemove.length > 0) {
                generateCalendar(true);
                showMessage('All task overrides removed for this period', 'success');
            }
        }

        // ===== END CONSTRAINT OVERRIDE MODAL FUNCTIONS =====

        function formatDateForInput(date) {
            // Convert Date to YYYY-MM-DD format for date input
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatTimeDisplay(time24) {
            // Convert 24-hour time (HH:MM) to 12-hour format with am/pm
            if (!time24) return '';

            const [hours, minutes] = time24.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'pm' : 'am';
            const hour12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);

            return `${hour12}:${minutes}${ampm}`;
        }

        // Task Time Modal Functions
        let currentTaskIndex = null;

        function showTaskTimeModal(taskIndex) {
            currentTaskIndex = taskIndex;
            const task = tasks[taskIndex];

            const modal = document.getElementById('taskTimeModal');
            const label = document.getElementById('taskTimeLabel');
            const input = document.getElementById('taskTimeInput');
            const clearBtn = document.getElementById('clearTimeBtn');

            label.textContent = task.name;
            input.value = task.dueTime || '';

            // Show/hide clear button based on whether there's a time set
            clearBtn.style.display = task.dueTime ? 'inline-block' : 'none';

            modal.style.display = 'flex';
        }

        function closeTaskTimeModal() {
            const modal = document.getElementById('taskTimeModal');
            modal.style.display = 'none';
            currentTaskIndex = null;
        }

        function saveTaskTime() {
            if (currentTaskIndex === null) return;

            const input = document.getElementById('taskTimeInput');
            const newTime = input.value;

            tasks[currentTaskIndex].dueTime = newTime || '';

            closeTaskTimeModal();
            renderTasks();
        }

        function clearTaskTime() {
            if (currentTaskIndex === null) return;

            tasks[currentTaskIndex].dueTime = '';

            closeTaskTimeModal();
            renderTasks();
        }

        function getTimezoneAbbr() {
            const timezone = document.getElementById('calendarTimezone')?.value || '';
            if (!timezone) return '';

            // Map of timezone to abbreviation
            const tzMap = {
                'UTC': 'UTC',
                'America/New_York': 'ET',
                'America/Chicago': 'CT',
                'America/Denver': 'MT',
                'America/Los_Angeles': 'PT',
                'Europe/London': 'GMT',
                'Europe/Paris': 'CET',
                'Europe/Berlin': 'CET',
                'Asia/Dubai': 'GST',
                'Asia/Singapore': 'SGT',
                'Asia/Hong_Kong': 'HKT',
                'Asia/Tokyo': 'JST',
                'Australia/Sydney': 'AEDT'
            };

            return tzMap[timezone] || '';
        }

        // Handle timezone change event
        let isTimezoneChanging = false;
        function onTimezoneChange() {
            if (isTimezoneChanging) return; // Prevent recursion if user changes again during modals

            const timezone = document.getElementById('calendarTimezone').value;

            // Only show prompt if a timezone is selected (not empty)
            if (timezone) {
                isTimezoneChanging = true;
                showStandardTimeConfirmModal();
            }
        }

        function showStandardTimeConfirmModal() {
            const modal = document.getElementById('standardTimeConfirmModal');
            modal.style.display = 'flex';
        }

        function closeStandardTimeConfirmModal() {
            const modal = document.getElementById('standardTimeConfirmModal');
            modal.style.display = 'none';
            isTimezoneChanging = false;
        }

        function showStandardTimeInputModal() {
            // Close confirmation modal
            const confirmModal = document.getElementById('standardTimeConfirmModal');
            confirmModal.style.display = 'none';

            // Show input modal
            const inputModal = document.getElementById('standardTimeInputModal');
            const input = document.getElementById('standardTimeInput');
            input.value = ''; // Clear previous value
            inputModal.style.display = 'flex';
        }

        function closeStandardTimeInputModal() {
            const modal = document.getElementById('standardTimeInputModal');
            modal.style.display = 'none';
            isTimezoneChanging = false;
        }

        function applyStandardTime() {
            const timeInput = document.getElementById('standardTimeInput');
            const standardTime = timeInput.value;

            if (!standardTime) {
                showMessage('Please select a time', 'error');
                return;
            }

            // Apply this time to all tasks
            tasks.forEach(task => {
                task.dueTime = standardTime;
            });

            // Close modal and refresh task list
            closeStandardTimeInputModal();
            renderTasks();
            showMessage('Standard due time applied to all tasks', 'success');
        }

        // ========== ADVANCED TASK RULES (CONSTRAINTS) FUNCTIONS ==========

        function openConstraintsModal() {
            populateConstraintDropdowns();
            renderConstraintsList();
            updateConstraintCount();
            document.getElementById('constraintsModal').style.display = 'flex';
        }

        function closeConstraintsModal() {
            document.getElementById('constraintsModal').style.display = 'none';
            document.getElementById('constraintTask1').value = '';
            document.getElementById('constraintTask2').value = '';
        }

        function populateConstraintDropdowns() {
            const task1Select = document.getElementById('constraintTask1');
            const task2Select = document.getElementById('constraintTask2');

            task1Select.innerHTML = '<option value="">Select task...</option>';
            task2Select.innerHTML = '<option value="">Select task...</option>';

            tasks.forEach((task, index) => {
                // Include all tasks in constraint dropdowns
                const option1 = document.createElement('option');
                option1.value = index;
                option1.textContent = task.name;
                task1Select.appendChild(option1);

                const option2 = document.createElement('option');
                option2.value = index;
                option2.textContent = task.name;
                task2Select.appendChild(option2);
            });
        }

        function renderConstraintsList() {
            const container = document.getElementById('constraintsList');

            if (taskConstraints.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 32px; color: var(--text-light);">
                        <p style="font-size: 15px;">No task rules defined yet</p>
                        <p style="font-size: 13px; margin-top: 8px;">Add rules below to prevent tasks from being on the same date</p>
                    </div>
                `;
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 12px;">';
            taskConstraints.forEach(constraint => {
                html += `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; background: white; border: 1.5px solid var(--border-light); border-radius: 8px;">
                        <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                            <span style="font-size: 18px;">âš¡</span>
                            <span style="font-size: 14px; color: var(--text-dark);">
                                <strong>${constraint.task1Name}</strong> â‰  <strong>${constraint.task2Name}</strong>
                            </span>
                        </div>
                        <button class="danger small" onclick="deleteConstraint(${constraint.id})" style="flex-shrink: 0;">Delete</button>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function addConstraint() {
            const task1Index = parseInt(document.getElementById('constraintTask1').value);
            const task2Index = parseInt(document.getElementById('constraintTask2').value);

            // Validation
            if (isNaN(task1Index) || isNaN(task2Index)) {
                showMessage('Please select both tasks', 'error');
                return;
            }

            if (task1Index === task2Index) {
                showMessage('Cannot constrain a task with itself', 'error');
                return;
            }

            const task1Name = tasks[task1Index].name;
            const task2Name = tasks[task2Index].name;

            // Check for duplicate (order-independent)
            const duplicate = taskConstraints.some(c =>
                (c.task1Index === task1Index && c.task2Index === task2Index) ||
                (c.task1Index === task2Index && c.task2Index === task1Index)
            );

            if (duplicate) {
                showMessage('This constraint already exists', 'error');
                return;
            }

            // Add constraint
            const newConstraint = {
                id: Date.now(),
                task1Index: task1Index,
                task2Index: task2Index,
                task1Name: task1Name,
                task2Name: task2Name
            };

            taskConstraints.push(newConstraint);
            console.log(`âœ“ Added constraint: ${task1Name} â‰  ${task2Name}`);

            // Update UI
            renderConstraintsList();
            updateConstraintCount();
            document.getElementById('constraintTask1').value = '';
            document.getElementById('constraintTask2').value = '';
            showMessage('Task rule added successfully', 'success');
        }

        function deleteConstraint(constraintId) {
            if (confirm('Delete this task rule?')) {
                const index = taskConstraints.findIndex(c => c.id === constraintId);
                if (index > -1) {
                    const constraint = taskConstraints[index];
                    console.log(`âœ“ Deleted constraint: ${constraint.task1Name} â‰  ${constraint.task2Name}`);
                    taskConstraints.splice(index, 1);
                    renderConstraintsList();
                    updateConstraintCount();
                    showMessage('Task rule deleted', 'success');
                }
            }
        }

        function updateConstraintCount() {
            const badge = document.getElementById('constraintsBadge');
            if (badge) {
                if (taskConstraints.length > 0) {
                    badge.textContent = taskConstraints.length;
                    badge.style.display = 'inline-flex';
                } else {
                    badge.style.display = 'none';
                }
            }
        }

        // Maintenance functions for constraint integrity

        function onTaskDeleted(taskIndex) {
            // Remove any constraints involving the deleted task
            const before = taskConstraints.length;
            taskConstraints = taskConstraints.filter(c =>
                c.task1Index !== taskIndex && c.task2Index !== taskIndex
            );

            // Update indices for remaining tasks (shift down)
            taskConstraints.forEach(c => {
                if (c.task1Index > taskIndex) c.task1Index--;
                if (c.task2Index > taskIndex) c.task2Index--;
            });

            if (taskConstraints.length < before) {
                console.log(`âœ“ Removed ${before - taskConstraints.length} constraint(s) involving deleted task`);
                updateConstraintCount();
            }
        }

        function onTaskReordered(oldIndex, newIndex) {
            // Update constraint indices when tasks are moved
            taskConstraints.forEach(c => {
                if (c.task1Index === oldIndex) {
                    c.task1Index = newIndex;
                } else if (c.task1Index === newIndex) {
                    c.task1Index = oldIndex;
                }

                if (c.task2Index === oldIndex) {
                    c.task2Index = newIndex;
                } else if (c.task2Index === newIndex) {
                    c.task2Index = oldIndex;
                }
            });
        }

        function onTaskRenamed(taskIndex, newName) {
            // Update constraint names when a task is renamed
            taskConstraints.forEach(c => {
                if (c.task1Index === taskIndex) {
                    c.task1Name = newName;
                }
                if (c.task2Index === taskIndex) {
                    c.task2Name = newName;
                }
            });
        }

        function getConstraintIndicator(taskIndex) {
            // Returns HTML for constraint icon if task has constraints
            const hasConstraint = taskConstraints.some(c =>
                c.task1Index === taskIndex || c.task2Index === taskIndex
            );

            if (hasConstraint) {
                return '<span style="color: var(--warning-orange); font-size: 14px; margin-left: 6px;" title="Has constraint rule">âš¡</span>';
            }
            return '';
        }

        // ========================================
        // OFF-CYCLE WIZARD FUNCTIONS (v4.0)
        // ========================================

        let wizardState = {
            currentStep: 1,
            quantity: null, // 'single' or 'multiple'
            placement: null, // 'before' or 'after'
            selectedPeriods: [],
            offCycleName: '', // v4.0: Optional custom name for off-cycle
            payDateMode: 'manual', // 'offset' or 'manual' - default to manual
            payDateOffset: 7,
            manualPayDates: {},
            taskMode: 'standard', // 'standard' or 'custom'
            selectedTasks: [],
            offsetMode: 'standard', // 'standard' or 'custom'
            customOffsets: {},
            taskDateMode: {}, // v4.0: Track which tasks use specific dates vs offsets
            taskSpecificDates: {}, // v4.0: Store specific dates for tasks
            constraints: []
        };

        function openOffCycleWizard() {
            // Check if calendar has been generated
            if (generatedCalendar.length === 0) {
                showMessage('Please generate a payroll calendar first before adding off-cycles.', 'error');
                return;
            }

            // Reset wizard state
            wizardState = {
                currentStep: 1,
                quantity: 'single', // v4.0: Default to single off-cycle
                placement: null,
                selectedPeriods: [],
                offCycleName: '',
                payDateMode: 'manual',
                payDateOffset: 7,
                manualPayDates: {},
                taskMode: 'standard',
                selectedTasks: [],
                offsetMode: 'custom', // v4.0: Default to custom (date picker) mode
                customOffsets: {},
                taskDateMode: {},
                taskSpecificDates: {},
                constraints: []
            };

            // Reset the name input field
            const nameInput = document.getElementById('offCycleName');
            if (nameInput) nameInput.value = '';

            // Show wizard
            document.getElementById('offCycleWizard').style.display = 'flex';
            updateWizardStep(1);
        }

        function closeOffCycleWizard() {
            document.getElementById('offCycleWizard').style.display = 'none';
        }

        function wizardNextStep() {
            // Validate current step before proceeding
            if (!validateWizardStep(wizardState.currentStep)) {
                return;
            }

            // Move to next step
            wizardState.currentStep++;
            updateWizardStep(wizardState.currentStep);
        }

        function wizardPrevStep() {
            wizardState.currentStep--;
            updateWizardStep(wizardState.currentStep);
        }

        function updateWizardStep(step) {
            // Update progress indicator
            document.querySelectorAll('.wizard-step').forEach((el, index) => {
                const stepNum = index + 1;
                el.classList.remove('active', 'completed');
                if (stepNum < step) {
                    el.classList.add('completed');
                } else if (stepNum === step) {
                    el.classList.add('active');
                }
            });

            // Update panels
            document.querySelectorAll('.wizard-panel').forEach((panel, index) => {
                panel.classList.remove('active');
                if (index + 1 === step) {
                    panel.classList.add('active');
                }
            });

            // Update navigation buttons
            const backBtn = document.getElementById('wizardBackBtn');
            const nextBtn = document.getElementById('wizardNextBtn');
            const finishBtn = document.getElementById('wizardFinishBtn');

            backBtn.style.display = step > 1 ? 'block' : 'none';
            nextBtn.style.display = step < 6 ? 'block' : 'none';
            finishBtn.style.display = step === 6 ? 'block' : 'none';

            // Populate dynamic content for each step
            if (step === 1) {
                // v4.0: Sync UI with default quantity selection
                document.querySelectorAll('#wizardStep1 .option-card').forEach(card => {
                    card.classList.remove('selected');
                });
                if (wizardState.quantity === 'single') {
                    document.getElementById('quantitySingle')?.classList.add('selected');
                } else if (wizardState.quantity === 'multiple') {
                    document.getElementById('quantityMultiple')?.classList.add('selected');
                }
            } else if (step === 2) {
                populatePeriodSelectors();
            } else if (step === 3) {
                // v4.0: Ensure periods are captured before configuring pay dates
                if (wizardState.quantity === 'single') {
                    const singlePeriodSelect = document.getElementById('singlePeriodSelect');
                    const singlePosition = document.getElementById('singlePosition');
                    if (singlePeriodSelect && singlePeriodSelect.value) {
                        wizardState.selectedPeriods = [parseInt(singlePeriodSelect.value)];
                        wizardState.placement = singlePosition?.value || 'after';
                    }
                } else {
                    updateSelectedPeriods();
                }
                // v4.0: Simplified - always manual mode
                wizardState.payDateMode = 'manual';
                populateManualPayDates();
            } else if (step === 4) {
                // v4.0: Simplified - always custom mode
                wizardState.taskMode = 'custom';
                populateTaskSelector();
            } else if (step === 5) {
                // v4.0: Simplified - always custom (date picker) mode
                wizardState.offsetMode = 'custom';
                populateOffsetEditor();
            } else if (step === 6) {
                renderOffCycleConstraints();
            }
        }

        function validateWizardStep(step) {
            switch(step) {
                case 1:
                    // v4.0: Default is pre-selected, validation always passes
                    if (!wizardState.quantity) {
                        showMessage('Please select whether you are adding a single or multiple off-cycles.', 'error');
                        return false;
                    }
                    return true;

                case 2:
                    // v4.0: Auto-capture period selection before validating
                    if (wizardState.quantity === 'single') {
                        const singlePeriodSelect = document.getElementById('singlePeriodSelect');
                        const singlePosition = document.getElementById('singlePosition');
                        if (singlePeriodSelect && singlePeriodSelect.value) {
                            wizardState.selectedPeriods = [parseInt(singlePeriodSelect.value)];
                            wizardState.placement = singlePosition?.value || 'after';
                        }
                    } else {
                        updateSelectedPeriods();
                    }

                    if (wizardState.selectedPeriods.length === 0) {
                        showMessage('Please select at least one pay period.', 'error');
                        return false;
                    }
                    return true;

                case 3:
                    // v4.0: Simplified - always manual mode
                    // Check all manual dates are filled
                    for (let periodIdx of wizardState.selectedPeriods) {
                        if (!wizardState.manualPayDates[periodIdx]) {
                            showMessage('Please enter pay dates for all selected periods.', 'error');
                            return false;
                        }
                    }
                    return true;

                case 4:
                    // v4.0: Simplified - always custom mode, must select at least one task
                    if (wizardState.selectedTasks.length === 0) {
                        showMessage('Please select at least one task for the off-cycle periods.', 'error');
                        return false;
                    }
                    return true;

                case 5:
                    // v4.0: Offset validation is optional (date picker mode)
                    return true;

                case 6:
                    // Constraints are optional
                    return true;

                default:
                    return true;
            }
        }

        // Step 1: Quantity Selection
        function selectOffCycleQuantity(quantity) {
            wizardState.quantity = quantity;

            // Update UI
            document.querySelectorAll('#wizardStep1 .option-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('quantity' + (quantity === 'single' ? 'Single' : 'Multiple')).classList.add('selected');
        }

        // Step 2: Period Placement
        function populatePeriodSelectors() {
            const singlePlacement = document.getElementById('singlePlacement');
            const multiplePlacement = document.getElementById('multiplePlacement');
            const singlePeriodSelect = document.getElementById('singlePeriodSelect');
            const multiplePeriodSelect = document.getElementById('multiplePeriodSelect');

            // Get unique periods (generatedCalendar has multiple entries per period, one per task)
            const uniquePeriods = [];
            const seenPeriods = new Set();
            generatedCalendar.forEach(entry => {
                if (!seenPeriods.has(entry.period) && !entry.isOffCycle) {
                    seenPeriods.add(entry.period);
                    uniquePeriods.push({
                        index: entry.period,
                        label: entry.periodLabel
                    });
                }
            });

            // Show appropriate placement UI
            if (wizardState.quantity === 'single') {
                singlePlacement.style.display = 'block';
                multiplePlacement.style.display = 'none';

                // Populate single period selector
                singlePeriodSelect.innerHTML = '';
                uniquePeriods.forEach(period => {
                    const option = document.createElement('option');
                    option.value = period.index;
                    option.textContent = period.label;
                    singlePeriodSelect.appendChild(option);
                });

                // Set default selection
                if (wizardState.selectedPeriods.length === 0) {
                    wizardState.selectedPeriods = [uniquePeriods[0]?.index || 0];
                    wizardState.placement = 'after';
                }
            } else {
                singlePlacement.style.display = 'none';
                multiplePlacement.style.display = 'block';

                // Populate multiple period checkboxes
                multiplePeriodSelect.innerHTML = '';
                uniquePeriods.forEach(period => {
                    const checkbox = document.createElement('label');
                    checkbox.className = 'period-checkbox';
                    checkbox.innerHTML = `
                        <input type="checkbox" value="${period.index}" onchange="updateSelectedPeriods()" ${wizardState.selectedPeriods.includes(period.index) ? 'checked' : ''}>
                        <span>${period.label}</span>
                    `;
                    multiplePeriodSelect.appendChild(checkbox);
                });

                // Set default placement
                if (!wizardState.placement) {
                    wizardState.placement = 'after';
                }
            }
        }

        function updateSelectedPeriods() {
            const checkboxes = document.querySelectorAll('#multiplePeriodSelect input[type="checkbox"]');
            wizardState.selectedPeriods = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => parseInt(cb.value));

            // Update placement from dropdown
            wizardState.placement = document.getElementById(wizardState.quantity === 'single' ? 'singlePosition' : 'multiplePosition').value;
        }

        function toggleAllPeriods() {
            const allCheckbox = document.getElementById('allPeriodsCheckbox');
            const checkboxes = document.querySelectorAll('#multiplePeriodSelect input[type="checkbox"]');
            const periodSelector = document.getElementById('periodSelectorContainer');

            if (allCheckbox.checked) {
                periodSelector.style.display = 'none';
                // Select all periods
                wizardState.selectedPeriods = [];
                generatedCalendar.forEach((period, index) => {
                    if (!period.isOffCycle) {
                        wizardState.selectedPeriods.push(index);
                    }
                });
            } else {
                periodSelector.style.display = 'block';
                updateSelectedPeriods();
            }
        }

        // Step 3: Pay Date Configuration
        // v4.0: Simplified - No mode selection, always manual
        function updateWizardPayDateConfig() {
            // IMPORTANT: Ensure selected periods are captured from Step 2 before populating dates
            if (wizardState.quantity === 'single') {
                const singlePeriodSelect = document.getElementById('singlePeriodSelect');
                if (singlePeriodSelect && singlePeriodSelect.value) {
                    wizardState.selectedPeriods = [parseInt(singlePeriodSelect.value)];
                    wizardState.placement = document.getElementById('singlePosition')?.value || 'after';
                }
            } else {
                updateSelectedPeriods();
            }

            // v4.0: Always manual mode
            wizardState.payDateMode = 'manual';

            // v4.0: Simplified - Always populate manual dates
            populateManualPayDates();
        }

        function populateManualPayDates() {
            console.log('ðŸŽ¯ populateManualPayDates called at', new Date().toISOString());

            const container = document.getElementById('manualPayDateList');
            if (!container) {
                console.error('âŒ manualPayDateList container not found!');
                return;
            }
            console.log('âœ… Container found:', container);

            container.innerHTML = '';

            // Ensure placement is updated from current UI
            if (wizardState.quantity === 'single') {
                const singlePeriodSelect = document.getElementById('singlePeriodSelect');
                const singlePosition = document.getElementById('singlePosition');
                if (singlePeriodSelect && singlePeriodSelect.value) {
                    wizardState.selectedPeriods = [parseInt(singlePeriodSelect.value)];
                    wizardState.placement = singlePosition?.value || 'after';
                    console.log('âœ… Captured single period:', {
                        periodIndex: singlePeriodSelect.value,
                        placement: singlePosition?.value
                    });
                } else {
                    console.warn('âš ï¸ singlePeriodSelect element or value not found');
                }
            } else {
                updateSelectedPeriods();
            }

            console.log('ðŸ” Current wizardState:', {
                selectedPeriods: wizardState.selectedPeriods,
                placement: wizardState.placement,
                quantity: wizardState.quantity,
                payDateOffset: wizardState.payDateOffset
            });

            console.log('ðŸ“Š generatedCalendar status:', {
                exists: !!generatedCalendar,
                length: generatedCalendar?.length || 0,
                sampleEntry: generatedCalendar?.[0]
            });

            if (wizardState.selectedPeriods.length === 0) {
                console.warn('âš ï¸ No periods selected - cannot populate manual dates');
                container.innerHTML = '<p style="color: var(--text-medium); font-size: 13px; padding: 12px;">Please select a period in the previous step.</p>';
                return;
            }

            let inputsCreated = 0;
            wizardState.selectedPeriods.forEach(periodIdx => {
                console.log('ðŸ” Looking for period index:', periodIdx, 'Type:', typeof periodIdx);
                const period = generatedCalendar.find(e => e.period === periodIdx && e.task === 'Pay Date');
                console.log('ðŸ” Search result for period', periodIdx, ':', period);

                if (!period) {
                    console.error('âŒ Period not found! Searching in generatedCalendar...');
                    console.log('Available periods:', generatedCalendar
                        .filter(e => e.task === 'Pay Date')
                        .map(e => ({ period: e.period, label: e.periodLabel }))
                    );
                    return;
                }

                const dateInput = document.createElement('div');
                dateInput.className = 'form-group';
                dateInput.style.marginBottom = '16px';

                const savedDate = wizardState.manualPayDates[periodIdx];

                // v4.0: Calculate suggested date based on reference period and placement
                const offset = wizardState.payDateOffset || 7; // Define offset outside if/else so it's accessible in template
                let dateValue = '';
                if (savedDate) {
                    dateValue = savedDate.toISOString().split('T')[0];
                } else {
                    // Suggest a date based on the reference period's pay date and offset
                    const refPayDate = new Date(period.date);
                    const suggestedDate = new Date(refPayDate);

                    if (wizardState.placement === 'before') {
                        suggestedDate.setDate(suggestedDate.getDate() - offset);
                    } else {
                        suggestedDate.setDate(suggestedDate.getDate() + offset);
                    }

                    dateValue = suggestedDate.toISOString().split('T')[0];

                    // v4.0: AUTO-SAVE - Store suggested date immediately so validation passes
                    wizardState.manualPayDates[periodIdx] = suggestedDate;
                }

                dateInput.innerHTML = `
                    <label>Off-Cycle Pay Date ${wizardState.placement} ${period.periodLabel}</label>
                    <input type="date"
                           data-period="${periodIdx}"
                           value="${dateValue}"
                           onchange="updateManualPayDate(${periodIdx}, this.value)"
                           onclick="event.stopPropagation()"
                           onfocus="event.stopPropagation()"
                           style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                    <span class="help-text">Please select the Pay Date for the Off-Cycle.</span>
                `;
                console.log('âœ… Created date input HTML for period', periodIdx);
                console.log('ðŸ“ Date input HTML:', dateInput.outerHTML.substring(0, 200) + '...');
                container.appendChild(dateInput);
                inputsCreated++;
                console.log('âœ… Appended date input to container. Total inputs:', inputsCreated);
            });

            console.log('ðŸŽ‰ populateManualPayDates complete. Total inputs created:', inputsCreated);
            console.log('ðŸ“¦ Final container HTML length:', container.innerHTML.length);
        }

        function updateManualPayDate(periodIdx, dateString) {
            if (dateString) {
                wizardState.manualPayDates[periodIdx] = new Date(dateString);
            } else {
                delete wizardState.manualPayDates[periodIdx];
            }
        }

        // Step 4: Task Selection
        // v4.0: Simplified - Always custom mode, no mode selection needed

        function populateTaskSelector() {
            const container = document.getElementById('taskCheckboxList');
            if (!container) return;

            container.innerHTML = '';

            // v4.0: Exclude "Pay Date" from task selector since it's already configured in Step 3
            tasks.forEach((task, index) => {
                if (task.name === 'Pay Date') return; // Skip Pay Date task

                const checkbox = document.createElement('label');
                checkbox.className = 'period-checkbox';
                checkbox.innerHTML = `
                    <input type="checkbox"
                           value="${index}"
                           onchange="updateSelectedTasks()"
                           ${wizardState.selectedTasks.includes(index) ? 'checked' : ''}>
                    <span>${task.name}</span>
                `;
                container.appendChild(checkbox);
            });
        }

        function updateSelectedTasks() {
            const checkboxes = document.querySelectorAll('#taskCheckboxList input[type="checkbox"]');
            wizardState.selectedTasks = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => parseInt(cb.value));
        }

        // Step 5: Offset Configuration
        // v4.0: Simplified - Always date picker mode, no toggle

        function toggleApplyToAll() {
            populateOffsetEditor();
        }

        // v4.0: Helper function to get period name/label from period index
        function getPeriodName(periodIdx) {
            // Look up the period in the generated calendar
            const periodEntry = generatedCalendar.find(entry => entry.period === periodIdx);
            if (periodEntry && periodEntry.periodLabel) {
                return periodEntry.periodLabel;
            }
            // Fallback to generic label
            return `Period ${periodIdx}`;
        }

        function populateOffsetEditor() {
            if (wizardState.offsetMode !== 'custom') return;

            const container = document.getElementById('offsetInputList');
            container.innerHTML = '';

            // Show/hide the "apply to all" checkbox for multiple off-cycles
            const multipleOption = document.getElementById('multipleOffCycleOption');
            const applyToAllCheckbox = document.getElementById('applyToAllOffCycles');
            const applyToAll = applyToAllCheckbox ? applyToAllCheckbox.checked : true;

            if (wizardState.quantity === 'multiple' && wizardState.selectedPeriods.length > 1) {
                multipleOption.style.display = 'block';
                document.getElementById('offCycleCountDisplay').textContent = wizardState.selectedPeriods.length;
            } else {
                multipleOption.style.display = 'none';
            }

            // Initialize state objects if not present
            if (!wizardState.taskSpecificDates) wizardState.taskSpecificDates = {};

            // Get task list based on task mode
            const taskList = wizardState.taskMode === 'custom'
                ? wizardState.selectedTasks.map(idx => ({ index: idx, task: tasks[idx] }))
                : tasks.map((task, index) => ({ index, task }));

            // v4.0: Determine which periods to show
            const periodsToShow = (wizardState.quantity === 'multiple' && !applyToAll)
                ? wizardState.selectedPeriods
                : [wizardState.selectedPeriods[0]]; // Show only first period if applying to all

            // Loop through periods (one if applying to all, multiple if not)
            periodsToShow.forEach((periodIdx, periodSeqNum) => {
                // Add period header if showing multiple periods
                if (periodsToShow.length > 1) {
                    const periodHeader = document.createElement('div');
                    const periodName = getPeriodName(periodIdx);
                    periodHeader.style.cssText = 'background: #F0F9FF; padding: 12px 16px; margin-top: 16px; border-left: 3px solid #0EA5E9; font-weight: 600; font-size: 14px; color: var(--text-dark);';
                    periodHeader.textContent = `${periodName} Off-Cycle (${periodSeqNum + 1} of ${periodsToShow.length})`;
                    container.appendChild(periodHeader);
                }

                // Loop through tasks for this period
                taskList.forEach(({index, task}) => {
                    const defaultOffset = task.offset || 0;
                    const currentOffset = wizardState.customOffsets[index] !== undefined
                        ? wizardState.customOffsets[index]
                        : defaultOffset;

                    // v4.0: Use composite key for storing dates per period and task
                    const dateKey = `${periodIdx}_${index}`;
                    const specificDate = wizardState.taskSpecificDates[dateKey];

                    // v4.0: Calculate suggested date based on off-cycle pay date and task offset
                    let dateValue = '';
                    if (specificDate) {
                        dateValue = specificDate.toISOString().split('T')[0];
                    } else {
                        // Determine the off-cycle pay date (use manual date if specified, otherwise calculate)
                        let offCyclePayDate;
                        if (wizardState.payDateMode === 'manual' && wizardState.manualPayDates[periodIdx]) {
                            // Use the manually selected pay date
                            offCyclePayDate = new Date(wizardState.manualPayDates[periodIdx]);
                        } else {
                            // Calculate from reference period and offset
                            const refPeriod = generatedCalendar.find(e => e.period === periodIdx && e.task === 'Pay Date');
                            if (refPeriod) {
                                const refPayDate = new Date(refPeriod.date);
                                const payDateOffset = wizardState.payDateOffset || 7;
                                offCyclePayDate = new Date(refPayDate);
                                if (wizardState.placement === 'before') {
                                    offCyclePayDate.setDate(offCyclePayDate.getDate() - payDateOffset);
                                } else {
                                    offCyclePayDate.setDate(offCyclePayDate.getDate() + payDateOffset);
                                }
                            }
                        }

                        if (offCyclePayDate) {
                            // Default to same week as off-cycle pay date - use pay date itself as starting point
                            const suggestedTaskDate = new Date(offCyclePayDate);
                            const taskOffset = parseInt(currentOffset) || 0;

                            // Adjust based on whether task is before or after pay date
                            if (task.beforePayDate && taskOffset !== 0) {
                                suggestedTaskDate.setDate(suggestedTaskDate.getDate() - Math.abs(taskOffset));
                            } else if (task.afterPayDate && taskOffset !== 0) {
                                suggestedTaskDate.setDate(suggestedTaskDate.getDate() + Math.abs(taskOffset));
                            }
                            // If task has no specific timing (not before or after), default to pay date itself

                            dateValue = suggestedTaskDate.toISOString().split('T')[0];
                        }
                    }

                    const inputGroup = document.createElement('div');
                    inputGroup.style.cssText = 'padding: 16px 12px; border-bottom: 1px solid var(--border-light);';

                    // v4.0: Simplified - Always show date picker
                    inputGroup.innerHTML = `
                        <div style="margin-bottom: 8px;">
                            <span style="font-size: 14px; color: var(--text-dark); font-weight: 500;">${task.name}</span>
                        </div>
                        <div>
                            <label style="font-size: 12px; color: var(--text-medium); display: block; margin-bottom: 4px;">Select Date</label>
                            <input type="date"
                                   value="${dateValue}"
                                   onchange="updateTaskSpecificDate('${dateKey}', this.value)"
                                   onclick="event.stopPropagation()"
                                   onfocus="event.stopPropagation()"
                                   style="width: 100%; padding: 10px 12px; border: 1.5px solid var(--border-light); border-radius: 4px; font-size: 14px;">
                            <span style="font-size: 11px; color: var(--text-light); margin-top: 4px; display: block;">Please select the due date for this off-cycle pay-period task.</span>
                        </div>
                        ${specificDate ? '<div style="margin-top: 8px; font-size: 12px; color: var(--success-teal);">âœ“ Date confirmed</div>' : ''}
                    `;

                    container.appendChild(inputGroup);
                });
            });
        }

        function updateTaskSpecificDate(dateKey, dateString) {
            // v4.0: dateKey can be either taskIndex (for single/apply-to-all) or "periodIdx_taskIndex" (for individual config)
            if (!wizardState.taskSpecificDates) wizardState.taskSpecificDates = {};
            if (dateString) {
                wizardState.taskSpecificDates[dateKey] = new Date(dateString);
                // Re-render to show the confirmation message
                populateOffsetEditor();
            } else {
                delete wizardState.taskSpecificDates[dateKey];
                populateOffsetEditor();
            }
        }

        function updateCustomOffset(taskIndex, value) {
            wizardState.customOffsets[taskIndex] = parseInt(value) || 0;
        }

        // Step 6: Advanced Rules
        function renderOffCycleConstraints() {
            const container = document.getElementById('offCycleConstraintsList');

            if (wizardState.constraints.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 24px; color: var(--text-light); background: #fafafa; border-radius: 8px;">
                        <p style="font-size: 14px;">No constraint rules added yet</p>
                    </div>
                `;
                return;
            }

            let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
            wizardState.constraints.forEach((constraint, idx) => {
                html += `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: white; border: 1.5px solid var(--border-light); border-radius: 6px;">
                        <span style="font-size: 13px; color: var(--text-dark);">
                            <strong>${constraint.task1Name}</strong> â‰  <strong>${constraint.task2Name}</strong>
                        </span>
                        <button onclick="removeOffCycleConstraint(${idx})" style="background: none; border: none; color: var(--danger-red); cursor: pointer; font-size: 18px; padding: 0 8px;">&times;</button>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function addOffCycleConstraint() {
            const taskList = wizardState.taskMode === 'custom'
                ? wizardState.selectedTasks
                : tasks.map((t, i) => i);

            if (taskList.length < 2) {
                showMessage('Need at least 2 tasks to create a constraint rule.', 'error');
                return;
            }

            // Show inline constraint selector
            const container = document.getElementById('offCycleConstraintsList');
            const selectorHtml = `
                <div id="offCycleConstraintSelector" style="background: #f9fafb; border: 2px solid var(--primary-purple); border-radius: 8px; padding: 16px; margin-bottom: 12px;">
                    <div style="font-weight: 600; margin-bottom: 12px; color: var(--text-dark);">Add Constraint Rule</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                        <div>
                            <label style="font-size: 12px; color: var(--text-medium); display: block; margin-bottom: 4px;">Task 1</label>
                            <select id="offCycleTask1" style="width: 100%; padding: 8px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <option value="">Select task...</option>
                                ${taskList.map(idx => `<option value="${idx}">${tasks[idx].name}</option>`).join('')}
                            </select>
                        </div>
                        <div>
                            <label style="font-size: 12px; color: var(--text-medium); display: block; margin-bottom: 4px;">Task 2</label>
                            <select id="offCycleTask2" style="width: 100%; padding: 8px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <option value="">Select task...</option>
                                ${taskList.map(idx => `<option value="${idx}">${tasks[idx].name}</option>`).join('')}
                            </select>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="primary" onclick="confirmOffCycleConstraint()" style="flex: 1;">Add Rule</button>
                        <button class="secondary" onclick="cancelOffCycleConstraint()">Cancel</button>
                    </div>
                </div>
            `;

            // Remove existing selector if present
            const existingSelector = document.getElementById('offCycleConstraintSelector');
            if (existingSelector) {
                existingSelector.remove();
            }

            // Insert at the top of the container
            container.insertAdjacentHTML('afterbegin', selectorHtml);
        }

        function confirmOffCycleConstraint() {
            const task1Idx = parseInt(document.getElementById('offCycleTask1').value);
            const task2Idx = parseInt(document.getElementById('offCycleTask2').value);

            if (isNaN(task1Idx) || isNaN(task2Idx)) {
                showMessage('Please select both tasks for the constraint rule.', 'error');
                return;
            }

            if (task1Idx === task2Idx) {
                showMessage('Please select two different tasks.', 'error');
                return;
            }

            wizardState.constraints.push({
                id: Date.now(),
                task1Index: task1Idx,
                task2Index: task2Idx,
                task1Name: tasks[task1Idx].name,
                task2Name: tasks[task2Idx].name
            });

            cancelOffCycleConstraint();
            renderOffCycleConstraints();
        }

        function cancelOffCycleConstraint() {
            const selector = document.getElementById('offCycleConstraintSelector');
            if (selector) {
                selector.remove();
            }
        }

        function removeOffCycleConstraint(index) {
            wizardState.constraints.splice(index, 1);
            renderOffCycleConstraints();
        }

        // Finish Wizard
        function finishOffCycleWizard() {
            // Final validation
            if (!validateWizardStep(wizardState.currentStep)) {
                return;
            }

            // Update placement from UI one final time
            if (wizardState.quantity === 'single') {
                wizardState.selectedPeriods = [parseInt(document.getElementById('singlePeriodSelect').value)];
                wizardState.placement = document.getElementById('singlePosition').value;
            } else {
                wizardState.placement = document.getElementById('multiplePosition').value;
            }

            // Create off-cycle configuration
            const offCycleConfig = {
                id: Date.now(),
                customName: wizardState.offCycleName || '', // v4.0: Optional custom name
                placement: wizardState.placement,
                relativeToPeriods: [...wizardState.selectedPeriods],
                payDates: {
                    mode: wizardState.payDateMode,
                    offsetDays: wizardState.payDateOffset,
                    dates: {...wizardState.manualPayDates}
                },
                tasks: {
                    mode: wizardState.taskMode,
                    selectedTasks: [...wizardState.selectedTasks],
                    offsets: {
                        mode: wizardState.offsetMode,
                        customOffsets: {...wizardState.customOffsets},
                        specificDates: {...(wizardState.taskSpecificDates || {})} // v4.0: Include specific dates
                    }
                },
                advancedRules: [...wizardState.constraints]
            };

            // Add to global off-cycle periods array
            offCyclePeriods.push(offCycleConfig);

            // Regenerate calendar with off-cycles
            generateCalendar();

            // Close wizard
            closeOffCycleWizard();

            showMessage('Off-cycle period(s) added successfully! Scroll down to see the updated calendar.', 'success');
        }

        window.onload = init;
    </script>

    <!-- Pay Date Override Modal -->
    <!-- Unified Edit Modal -->
    <div id="unifiedEditModal" class="modal-overlay" style="display: none;">
        <div class="modal" style="max-width: 90%; width: auto; max-height: 90vh; overflow-y: auto; padding-bottom: 0;">
            <h3 style="margin-bottom: 20px;">Edit Period: <span id="unifiedPeriodLabel"></span></h3>

            <!-- Tab Navigation -->
            <div class="tab-container">
                <button class="tab-button active" onclick="switchEditTab('periodSettings')">Period Settings</button>
                <button class="tab-button" onclick="switchEditTab('taskDates')">Task Dates</button>
            </div>

            <!-- Tab 1: Period Settings -->
            <div id="periodSettingsTab" class="tab-panel active">
                <!-- Pay Date Section -->
                <div class="form-group">
                    <label for="overridePayDateInput">Pay Date</label>
                    <input type="date" id="overridePayDateInput" style="width: 100%;">
                    <span class="help-text">Task dates will be adjusted to fit the new pay date while maintaining the cut-off date (unless you also edit cut-off below).</span>
                </div>

                <!-- Cut-Off Date Section -->
                <div class="form-group section-divider">
                    <label for="overrideCutoffInput">Cut-Off Date</label>
                    <input type="date" id="overrideCutoffInput" style="width: 100%;">
                    <span class="help-text">Task dates will be recalculated from this cut-off using working day offsets.</span>
                </div>

                <!-- Bank Holiday Section -->
                <div class="section-divider">
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label for="manualHolidayDate">Manual Bank Holiday Date</label>
                        <input type="date" id="manualHolidayDate" style="width: 100%;">
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="manualHolidayName">Holiday Name</label>
                        <input type="text" id="manualHolidayName" placeholder="e.g., Company Holiday" style="width: 100%;">
                        <span class="help-text">Add a bank holiday that wasn't automatically detected. This will affect working day calculations for this period.</span>
                    </div>
                </div>

                <!-- Period Settings Buttons -->
                <div class="modal-buttons" style="justify-content: space-between; margin-top: 20px;">
                    <button id="removePeriodOverrideBtn" class="danger" onclick="removePeriodOverrides()" style="display: none;">
                        Remove Override
                    </button>
                    <div style="display: flex; gap: 12px;">
                        <button class="secondary" onclick="closeUnifiedEditModal()">Cancel</button>
                        <button class="primary" onclick="applyPeriodSettings()">Apply Changes</button>
                    </div>
                </div>
            </div>

            <!-- Tab 2: Task Dates -->
            <div id="taskDatesTab" class="tab-panel">
                <p style="color: var(--warning-orange); margin-bottom: 16px; font-size: 13px;">
                    âš ï¸ Manual overrides bypass automatic constraint resolution. Working days are calculated between consecutive tasks.
                </p>
                <div id="taskOverrideList" style="max-height: 500px; overflow-x: auto; overflow-y: visible; margin-bottom: 20px;">
                    <!-- Task cards will be populated here in horizontal layout -->
                </div>

                <!-- Task Dates Buttons -->
                <div class="modal-buttons" style="justify-content: space-between; margin-top: 20px;">
                    <button class="danger" onclick="removeAllTaskOverrides(); closeUnifiedEditModal();" id="removeAllOverridesBtn">
                        Remove All Overrides
                    </button>
                    <div style="display: flex; gap: 12px;">
                        <button class="secondary" onclick="closeUnifiedEditModal()">Cancel</button>
                        <button class="primary" onclick="applyTaskOverrides()">Apply Overrides</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Time Modal -->
    <div id="taskTimeModal" class="modal-overlay" style="display: none;">
        <div class="modal" style="max-width: 400px;">
            <h3>Set Due Time</h3>
            <p style="color: var(--text-medium); margin-bottom: 20px;">
                Task: <strong id="taskTimeLabel"></strong>
            </p>
            <div class="form-group">
                <label for="taskTimeInput">Due Time (Optional)</label>
                <input type="time" id="taskTimeInput" style="width: 100%; padding: 8px 12px; font-size: 14px;">
                <span class="help-text">Select a specific time when this task is due.</span>
            </div>

            <div class="modal-buttons" style="justify-content: space-between; margin-top: 20px;">
                <button id="clearTimeBtn" class="secondary" onclick="clearTaskTime()" style="display: none;">
                    Clear Time
                </button>
                <div style="display: flex; gap: 12px; margin-left: auto;">
                    <button class="secondary" onclick="closeTaskTimeModal()">Cancel</button>
                    <button class="primary" onclick="saveTaskTime()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Standard Time Confirmation Modal -->
    <div id="standardTimeConfirmModal" class="modal-overlay" style="display: none;">
        <div class="modal" style="max-width: 450px;">
            <h3>Apply Standard Due Time</h3>
            <p style="color: var(--text-medium); margin-bottom: 20px;">
                Do you wish to apply a standard Due Time for all Payroll Tasks?
            </p>

            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="secondary" onclick="closeStandardTimeConfirmModal()">No</button>
                <button class="primary" onclick="showStandardTimeInputModal()">Yes</button>
            </div>
        </div>
    </div>

    <!-- Standard Time Input Modal -->
    <div id="standardTimeInputModal" class="modal-overlay" style="display: none;">
        <div class="modal" style="max-width: 400px;">
            <h3>Set Standard Due Time</h3>
            <p style="color: var(--text-medium); margin-bottom: 20px;">
                This time will be applied to all payroll tasks in the list.
            </p>
            <div class="form-group">
                <label for="standardTimeInput">Due Time</label>
                <input type="time" id="standardTimeInput" style="width: 100%; padding: 8px 12px; font-size: 14px;">
                <span class="help-text">Select a time to apply to all tasks.</span>
            </div>

            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="secondary" onclick="closeStandardTimeInputModal()">Cancel</button>
                <button class="primary" onclick="applyStandardTime()">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Advanced Task Rules Modal -->
    <div id="constraintsModal" class="modal-overlay" style="display: none;">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header">
                <h3 style="margin: 0; font-size: 20px; color: var(--text-dark);">Advanced Task Rules âš™ï¸</h3>
                <button class="close-button" onclick="closeConstraintsModal()" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <p style="color: var(--text-medium); margin-bottom: 24px; font-size: 14px;">
                    Prevent specific task pairs from being scheduled on the same date. This ensures critical deliverables have proper spacing.
                </p>

                <!-- Existing Constraints List -->
                <div id="constraintsList" style="margin-bottom: 32px;">
                    <!-- Dynamically populated -->
                </div>

                <!-- Add New Constraint -->
                <div style="border-top: 1px solid var(--border-light); padding-top: 24px;">
                    <h4 style="margin: 0 0 16px 0; font-size: 16px; color: var(--text-dark);">Add New Rule</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        <div>
                            <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-dark); margin-bottom: 8px;">Task 1</label>
                            <select id="constraintTask1" style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <option value="">Select task...</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-dark); margin-bottom: 8px;">Task 2</label>
                            <select id="constraintTask2" style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <option value="">Select task...</option>
                            </select>
                        </div>
                    </div>
                    <button class="primary" onclick="addConstraint()" style="width: 100%;">Add Rule</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="secondary" onclick="closeConstraintsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Off-Cycle Wizard Modal (v4.0) -->
    <div id="offCycleWizard" class="modal-overlay" style="display: none;">
        <div class="modal wizard-modal">
            <h3 style="margin-bottom: 24px;">Add Off-Cycle Payroll(s)</h3>

            <!-- Progress Indicator -->
            <div class="wizard-progress">
                <div class="wizard-step active" data-step="1">
                    <div class="wizard-step-number">1</div>
                    <div class="wizard-step-label">Quantity</div>
                </div>
                <div class="wizard-step" data-step="2">
                    <div class="wizard-step-number">2</div>
                    <div class="wizard-step-label">Placement</div>
                </div>
                <div class="wizard-step" data-step="3">
                    <div class="wizard-step-number">3</div>
                    <div class="wizard-step-label">Pay Dates</div>
                </div>
                <div class="wizard-step" data-step="4">
                    <div class="wizard-step-number">4</div>
                    <div class="wizard-step-label">Tasks</div>
                </div>
                <div class="wizard-step" data-step="5">
                    <div class="wizard-step-number">5</div>
                    <div class="wizard-step-label">Offsets</div>
                </div>
                <div class="wizard-step" data-step="6">
                    <div class="wizard-step-number">6</div>
                    <div class="wizard-step-label">Rules</div>
                </div>
            </div>

            <!-- Wizard Content -->
            <div class="wizard-content">

                <!-- Step 1: Quantity Selection -->
                <div id="wizardStep1" class="wizard-panel active">
                    <h4 style="margin-bottom: 16px; color: var(--text-dark);">How many off-cycles are you adding?</h4>

                    <div class="option-card" onclick="selectOffCycleQuantity('single')" id="quantitySingle">
                        <h4>A Single Off-Cycle</h4>
                        <p>Add one off-cycle payroll period before or after a specific pay period</p>
                    </div>

                    <div class="option-card" onclick="selectOffCycleQuantity('multiple')" id="quantityMultiple">
                        <h4>Multiple Off-Cycles</h4>
                        <p>Add off-cycle payroll periods before or after multiple pay periods</p>
                    </div>

                    <div class="form-group" style="margin-top: 24px;">
                        <label>Off-Cycle Name (Optional)</label>
                        <input type="text"
                               id="offCycleName"
                               placeholder="e.g., Christmas Bonus, Mid-Month Bonus"
                               onchange="wizardState.offCycleName = this.value"
                               style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                        <span class="help-text">Give this off-cycle a custom name. If left blank, it will use the default naming (e.g., "January 2025 Post-Off-Cycle")</span>
                    </div>
                </div>

                <!-- Step 2: Period Placement -->
                <div id="wizardStep2" class="wizard-panel">
                    <h4 style="margin-bottom: 16px; color: var(--text-dark);">Where should the off-cycle(s) be placed?</h4>

                    <!-- Single Off-Cycle Placement -->
                    <div id="singlePlacement" style="display: none;">
                        <div class="form-group">
                            <label>Position</label>
                            <select id="singlePosition" style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <option value="before">Before</option>
                                <option value="after">After</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-top: 16px;">
                            <label>Pay Period</label>
                            <select id="singlePeriodSelect" style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <!-- Populated dynamically -->
                            </select>
                        </div>
                    </div>

                    <!-- Multiple Off-Cycles Placement -->
                    <div id="multiplePlacement" style="display: none;">
                        <div class="form-group">
                            <label>Position</label>
                            <select id="multiplePosition" style="width: 100%; padding: 10px; border: 1.5px solid var(--border-light); border-radius: 6px; font-size: 14px;">
                                <option value="before">Before</option>
                                <option value="after">After</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-top: 16px;">
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <input type="checkbox" id="allPeriodsCheckbox" onchange="toggleAllPeriods()">
                                <span>All Pay Periods</span>
                            </label>
                        </div>
                        <div id="periodSelectorContainer">
                            <label>Select Pay Periods</label>
                            <div class="period-selector" id="multiplePeriodSelect">
                                <!-- Populated dynamically with checkboxes -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 3: Pay Date Configuration -->
                <div id="wizardStep3" class="wizard-panel">
                    <h4 style="margin-bottom: 16px; color: var(--text-dark);">Configure off-cycle pay dates</h4>

                    <p style="font-size: 13px; color: var(--text-medium); margin-bottom: 20px;">Select the specific pay date(s) for your off-cycle period(s):</p>

                    <!-- v4.0: Simplified - Manual Date Entry Only -->
                    <div style="border: 2px solid var(--primary-purple); border-radius: 8px; padding: 20px; background: #F5F3FF;">
                        <div id="manualPayDateConfig">
                            <div id="manualPayDateList">
                                <!-- Populated dynamically based on selected periods -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 4: Task Selection -->
                <div id="wizardStep4" class="wizard-panel">
                    <h4 style="margin-bottom: 16px; color: var(--text-dark);">Create off-cycle task list</h4>
                    <p style="font-size: 13px; color: var(--text-medium); margin-bottom: 20px;">Select the tasks to include in your off-cycle periods:</p>

                    <!-- v4.0: Simplified - Custom Task Selection Only -->
                    <div id="customTaskSelector" style="margin-top: 20px;">
                        <label style="font-weight: 500; margin-bottom: 12px; display: block;">Select Tasks</label>
                        <div class="period-selector" id="taskCheckboxList">
                            <!-- Populated dynamically with task checkboxes -->
                        </div>
                    </div>
                </div>

                <!-- Step 5: Task Due Dates -->
                <div id="wizardStep5" class="wizard-panel">
                    <h4 style="margin-bottom: 16px; color: var(--text-dark);">Task Due Dates</h4>

                    <p style="color: var(--text-medium); margin-bottom: 20px; font-size: 13px;">
                        Select specific dates for each task in your off-cycle periods.
                    </p>

                    <!-- v4.0: Single scrollable container with checkbox inside -->
                    <div id="customOffsetEditor" style="max-height: 500px; overflow-y: auto; border: 1px solid var(--border-light); border-radius: 8px; padding: 16px; background: white;">

                        <!-- Multiple off-cycles: option to apply to all or customize each -->
                        <div id="multipleOffCycleOption" style="display: none; background: #F0F9FF; border: 1.5px solid #0EA5E9; border-radius: 8px; padding: 12px 16px; margin-bottom: 16px;">
                            <label style="display: flex; align-items: start; gap: 12px; cursor: pointer;">
                                <input type="checkbox" id="applyToAllOffCycles" checked onchange="toggleApplyToAll()" style="margin-top: 2px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; font-size: 14px; color: var(--text-dark); margin-bottom: 4px;">
                                        Apply same dates/offsets to all off-cycles
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-medium); line-height: 1.4;">
                                        When checked, the dates you select below will be applied to all <span id="offCycleCountDisplay"></span> off-cycle periods you're adding. Uncheck to customize dates for each off-cycle individually.
                                    </div>
                                </div>
                            </label>
                        </div>

                        <div id="offsetInputList">
                            <!-- Populated dynamically with date pickers -->
                        </div>
                    </div>
                </div>

                <!-- Step 6: Advanced Rules (Optional) -->
                <div id="wizardStep6" class="wizard-panel">
                    <h4 style="margin-bottom: 16px; color: var(--text-dark);">Advanced task rules (optional)</h4>
                    <p style="color: var(--text-medium); margin-bottom: 20px; font-size: 14px;">
                        Add constraint rules specific to off-cycle periods. These rules will only apply to the off-cycles you're creating.
                    </p>

                    <div id="offCycleConstraintsList" style="margin-bottom: 20px;">
                        <!-- Populated dynamically with constraints -->
                    </div>

                    <button class="secondary" onclick="addOffCycleConstraint()" style="width: 100%;">+ Add Constraint Rule</button>
                </div>

            </div>

            <!-- Navigation Buttons -->
            <div class="wizard-buttons">
                <button class="secondary" onclick="closeOffCycleWizard()">Cancel</button>
                <div style="display: flex; gap: 12px;">
                    <button class="secondary" id="wizardBackBtn" onclick="wizardPrevStep()" style="display: none;">â† Back</button>
                    <button class="primary" id="wizardNextBtn" onclick="wizardNextStep()">Next â†’</button>
                    <button class="primary" id="wizardFinishBtn" onclick="finishOffCycleWizard()" style="display: none;">Add to Calendar</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
