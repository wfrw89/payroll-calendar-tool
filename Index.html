<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payroll Calendar Generator</title>

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-purple: #6B69D6;
            --primary-purple-light: #8B89E5;
            --success-teal: #0FA47F;
            --success-teal-light: #14B98F;
            --warning-yellow: #F59E0B;
            --warning-orange: #F97316;
            --danger-red: #eb5757;
            --text-dark: #37352f;
            --text-medium: #787774;
            --text-light: #9B9A97;
            --bg-main: #fafafa;
            --bg-card: #ffffff;
            --border-light: #e5e5e4;
            --border-medium: #d3d3d1;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-main);
            min-height: 100vh;
            padding: 48px 24px;
            color: var(--text-dark);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            animation: fadeIn 0.5s ease;
        }

        .header {
            text-align: center;
            margin-bottom: 56px;
        }

        .header h1 {
            font-size: 44px;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 12px;
            letter-spacing: -0.04em;
            background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-medium);
            font-size: 17px;
            font-weight: 400;
        }

        .card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 36px;
            margin-bottom: 28px;
            border: 1px solid var(--border-light);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: fadeIn 0.6s ease;
        }

        .card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .card-header {
            font-size: 19px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 28px;
            padding-bottom: 18px;
            border-bottom: 2px solid #f1f1f0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .card-header::before {
            content: '';
            width: 5px;
            height: 24px;
            background: linear-gradient(180deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            border-radius: 3px;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 28px;
            margin-bottom: 24px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-dark);
        }

        .form-group input,
        .form-group select {
            padding: 12px 16px;
            border: 1.5px solid var(--border-light);
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            background: var(--bg-card);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--text-dark);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary-purple);
            box-shadow: 0 0 0 4px rgba(107, 105, 214, 0.1);
            transform: translateY(-1px);
        }

        .form-group input:hover:not(:focus),
        .form-group select:hover:not(:focus) {
            border-color: var(--border-medium);
        }

        .help-text {
            font-size: 13px;
            color: var(--text-medium);
            margin-top: 4px;
        }

        .button-group {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            margin-top: 28px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 0.01em;
        }

        button:active {
            transform: scale(0.98);
        }

        button.primary {
            background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(107, 105, 214, 0.25);
        }

        button.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(107, 105, 214, 0.35);
        }

        button.secondary {
            background: #f1f1f0;
            color: var(--text-dark);
        }

        button.secondary:hover {
            background: #e5e5e4;
            transform: translateY(-1px);
        }

        button.success {
            background: linear-gradient(135deg, var(--success-teal) 0%, var(--success-teal-light) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(15, 164, 127, 0.25);
        }

        button.success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(15, 164, 127, 0.35);
        }

        button.danger {
            background: var(--danger-red);
            color: white;
        }

        button.danger:hover {
            background: #d13636;
            transform: translateY(-1px);
        }

        button.small {
            padding: 7px 16px;
            font-size: 13px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .task-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 24px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .task-table th {
            text-align: left;
            font-size: 12px;
            font-weight: 700;
            color: var(--text-medium);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            padding: 16px 18px;
            background: #fafafa;
            border-bottom: 2px solid var(--border-light);
        }

        .task-table td {
            padding: 18px;
            border-bottom: 1px solid #f7f7f7;
            font-size: 15px;
            vertical-align: middle;
            background: white;
        }

        .task-table tr:last-child td {
            border-bottom: none;
        }

        .task-table tr:hover td {
            background: #fafafa;
        }

        .task-row.core td {
            background: #f0f9f7;
        }

        .task-row.core:hover td {
            background: #e6f4f0;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--success-teal) 0%, var(--success-teal-light) 100%);
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 4px rgba(15, 164, 127, 0.2);
        }

        .task-name-cell {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
        }

        .task-offset-input {
            width: 90px;
            padding: 8px 12px;
            border: 1.5px solid var(--border-light);
            border-radius: 6px;
            font-size: 15px;
            text-align: center;
            font-family: inherit;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .task-offset-input:focus {
            outline: none;
            border-color: var(--primary-purple);
            box-shadow: 0 0 0 3px rgba(107, 105, 214, 0.1);
        }

        .add-task-row {
            display: flex;
            gap: 14px;
            margin-top: 24px;
            align-items: stretch;
        }

        .add-task-row input {
            padding: 12px 16px;
            border: 1.5px solid var(--border-light);
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .add-task-row input:focus {
            outline: none;
            border-color: var(--primary-purple);
            box-shadow: 0 0 0 4px rgba(107, 105, 214, 0.1);
        }

        .add-task-row input:first-child {
            flex: 1;
        }

        .add-task-row input[type="number"] {
            width: 140px;
            text-align: center;
            font-weight: 600;
        }

        .calendar-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 24px;
            font-size: 14px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            table-layout: fixed;
        }

        .calendar-table th {
            background: linear-gradient(135deg, #2d2c2f 0%, #37352f 100%);
            color: white;
            padding: 18px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .calendar-table th:last-child {
            border-right: none;
        }

        .calendar-table th:not(:first-child) {
            text-align: center;
        }

        .calendar-table th:first-child,
        .calendar-table td:first-child {
            width: 150px;
        }

        .calendar-table th:last-child,
        .calendar-table td:last-child {
            width: 300px;
        }

        /* Task columns (not first or last) - ensure enough width for month abbreviations */
        .calendar-table th:not(:first-child):not(:last-child),
        .calendar-table td:not(:first-child):not(:last-child) {
            min-width: 130px; /* Increased to prevent "Sept" wrapping on any display */
        }

        .calendar-table td {
            padding: 18px 16px;
            border-bottom: 1px solid #f1f1f0;
            border-right: 1px solid #f7f7f7;
            text-align: center;
            vertical-align: top;
            background: white;
        }

        .calendar-table td:first-child {
            text-align: left;
            font-weight: 600;
            background: #fafafa;
        }

        .calendar-table td:last-child {
            text-align: left;
            background: #fffef5;
            font-size: 13px;
            line-height: 1.7;
        }

        .calendar-table tr:hover td {
            background: #f7f8f9;
        }

        .calendar-table tr:hover td:first-child {
            background: #f0f0f0;
        }

        .calendar-table tr:hover td:last-child {
            background: #fff9e6;
        }

        .calendar-table tr:last-child td {
            border-bottom: none;
        }

        .period-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .holiday-indicator {
            width: 10px;
            height: 10px;
            background: var(--warning-yellow);
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
            animation: pulse 2s ease-in-out infinite;
            flex-shrink: 0;
        }

        .adjustment-indicator {
            width: 10px;
            height: 10px;
            background: var(--warning-orange);
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
            animation: pulse 2s ease-in-out infinite;
            flex-shrink: 0;
            margin-left: 4px;
        }

        .override-indicator {
            font-size: 14px;
            margin-right: 6px;
            display: inline-block;
        }

        .date-display {
            font-weight: 600;
            display: block;
            color: var(--text-dark);
            font-size: 15px;
        }

        .day-display {
            font-size: 12px;
            color: var(--text-medium);
            display: block;
            margin-top: 4px;
            font-weight: 500;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 24px;
        }

        .config-card {
            background: linear-gradient(135deg, #fafafa 0%, #f7f7f7 100%);
            border: 1.5px solid var(--border-light);
            border-radius: 10px;
            padding: 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .config-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary-purple) 0%, var(--primary-purple-light) 100%);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .config-card:hover {
            background: white;
            border-color: var(--primary-purple);
            box-shadow: var(--shadow-lg);
            transform: translateY(-4px);
        }

        .config-card:hover::before {
            transform: scaleX(1);
        }

        .config-card h3 {
            font-size: 17px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 14px;
        }

        .config-card p {
            font-size: 13px;
            color: var(--text-medium);
            margin-bottom: 6px;
        }

        .config-actions {
            display: flex;
            gap: 10px;
            margin-top: 18px;
        }

        .message {
            padding: 16px 20px;
            border-radius: 8px;
            margin-top: 24px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: fadeIn 0.3s ease;
            font-weight: 500;
        }

        .message::before {
            content: '';
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .message.success {
            background: linear-gradient(135deg, #d3f9d8 0%, #c1f5c8 100%);
            color: #0f5132;
            border: 1.5px solid #a3cfbb;
        }

        .message.success::before {
            content: 'âœ“';
            background: var(--success-teal);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .message.error {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c2c7 100%);
            color: #721c24;
            border: 1.5px solid #f1aeb5;
        }

        .message.error::before {
            content: '!';
            background: var(--danger-red);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        .message.loading {
            background: linear-gradient(135deg, #e7f3ff 0%, #d4e9ff 100%);
            color: #052c65;
            border: 1.5px solid #9ec5fe;
        }

        .message.loading::before {
            content: '';
            border: 2px solid var(--primary-purple);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .hidden {
            display: none;
        }

        #payDateConfig {
            margin-top: 20px;
            padding: 24px;
            background: linear-gradient(135deg, #fafafa 0%, #f7f7f7 100%);
            border-radius: 10px;
            border: 1.5px solid var(--border-light);
        }

        .cutoff-mode-selector {
            margin-top: 20px;
            padding: 24px;
            background: linear-gradient(135deg, #f8f3ff 0%, #f5f0ff 100%);
            border-radius: 10px;
            border: 1.5px solid #e5d9ff;
            box-shadow: var(--shadow-sm);
        }

        .cutoff-mode-selector label {
            display: block;
            margin-bottom: 16px;
            font-weight: 600;
            color: var(--text-dark);
            font-size: 15px;
        }

        .radio-group {
            display: flex;
            gap: 28px;
            margin-bottom: 20px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .radio-option:hover {
            transform: translateX(2px);
        }

        .radio-option input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--primary-purple);
        }

        .radio-option label {
            cursor: pointer;
            margin: 0;
            font-weight: 500;
            font-size: 14px;
        }

        .cutoff-config {
            margin-top: 20px;
        }

        .legend {
            display: flex;
            gap: 24px;
            margin-top: 20px;
            padding: 16px;
            background: #fafafa;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: var(--text-medium);
        }

        @media (max-width: 768px) {
            body {
                padding: 24px 16px;
            }

            .header h1 {
                font-size: 32px;
            }

            .card {
                padding: 24px;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .add-task-row {
                flex-direction: column;
            }

            .add-task-row input[type="number"] {
                width: 100%;
            }

            .calendar-table {
                font-size: 12px;
            }

            .calendar-table th,
            .calendar-table td {
                padding: 12px 10px;
            }

            .button-group {
                flex-direction: column;
            }

            .button-group button {
                width: 100%;
                justify-content: center;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Calendar Day Picker Styles */
        .day-picker {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
            margin-top: 12px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--border-medium);
            max-width: 280px;
            box-shadow: var(--shadow-sm);
        }

        .day-picker-button {
            padding: 8px 6px;
            background: white;
            border: 1px solid var(--border-light);
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-dark);
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-picker-button:hover {
            background: var(--primary-purple-light);
            color: white;
            border-color: var(--primary-purple);
        }

        .day-picker-button.selected {
            background: var(--primary-purple);
            color: white;
            border-color: var(--primary-purple);
            font-weight: 600;
            box-shadow: 0 0 0 2px rgba(107, 105, 214, 0.2);
        }

        .day-picker-button.last-day {
            grid-column: span 7;
            background: var(--success-teal);
            color: white;
            border-color: var(--success-teal);
            font-weight: 600;
            padding: 10px;
            font-size: 12px;
        }

        .day-picker-button.last-day:hover {
            background: var(--success-teal-light);
            border-color: var(--success-teal-light);
        }

        .day-picker-button.last-day.selected {
            background: var(--success-teal);
            box-shadow: 0 0 0 2px rgba(15, 164, 127, 0.2);
        }

        .day-picker-label {
            font-size: 13px;
            color: var(--text-medium);
            margin-bottom: 6px;
            font-weight: 500;
        }

        /* Icon Button Styles */
        .icon-button {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-medium);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .icon-button:hover {
            background: var(--primary-purple-light);
            color: white;
        }

        /* Clock Icon Button Styles */
        .clock-icon-button {
            background: none;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: #D3D3D1;  /* Faint grey by default */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .clock-icon-button:hover {
            color: var(--text-medium);
            background: rgba(0, 0, 0, 0.05);
        }

        .clock-icon-button.has-time {
            color: #000000;  /* Black when time is set */
        }

        .clock-icon-button.has-time:hover {
            color: var(--primary-purple);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 32px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lg);
            animation: fadeIn 0.3s ease;
        }

        .modal h3 {
            margin-bottom: 20px;
            color: var(--text-dark);
            font-size: 22px;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Payroll Calendar Generator</h1>
            <p>Create accurate payroll calendars with bank holidays and working day calculations</p>
        </div>

        <!-- Saved Configurations -->
        <div class="card">
            <div class="card-header">Saved Configurations</div>
            <div id="savedConfigs" class="config-grid">
                <p style="color: var(--text-medium);">No saved configurations yet. Create one below!</p>
            </div>
        </div>

        <!-- Client Information -->
        <div class="card">
            <div class="card-header">Client Information</div>
            <div class="form-row">
                <div class="form-group">
                    <label for="clientName">Client Name</label>
                    <input type="text" id="clientName" placeholder="Enter client name">
                </div>
                <div class="form-group">
                    <label for="employeeCountry">Employee Country</label>
                    <select id="employeeCountry">
                        <option value="">Select country...</option>
                    </select>
                    <span class="help-text">Country where employees are being paid</span>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="providerCountry">Payroll Provider Country <span style="color: var(--text-light); font-weight: 400; font-size: 13px;">(Optional)</span></label>
                    <select id="providerCountry">
                        <option value="">Select country...</option>
                    </select>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 12px;">
                        <input type="checkbox" id="providerCountryImpact" checked>
                        <label for="providerCountryImpact" style="font-size: 14px; font-weight: 400; cursor: pointer; margin: 0;">Bank holidays in this country impact task dates</label>
                    </div>
                    <span class="help-text">Your payroll team's location</span>
                </div>
                <div class="form-group">
                    <label for="clientTeamCountry">Client Payroll Team Country <span style="color: var(--text-light); font-weight: 400; font-size: 13px;">(Optional)</span></label>
                    <select id="clientTeamCountry">
                        <option value="">Select country...</option>
                    </select>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 12px;">
                        <input type="checkbox" id="clientTeamCountryImpact" checked>
                        <label for="clientTeamCountryImpact" style="font-size: 14px; font-weight: 400; cursor: pointer; margin: 0;">Bank holidays in this country impact task dates</label>
                    </div>
                    <span class="help-text">Client team's location</span>
                </div>
            </div>
        </div>

        <!-- Pay Frequency Configuration -->
        <div class="card">
            <div class="card-header">Pay Frequency Configuration</div>
            <div class="form-row">
                <div class="form-group">
                    <label for="payFrequency">Pay Frequency</label>
                    <select id="payFrequency" onchange="updatePayDateConfig()">
                        <option value="">Select frequency...</option>
                        <option value="monthly">Monthly</option>
                        <option value="semi-monthly">Semi-Monthly (twice per month)</option>
                        <option value="bi-weekly">Bi-Weekly (every 2 weeks)</option>
                        <option value="weekly">Weekly</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="calendarYear">Calendar Year</label>
                    <input type="number" id="calendarYear" min="2024" max="2030" value="2025">
                </div>
            </div>

            <div id="payDateConfig" class="hidden"></div>

            <div id="cutoffConfig" class="cutoff-mode-selector hidden">
                <label>Payroll Cut-Off Configuration</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="cutoffByDate" name="cutoffMode" value="date" onchange="updateCutoffMode()">
                        <label for="cutoffByDate">Specific Date</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="cutoffByOffset" name="cutoffMode" value="offset" checked onchange="updateCutoffMode()">
                        <label for="cutoffByOffset">Working Days Before Pay Date</label>
                    </div>
                </div>
                <div id="cutoffModeConfig" class="cutoff-config"></div>
            </div>
        </div>

        <!-- Payroll Tasks -->
        <div class="card">
            <div class="card-header">Payroll Tasks</div>
            <p class="help-text" style="margin-bottom: 24px;">
                Configure your payroll timeline. Set the cut-off date, then each subsequent task is calculated as working days after the previous milestone. If tasks overrun the pay date, the system will automatically adjust intermediate milestones.
            </p>

            <div class="form-group" style="margin-bottom: 24px; max-width: 400px;">
                <label for="calendarTimezone">Timezone for Due Times (Optional)</label>
                <select id="calendarTimezone">
                    <option value="">No timezone (times only)</option>
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Eastern Time (ET)</option>
                    <option value="America/Chicago">Central Time (CT)</option>
                    <option value="America/Denver">Mountain Time (MT)</option>
                    <option value="America/Los_Angeles">Pacific Time (PT)</option>
                    <option value="Europe/London">London (GMT/BST)</option>
                    <option value="Europe/Paris">Central European Time (CET)</option>
                    <option value="Europe/Berlin">Berlin (CET)</option>
                    <option value="Asia/Dubai">Dubai (GST)</option>
                    <option value="Asia/Singapore">Singapore (SGT)</option>
                    <option value="Asia/Hong_Kong">Hong Kong (HKT)</option>
                    <option value="Asia/Tokyo">Tokyo (JST)</option>
                    <option value="Australia/Sydney">Sydney (AEDT/AEST)</option>
                </select>
                <span class="help-text">Select timezone for task due times. Click the clock icon next to each task to set a specific due time.</span>
            </div>

            <table class="task-table">
                <thead>
                    <tr>
                        <th>Task Name</th>
                        <th style="text-align: center; width: 100px;">Mandatory</th>
                        <th style="text-align: center;">Working Days</th>
                        <th>Description</th>
                        <th style="width: 150px; text-align: center;">Actions</th>
                    </tr>
                </thead>
                <tbody id="taskList"></tbody>
            </table>

            <div class="add-task-row">
                <input type="text" id="newTaskName" placeholder="Enter task name (e.g., Final Approval)">
                <input type="number" id="newTaskOffset" placeholder="Days" value="1" min="0">
                <button class="primary" onclick="addTask()">+ Add Task</button>
            </div>
        </div>

        <!-- Actions -->
        <div class="card">
            <div class="card-header">Actions</div>
            <div class="button-group">
                <button class="success" onclick="generateCalendar()">âœ“ Generate Calendar</button>
                <button class="primary" onclick="saveConfiguration()">ðŸ’¾ Save Configuration</button>
                <button class="secondary" onclick="exportToXLSX()">ðŸ“Š Export to Excel</button>
                <button class="secondary" onclick="exportToPDF()">ðŸ“„ Export to PDF</button>
                <button class="secondary" onclick="resetForm()">âŸ² Reset Form</button>
            </div>
            <div id="message"></div>
        </div>

        <!-- Calendar Preview -->
        <div class="card hidden" id="calendarSection">
            <div class="card-header">Calendar Preview</div>

            <div class="legend">
                <div class="legend-item">
                    <span class="holiday-indicator"></span>
                    <span>Bank holiday affected this period</span>
                </div>
                <div class="legend-item">
                    <span class="adjustment-indicator"></span>
                    <span>Timeline auto-adjusted to fit within period</span>
                </div>
            </div>

            <div id="calendarPreview"></div>
        </div>
    </div>

    <script>
        const countries = [
            { code: 'US', name: 'United States' },
            { code: 'GB', name: 'United Kingdom' },
            { code: 'CA', name: 'Canada' },
            { code: 'AU', name: 'Australia' },
            { code: 'DE', name: 'Germany' },
            { code: 'FR', name: 'France' },
            { code: 'ES', name: 'Spain' },
            { code: 'IT', name: 'Italy' },
            { code: 'NL', name: 'Netherlands' },
            { code: 'BE', name: 'Belgium' },
            { code: 'IE', name: 'Ireland' },
            { code: 'SE', name: 'Sweden' },
            { code: 'NO', name: 'Norway' },
            { code: 'DK', name: 'Denmark' },
            { code: 'FI', name: 'Finland' },
            { code: 'PL', name: 'Poland' },
            { code: 'AT', name: 'Austria' },
            { code: 'CH', name: 'Switzerland' },
            { code: 'NZ', name: 'New Zealand' },
            { code: 'SG', name: 'Singapore' },
            { code: 'HK', name: 'Hong Kong' },
            { code: 'IN', name: 'India' },
            { code: 'JP', name: 'Japan' },
            { code: 'CN', name: 'China' },
            { code: 'BR', name: 'Brazil' },
            { code: 'MX', name: 'Mexico' },
            { code: 'ZA', name: 'South Africa' },
            { code: 'IL', name: 'Israel' },
            { code: 'AE', name: 'United Arab Emirates' },
            { code: 'SA', name: 'Saudi Arabia' },
            { code: 'BH', name: 'Bahrain' },
            { code: 'KW', name: 'Kuwait' },
            { code: 'QA', name: 'Qatar' },
            { code: 'OM', name: 'Oman' }
        ];

        // Weekend patterns by country (day numbers: 0=Sunday, 1=Monday, ..., 6=Saturday)
        const countryWeekends = {
            // Friday-Saturday weekends (Middle East)
            'IL': [5, 6],    // Israel: Friday, Saturday
            'AE': [5, 6],    // UAE: Friday, Saturday
            'SA': [5, 6],    // Saudi Arabia: Friday, Saturday
            'BH': [5, 6],    // Bahrain: Friday, Saturday
            'KW': [5, 6],    // Kuwait: Friday, Saturday
            'QA': [5, 6],    // Qatar: Friday, Saturday
            'OM': [5, 6],    // Oman: Friday, Saturday
            // Default: Saturday-Sunday weekends (most countries)
            'default': [0, 6]  // Sunday, Saturday
        };

        // Get weekend days for a specific country
        function getCountryWeekendDays(countryCode) {
            return countryWeekends[countryCode] || countryWeekends['default'];
        }

        const defaultTasks = [
            // Core tasks (cannot be deleted)
            { name: 'Payroll Cut Off', offset: 10, fromPrevious: false, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, description: 'Working days before Pay Date', dueTime: '' },
            // Default system tasks (can be deleted)
            { name: 'Send changes to ICP', offset: 2, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: false, beforePayDate: false, description: 'Working days after Cut Off', dueTime: '' },
            { name: 'Reports back from ICP', offset: 2, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: false, beforePayDate: false, description: 'Working days after Send changes to ICP', dueTime: '' },
            // Core tasks
            { name: 'Payroll Reports Due', offset: 3, fromPrevious: true, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, description: 'Working days after Reports back from ICP', dueTime: '' },
            // Default system tasks
            { name: 'Feedback from Client', offset: 2, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: false, beforePayDate: false, description: 'Working days after Reports Due', dueTime: '' },
            // Core tasks
            { name: 'Payroll Sign-Off Due', offset: 3, fromPrevious: true, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, description: 'Working days after Feedback from Client', dueTime: '' },
            { name: 'Final Reports Due', offset: 2, fromPrevious: true, core: true, deletable: false, canBeBeforePayDate: true, beforePayDate: false, description: 'Working days after Sign-Off', dueTime: '' },
            // Default system tasks
            { name: 'Net Pay Sent', offset: 1, fromPrevious: true, core: false, deletable: true, canBeBeforePayDate: true, beforePayDate: false, description: 'Working days after Final Reports', dueTime: '' },
            // Core tasks
            { name: 'Pay Date', offset: 0, fromPrevious: false, core: true, deletable: false, canBeBeforePayDate: false, beforePayDate: false, description: 'Pay date from Pay Date Configuration', dueTime: '' }
        ];
        // NOTE: Pay Date is ALWAYS the original pay date from the Pay Date Configuration section
        // It only moves if it falls on a weekend or bank holiday - NEVER based on task offsets

        let tasks = JSON.parse(JSON.stringify(defaultTasks));
        let bankHolidays = {};
        let generatedCalendar = [];
        let cutoffMode = 'offset';
        let cutoffConfig = { mode: 'offset', offset: 10 };
        let ignoredHolidays = []; // Array of holiday keys (country_date format) to ignore
        let payDateOverrides = {}; // Object mapping period index to override date
        let cutoffOverrides = {}; // Object mapping period index to override cutoff date
        let manualHolidays = {}; // Object mapping period index to { date: Date, name: string }
        let originalCutoffDates = []; // Store original cutoff dates to prevent recalculation when manual holidays are added

        function init() {
            populateCountryDropdowns();
            renderTasks();

            // Check if running from file:// protocol and warn user
            if (window.location.protocol === 'file:') {
                console.warn('âš ï¸ Running from file:// protocol - some browsers may block bank holiday API requests due to CORS restrictions');
                console.warn('ðŸ’¡ If bank holidays don\'t load, try one of these solutions:');
                console.warn('   1. Use Chrome or Firefox (most compatible)');
                console.warn('   2. Host the file on a web server');
                console.warn('   3. Manually add holidays using the "Add Manual Bank Holiday" feature');
            }
            loadSavedConfigurations();
        }

        function populateCountryDropdowns() {
            const selects = ['employeeCountry', 'providerCountry', 'clientTeamCountry'];
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                countries.forEach(country => {
                    const option = document.createElement('option');
                    option.value = country.code;
                    option.textContent = country.name;
                    select.appendChild(option);
                });
            });
        }

        function updatePayDateConfig() {
            const frequency = document.getElementById('payFrequency').value;
            const payConfig = document.getElementById('payDateConfig');
            const cutoffConfigDiv = document.getElementById('cutoffConfig');

            if (!frequency) {
                payConfig.classList.add('hidden');
                cutoffConfigDiv.classList.add('hidden');
                return;
            }

            payConfig.classList.remove('hidden');
            cutoffConfigDiv.classList.remove('hidden');

            let html = '';

            if (frequency === 'monthly') {
                html = `
                    <div class="form-group">
                        <label for="payDayOfMonth">Pay Day of Month</label>
                        <p class="day-picker-label">Select the day of the month for pay dates:</p>
                        ${generateDayPicker('payDayOfMonth', true)}
                        <span class="help-text">Adjusts to prior working day if weekend/holiday</span>
                    </div>
                `;
            } else if (frequency === 'semi-monthly') {
                html = `
                    <div class="form-row">
                        <div class="form-group">
                            <label for="firstPayDay">First Pay Date</label>
                            <p class="day-picker-label">Select the first pay day of the month:</p>
                            ${generateDayPicker('firstPayDay', false)}
                        </div>
                        <div class="form-group">
                            <label for="secondPayDay">Second Pay Date</label>
                            <p class="day-picker-label">Select the second pay day of the month:</p>
                            ${generateDayPicker('secondPayDay', true)}
                        </div>
                    </div>
                    <span class="help-text">Both dates adjust to prior working day if weekend/holiday</span>
                `;
            } else if (frequency === 'bi-weekly' || frequency === 'weekly') {
                const periodText = frequency === 'bi-weekly' ? 'every 2 weeks' : 'every week';
                html = `
                    <div class="form-row">
                        <div class="form-group">
                            <label for="payDayOfWeek">Pay Day of Week</label>
                            <select id="payDayOfWeek">
                                <option value="">Select day...</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                            </select>
                            <span class="help-text">Paid on this day ${periodText}</span>
                        </div>
                        <div class="form-group">
                            <label for="firstPayDate">First Pay Date of Year</label>
                            <input type="date" id="firstPayDate">
                            <span class="help-text">Starting reference date</span>
                        </div>
                    </div>
                `;
            }

            payConfig.innerHTML = html;
            updateCutoffMode();
        }

        function updateCutoffMode() {
            const frequency = document.getElementById('payFrequency').value;
            if (!frequency) return;

            cutoffMode = document.querySelector('input[name="cutoffMode"]:checked')?.value || 'offset';
            const container = document.getElementById('cutoffModeConfig');

            if (cutoffMode === 'date') {
                if (frequency === 'monthly') {
                    container.innerHTML = `
                        <div class="form-group">
                            <label for="cutoffDayOfMonth">Cut-Off Day of Month</label>
                            <p class="day-picker-label">Select the cut-off day of the month:</p>
                            ${generateDayPicker('cutoffDayOfMonth', false)}
                            <span class="help-text">Adjusts to prior working day if weekend/holiday</span>
                        </div>
                    `;
                } else if (frequency === 'semi-monthly') {
                    container.innerHTML = `
                        <div class="form-row">
                            <div class="form-group">
                                <label for="cutoffFirstDay">First Cut-Off Day</label>
                                <p class="day-picker-label">Select the first cut-off day:</p>
                                ${generateDayPicker('cutoffFirstDay', false)}
                            </div>
                            <div class="form-group">
                                <label for="cutoffSecondDay">Second Cut-Off Day</label>
                                <p class="day-picker-label">Select the second cut-off day:</p>
                                ${generateDayPicker('cutoffSecondDay', false)}
                            </div>
                        </div>
                        <span class="help-text">Both dates adjust to prior working day if weekend/holiday</span>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="form-group">
                            <label for="cutoffDayOfWeek">Cut-Off Day of Week</label>
                            <select id="cutoffDayOfWeek">
                                <option value="">Select day...</option>
                                <option value="1">Monday</option>
                                <option value="2">Tuesday</option>
                                <option value="3">Wednesday</option>
                                <option value="4">Thursday</option>
                                <option value="5">Friday</option>
                            </select>
                            <span class="help-text">Cut-off happens on this day each period</span>
                        </div>
                    `;
                }
            } else {
                container.innerHTML = `
                    <div class="form-group">
                        <label for="cutoffDaysOffset">Working Days Before Pay Date</label>
                        <input type="number" id="cutoffDaysOffset" value="10" min="1" placeholder="e.g., 10">
                        <span class="help-text">Number of working days before the pay date</span>
                    </div>
                `;
            }
        }

        function getOrdinal(n) {
            const s = ['th', 'st', 'nd', 'rd'];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        // Format date as "Thu, 27th Nov"
        function formatDateWithOrdinal(date) {
            const dayName = date.toLocaleDateString('en-GB', { weekday: 'short' });
            const day = date.getDate();
            const month = date.toLocaleDateString('en-GB', { month: 'short' });
            const dayWithOrdinal = getOrdinal(day);
            return `${dayName}, ${dayWithOrdinal} ${month}`;
        }

        // Generate calendar day picker HTML
        function generateDayPicker(pickerId, includeLastDay = false, selectedValue = null) {
            let html = '<div class="day-picker">';

            // Generate day buttons (1-31)
            for (let day = 1; day <= 31; day++) {
                const isSelected = selectedValue == day ? 'selected' : '';
                html += `<button type="button" class="day-picker-button ${isSelected}"
                         onclick="selectDay('${pickerId}', ${day})">${day}</button>`;
            }

            // Add "Last working day" button if requested
            if (includeLastDay) {
                const isSelected = selectedValue === 'last' ? 'selected' : '';
                html += `<button type="button" class="day-picker-button last-day ${isSelected}"
                         onclick="selectDay('${pickerId}', 'last')">Last working day of month</button>`;
            }

            html += '</div>';
            html += `<input type="hidden" id="${pickerId}" value="${selectedValue || ''}">`;
            return html;
        }

        // Handle day selection
        function selectDay(pickerId, value) {
            // Update hidden input
            document.getElementById(pickerId).value = value;

            // Update button states
            const picker = document.getElementById(pickerId).previousElementSibling;
            picker.querySelectorAll('.day-picker-button').forEach(btn => {
                btn.classList.remove('selected');
            });

            // Find and select the clicked button
            const buttons = picker.querySelectorAll('.day-picker-button');
            buttons.forEach(btn => {
                if ((btn.textContent.trim() === String(value)) ||
                    (value === 'last' && btn.classList.contains('last-day'))) {
                    btn.classList.add('selected');
                }
            });
        }

        function renderTasks() {
            const tbody = document.getElementById('taskList');
            tbody.innerHTML = '';

            tasks.forEach((task, index) => {
                const tr = document.createElement('tr');
                tr.className = task.core ? 'task-row core' : 'task-row';

                let descText = task.description;
                if (task.name === 'Payroll Cut Off') {
                    descText = task.description;
                } else if (task.name === 'Pay Date') {
                    descText = 'From Pay Date Configuration (only moves for weekends/holidays)';
                } else if (task.beforePayDate) {
                    descText = task.offset === 0 ? 'Same day as Pay Date' : `${task.offset} working days before Pay Date`;
                } else if (task.offset === 0) {
                    descText = `Same day as ${index > 0 ? tasks[index - 1].name : 'previous task'}`;
                } else {
                    descText = `${task.offset} working days after ${index > 0 ? tasks[index - 1].name : 'previous task'}`;
                }

                const timeTooltip = task.dueTime ? `Due time: ${formatTimeDisplay(task.dueTime)}` : 'Set due time';

                tr.innerHTML = `
                    <td>
                        <div class="task-name-cell">
                            <span>${task.name}</span>
                        </div>
                    </td>
                    <td style="text-align: center;">
                        ${task.core ?
                            '<span style="color: var(--success-teal); font-size: 18px; font-weight: 700;">âœ“</span>' :
                            ''
                        }
                    </td>
                    <td>
                        <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <div style="flex: 0 0 auto;">
                                ${task.name === 'Pay Date' ?
                                    '<span style="color: var(--text-light); font-style: italic;">N/A</span>' :
                                    `<input type="number" class="task-offset-input" value="${task.offset}" min="0"
                                        onchange="updateTaskOffset(${index}, this.value)"
                                        ${task.name === 'Payroll Cut Off' ? 'disabled style="opacity: 0.5; cursor: not-allowed;" title="Cutoff is configured above"' : ''}>`
                                }
                            </div>
                            <button class="clock-icon-button ${task.dueTime ? 'has-time' : ''}"
                                    onclick="showTaskTimeModal(${index})"
                                    title="${timeTooltip}">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <polyline points="12 6 12 12 16 14"></polyline>
                                </svg>
                            </button>
                        </div>
                    </td>
                    <td style="color: var(--text-medium); font-size: 14px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span>${descText}</span>
                            ${task.canBeBeforePayDate ? `
                                <button class="secondary small" onclick="toggleBeforePayDate(${index})" style="white-space: nowrap;">
                                    ${task.beforePayDate ? 'â†“ After Previous' : 'â†‘ Before Pay Date'}
                                </button>
                            ` : ''}
                        </div>
                    </td>
                    <td>
                        ${task.deletable ? `
                            <div style="display: flex; align-items: center; justify-content: flex-end; gap: 16px; height: 100%;">
                                <button class="secondary small" onclick="editTask(${index})">Edit</button>
                                <button class="danger small" onclick="deleteTask(${index})">Delete</button>
                            </div>
                        ` : ''}
                    </td>
                `;

                tbody.appendChild(tr);
            });
        }

        function updateTaskOffset(index, newValue) {
            const value = parseInt(newValue);
            if (!isNaN(value) && value >= 0) {
                tasks[index].offset = value;
                renderTasks();
            }
        }

        function toggleBeforePayDate(index) {
            if (tasks[index].canBeBeforePayDate) {
                tasks[index].beforePayDate = !tasks[index].beforePayDate;
                renderTasks();
            }
        }

        function addTask() {
            const name = document.getElementById('newTaskName').value.trim();
            const offset = parseInt(document.getElementById('newTaskOffset').value);

            if (!name) {
                showMessage('Please enter a task name', 'error');
                return;
            }

            if (isNaN(offset) || offset < 0) {
                showMessage('Please enter a valid number of working days (0 or more)', 'error');
                return;
            }

            tasks.push({
                name,
                offset,
                fromPrevious: true,
                core: false,
                deletable: true,
                canBeBeforePayDate: false,
                beforePayDate: false,
                description: offset === 0 ? `Same day as ${tasks[tasks.length - 1].name}` : `${offset} working days after ${tasks[tasks.length - 1].name}`,
                dueTime: ''
            });

            renderTasks();
            document.getElementById('newTaskName').value = '';
            document.getElementById('newTaskOffset').value = '1';
            showMessage('Task added successfully', 'success');
        }

        function editTask(index) {
            const task = tasks[index];
            const newName = prompt('Enter new task name:', task.name);

            if (newName && newName.trim()) {
                tasks[index].name = newName.trim();
                renderTasks();
                showMessage('Task updated successfully', 'success');
            }
        }

        function deleteTask(index) {
            if (confirm('Are you sure you want to delete this task?')) {
                tasks.splice(index, 1);
                renderTasks();
                showMessage('Task deleted successfully', 'success');
            }
        }

        async function fetchBankHolidays(countryCode, year) {
            try {
                console.log(`ðŸŒ Fetching bank holidays for ${countryCode} in ${year}...`);
                const url = `https://date.nager.at/api/v3/PublicHolidays/${year}/${countryCode}`;
                console.log(`   URL: ${url}`);

                const response = await fetch(url);

                console.log(`   Response status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const holidays = await response.json();
                console.log(`   âœ… Fetched ${holidays.length} holidays for ${countryCode}`);

                return holidays.map(h => ({
                    date: h.date,
                    name: h.localName || h.name
                }));
            } catch (error) {
                console.error(`âŒ Error fetching holidays for ${countryCode}:`, error);

                // Provide specific guidance based on error type
                let errorMsg = `Warning: Could not fetch bank holidays for ${countryCode}.`;

                if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    errorMsg += ' This is likely due to CORS/network restrictions.';
                    if (window.location.protocol === 'file:') {
                        errorMsg += ' TIP: Some browsers block API requests when opening HTML files directly. Try using Chrome, or host the file on a web server.';
                    }
                } else {
                    errorMsg += ` Error: ${error.message}.`;
                }

                errorMsg += ' You can manually add holidays using the "Add Manual Bank Holiday" feature in the pay date override modal.';

                showMessage(errorMsg, 'warning');
                return [];
            }
        }

        function isWeekend(date, relevantCountries) {
            const day = date.getDay();

            // Check if this day is a weekend in ANY of the relevant countries
            for (const countryCode of relevantCountries) {
                const weekendDays = getCountryWeekendDays(countryCode);
                if (weekendDays.includes(day)) {
                    return true;
                }
            }

            return false;
        }

        function formatDateToString(date) {
            // Format date as YYYY-MM-DD without timezone conversion
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function isBankHoliday(date, countryCode) {
            const dateStr = formatDateToString(date);
            const holidayKey = `${countryCode}_${dateStr}`;

            // Check if this holiday is ignored
            if (ignoredHolidays.includes(holidayKey)) {
                return false;
            }

            return bankHolidays[countryCode]?.some(h => h.date === dateStr);
        }

        function getHolidayName(date, countryCode) {
            const dateStr = formatDateToString(date);
            const holiday = bankHolidays[countryCode]?.find(h => h.date === dateStr);
            return holiday ? holiday.name : '';
        }

        function isNonWorkingDay(date, relevantCountries) {
            for (const country of relevantCountries) {
                if (isBankHoliday(date, country)) return true;
            }
            return false;
        }

        function calculateWorkingDate(startDate, offset, direction, relevantCountries) {
            let current = new Date(startDate);
            let remainingDays = Math.abs(offset);
            const dir = direction === 'forward' ? 1 : -1;

            if (offset === 0) return current;

            while (remainingDays > 0) {
                current.setDate(current.getDate() + dir);
                const isWE = isWeekend(current, relevantCountries);
                const isNWD = isNonWorkingDay(current, relevantCountries);

                if (isNWD) {
                    // Log when skipping bank holidays
                    const dateStr = formatDateToString(current);
                    for (const country of relevantCountries) {
                        const holidayName = getHolidayName(current, country);
                        if (holidayName) {
                            console.log(`â­ï¸  Skipping bank holiday: ${dateStr} - ${holidayName} (${country})`);
                            break;
                        }
                    }
                }

                if (!isWE && !isNWD) {
                    remainingDays--;
                }
            }

            return current;
        }

        function countWorkingDaysBetween(startDate, endDate, relevantCountries) {
            let count = 0;
            let current = new Date(startDate);
            const end = new Date(endDate);

            while (current < end) {
                current.setDate(current.getDate() + 1);
                if (!isWeekend(current, relevantCountries) && !isNonWorkingDay(current, relevantCountries)) {
                    count++;
                }
            }

            return count;
        }

        function moveToPriorWorkingDay(date, relevantCountries) {
            let current = new Date(date);
            const original = new Date(date);
            let moveCount = 0;
            while (isWeekend(current, relevantCountries) || isNonWorkingDay(current, relevantCountries)) {
                current.setDate(current.getDate() - 1);
                moveCount++;
            }
            if (moveCount > 0) {
                console.log(`  Moved ${original.toDateString()} â†’ ${current.toDateString()} (${moveCount} days back)`);
            }
            return current;
        }

        function getPayDates(frequency, year, config, employeeCountryArray) {
            const payDates = [];

            if (frequency === 'monthly') {
                const dayOfMonth = config.payDayOfMonth;
                for (let month = 0; month < 12; month++) {
                    let payDate;
                    if (dayOfMonth === 'last') {
                        payDate = new Date(year, month + 1, 0);
                    } else {
                        const day = parseInt(dayOfMonth);
                        payDate = new Date(year, month, day);
                        if (payDate.getMonth() !== month) {
                            payDate = new Date(year, month + 1, 0);
                        }
                    }
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    payDate = moveToPriorWorkingDay(payDate, employeeCountryArray);
                    payDates.push({
                        date: payDate,
                        label: new Date(year, month, 1).toLocaleDateString('en-GB', { month: 'long' }),
                        month: month
                    });
                }
            } else if (frequency === 'semi-monthly') {
                const firstDay = parseInt(config.firstPayDay);
                const secondDay = config.secondPayDay;

                for (let month = 0; month < 12; month++) {
                    let payDate1 = new Date(year, month, firstDay);
                    if (payDate1.getMonth() !== month) {
                        payDate1 = new Date(year, month + 1, 0);
                    }
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    payDate1 = moveToPriorWorkingDay(payDate1, employeeCountryArray);

                    payDates.push({
                        date: payDate1,
                        label: `${new Date(year, month, 1).toLocaleDateString('en-GB', { month: 'long' })} P1`,
                        month: month,
                        periodInMonth: 1
                    });

                    let payDate2;
                    if (secondDay === 'last') {
                        payDate2 = new Date(year, month + 1, 0);
                    } else {
                        payDate2 = new Date(year, month, parseInt(secondDay));
                        if (payDate2.getMonth() !== month) {
                            payDate2 = new Date(year, month + 1, 0);
                        }
                    }
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    payDate2 = moveToPriorWorkingDay(payDate2, employeeCountryArray);

                    payDates.push({
                        date: payDate2,
                        label: `${new Date(year, month, 1).toLocaleDateString('en-GB', { month: 'long' })} P2`,
                        month: month,
                        periodInMonth: 2
                    });
                }
            } else if (frequency === 'bi-weekly' || frequency === 'weekly') {
                let currentDate = new Date(config.firstPayDate);
                const increment = frequency === 'bi-weekly' ? 14 : 7;
                let payPeriodNum = 1;

                while (currentDate.getFullYear() === year) {
                    let payDate = new Date(currentDate);
                    // Pay date only moves for weekends/holidays in EMPLOYEE country
                    payDate = moveToPriorWorkingDay(payDate, employeeCountryArray);
                    payDates.push({
                        date: payDate,
                        label: `Period ${payPeriodNum} (${payDate.toLocaleDateString('en-GB', { month: 'short', day: 'numeric' })})`,
                        month: payDate.getMonth()
                    });
                    currentDate.setDate(currentDate.getDate() + increment);
                    payPeriodNum++;
                }
            }

            return payDates;
        }

        function getCutoffDates(frequency, year, payDates, cutoffConfig, relevantCountries) {
            const cutoffDates = [];

            if (cutoffConfig.mode === 'offset') {
                payDates.forEach(payPeriod => {
                    const cutoffDate = calculateWorkingDate(
                        payPeriod.date,
                        cutoffConfig.offset || 10,
                        'backward',
                        relevantCountries
                    );
                    cutoffDates.push(cutoffDate);
                });
            } else {
                if (frequency === 'monthly') {
                    const dayOfMonth = cutoffConfig.cutoffDayOfMonth;
                    for (let month = 0; month < 12; month++) {
                        let cutoffDate = new Date(year, month, parseInt(dayOfMonth));
                        if (cutoffDate.getMonth() !== month) {
                            cutoffDate = new Date(year, month + 1, 0);
                        }
                        cutoffDate = moveToPriorWorkingDay(cutoffDate, relevantCountries);
                        cutoffDates.push(cutoffDate);
                    }
                } else if (frequency === 'semi-monthly') {
                    for (let month = 0; month < 12; month++) {
                        let cutoff1 = new Date(year, month, parseInt(cutoffConfig.cutoffFirstDay));
                        if (cutoff1.getMonth() !== month) {
                            cutoff1 = new Date(year, month + 1, 0);
                        }
                        cutoff1 = moveToPriorWorkingDay(cutoff1, relevantCountries);
                        cutoffDates.push(cutoff1);

                        let cutoff2 = new Date(year, month, parseInt(cutoffConfig.cutoffSecondDay));
                        if (cutoff2.getMonth() !== month) {
                            cutoff2 = new Date(year, month + 1, 0);
                        }
                        cutoff2 = moveToPriorWorkingDay(cutoff2, relevantCountries);
                        cutoffDates.push(cutoff2);
                    }
                } else {
                    payDates.forEach(payPeriod => {
                        const targetDay = parseInt(cutoffConfig.cutoffDayOfWeek);
                        let cutoffDate = new Date(payPeriod.date);

                        while (cutoffDate.getDay() !== targetDay || cutoffDate >= payPeriod.date) {
                            cutoffDate.setDate(cutoffDate.getDate() - 1);
                        }

                        cutoffDate = moveToPriorWorkingDay(cutoffDate, relevantCountries);
                        cutoffDates.push(cutoffDate);
                    });
                }
            }

            return cutoffDates;
        }

        async function generateCalendar(preserveCutoffs = false) {
            // Reset original cutoffs unless we're regenerating with overrides/ignores
            if (!preserveCutoffs) {
                originalCutoffDates = [];
                console.log('ðŸ”„ Reset original cutoffs (fresh generation)');
            }

            const clientName = document.getElementById('clientName').value.trim();
            const employeeCountry = document.getElementById('employeeCountry').value;
            const providerCountry = document.getElementById('providerCountry').value;
            const clientTeamCountry = document.getElementById('clientTeamCountry').value;
            const payFrequency = document.getElementById('payFrequency').value;
            const year = parseInt(document.getElementById('calendarYear').value);

            if (!clientName || !employeeCountry || !payFrequency) {
                showMessage('Please fill in all required fields (Client Name, Employee Country, Pay Frequency)', 'error');
                return;
            }

            let config = {};
            if (payFrequency === 'monthly') {
                config.payDayOfMonth = document.getElementById('payDayOfMonth')?.value;
                if (!config.payDayOfMonth) {
                    showMessage('Please select the pay day of month', 'error');
                    return;
                }
            } else if (payFrequency === 'semi-monthly') {
                config.firstPayDay = document.getElementById('firstPayDay')?.value;
                config.secondPayDay = document.getElementById('secondPayDay')?.value;
                if (!config.firstPayDay || !config.secondPayDay) {
                    showMessage('Please select both pay dates', 'error');
                    return;
                }
            } else if (payFrequency === 'bi-weekly' || payFrequency === 'weekly') {
                config.payDayOfWeek = document.getElementById('payDayOfWeek')?.value;
                config.firstPayDate = document.getElementById('firstPayDate')?.value;
                if (!config.payDayOfWeek || !config.firstPayDate) {
                    showMessage('Please select pay day and first pay date', 'error');
                    return;
                }
            }

            cutoffMode = document.querySelector('input[name="cutoffMode"]:checked')?.value || 'offset';
            cutoffConfig = { mode: cutoffMode };

            if (cutoffMode === 'offset') {
                const offsetValue = document.getElementById('cutoffDaysOffset')?.value;
                if (!offsetValue) {
                    showMessage('Please enter the cut-off days offset', 'error');
                    return;
                }
                cutoffConfig.offset = parseInt(offsetValue);
                tasks[0].offset = cutoffConfig.offset;
                tasks[0].description = `${cutoffConfig.offset} working days before Pay Date`;
            } else {
                if (payFrequency === 'monthly') {
                    cutoffConfig.cutoffDayOfMonth = document.getElementById('cutoffDayOfMonth')?.value;
                    if (!cutoffConfig.cutoffDayOfMonth) {
                        showMessage('Please select the cut-off day of month', 'error');
                        return;
                    }
                } else if (payFrequency === 'semi-monthly') {
                    cutoffConfig.cutoffFirstDay = document.getElementById('cutoffFirstDay')?.value;
                    cutoffConfig.cutoffSecondDay = document.getElementById('cutoffSecondDay')?.value;
                    if (!cutoffConfig.cutoffFirstDay || !cutoffConfig.cutoffSecondDay) {
                        showMessage('Please select both cut-off dates', 'error');
                        return;
                    }
                } else {
                    cutoffConfig.cutoffDayOfWeek = document.getElementById('cutoffDayOfWeek')?.value;
                    if (!cutoffConfig.cutoffDayOfWeek) {
                        showMessage('Please select the cut-off day of week', 'error');
                        return;
                    }
                }
                tasks[0].description = 'Specific date (see calendar)';
            }

            renderTasks();

            showMessage('Generating calendar... Fetching bank holidays...', 'loading');

            // Build list of countries to consider for bank holidays
            const countriesForHolidays = [employeeCountry]; // Employee country always included

            // Check if provider country is selected and if its holidays should impact
            const providerImpact = document.getElementById('providerCountryImpact')?.checked ?? true;
            if (providerCountry && providerImpact) {
                countriesForHolidays.push(providerCountry);
            }

            // Check if client team country is selected and if its holidays should impact
            const clientTeamImpact = document.getElementById('clientTeamCountryImpact')?.checked ?? true;
            if (clientTeamCountry && clientTeamImpact) {
                countriesForHolidays.push(clientTeamCountry);
            }

            const uniqueCountries = [...new Set(countriesForHolidays)];
            bankHolidays = {};

            for (const country of uniqueCountries) {
                bankHolidays[country] = await fetchBankHolidays(country, year);
            }

            // Pay dates only check employee country for weekends/holidays
            const payDates = getPayDates(payFrequency, year, config, [employeeCountry]);

            // Calculate cutoff dates - but reuse original cutoffs if they exist (prevents recalculation when manual holidays are added)
            let cutoffDates;
            if (originalCutoffDates.length === payDates.length) {
                // Reuse stored cutoff dates (manual holidays won't affect cutoff)
                cutoffDates = originalCutoffDates;
                console.log('â™»ï¸ Reusing original cutoff dates (manual holidays will not affect cutoff calculation)');
            } else {
                // Calculate fresh cutoff dates and store them
                cutoffDates = getCutoffDates(payFrequency, year, payDates, cutoffConfig, uniqueCountries);
                originalCutoffDates = cutoffDates.map(date => new Date(date)); // Store a copy
                console.log('ðŸ“… Calculated and stored original cutoff dates');
            }

            generatedCalendar = [];
            const periodManualHolidays = []; // Track manual holidays by period for proper cleanup

            payDates.forEach((payPeriod, periodIndex) => {
                let cutoffDate = cutoffDates[periodIndex];

                // Check if there's a cutoff override for this period
                if (cutoffOverrides[periodIndex]) {
                    cutoffDate = new Date(cutoffOverrides[periodIndex]);
                    console.log(`âœï¸ Cutoff override applied for period ${periodIndex}: ${cutoffDate.toDateString()}`);
                }

                // Check if there's a pay date override for this period
                let payDate = payPeriod.date;
                if (payDateOverrides[periodIndex]) {
                    payDate = new Date(payDateOverrides[periodIndex]);
                    console.log(`âœï¸ Pay date override applied for period ${periodIndex}: ${payDate.toDateString()}`);
                }

                // Add manual holiday for this period if one exists (temporarily, for this period's calculations only)
                let manualHolidayDateStr = null;
                if (manualHolidays[periodIndex]) {
                    const manualHoliday = manualHolidays[periodIndex];
                    manualHolidayDateStr = formatDateToString(manualHoliday.date);

                    // Add to employee country bank holidays (this affects working day calculations)
                    if (!bankHolidays[employeeCountry]) {
                        bankHolidays[employeeCountry] = [];
                    }

                    // Check if it's not already in the list
                    const exists = bankHolidays[employeeCountry].some(h => h.date === manualHolidayDateStr);
                    if (!exists) {
                        bankHolidays[employeeCountry].push({
                            date: manualHolidayDateStr,
                            localName: manualHoliday.name,
                            name: manualHoliday.name,
                            isManual: true // Flag to indicate this is a manually added holiday
                        });
                        // Track this for later
                        periodManualHolidays.push({
                            periodIndex,
                            dateStr: manualHolidayDateStr,
                            name: manualHoliday.name
                        });
                        console.log(`ðŸ–ï¸ Manual holiday added for period ${periodIndex}: ${manualHoliday.name} on ${manualHolidayDateStr}`);
                    }
                }

                // Calculate available working days between cut-off and pay date
                const availableWorkingDays = countWorkingDaysBetween(cutoffDate, payDate, uniqueCountries);

                // Calculate required working days (all intermediate tasks, NOT including Pay Date)
                // Pay Date is FIXED, so we only calculate offsets for tasks between cutoff and pay date
                let requiredDays = 0;
                for (let i = 1; i < tasks.length - 1; i++) {  // Exclude last task (Pay Date)
                    requiredDays += tasks[i].offset;
                }

                // Debug logging
                console.log(`Period ${periodIndex} (${payPeriod.label}):`, {
                    cutoffDate: cutoffDate.toDateString(),
                    payDate: payDate.toDateString(),
                    availableWorkingDays,
                    requiredDays,
                    taskOffsets: tasks.slice(1, -1).map((t) => `${t.name}: ${t.offset}`),
                    note: 'Pay Date is FIXED and not included in requiredDays calculation'
                });

                // Check if we need to adjust
                const needsAdjustment = requiredDays > availableWorkingDays;
                let adjustedOffsets = tasks.map(t => t.offset);
                let adjustedTasks = [];

                if (needsAdjustment) {
                    console.log(`âš ï¸ Adjustment needed! Shortage: ${requiredDays - availableWorkingDays} days`);

                    // Auto-adjust with priority: Payroll Sign-Off, Feedback from Client, Payroll Reports Due
                    // Each task has 1 working day removed at a time
                    const shortage = requiredDays - availableWorkingDays;
                    let remaining = shortage;

                    // Priority 1: Payroll Sign-Off Due (find by name)
                    const signOffIndex = tasks.findIndex(t => t.name === 'Payroll Sign-Off Due');
                    if (remaining > 0 && signOffIndex > 0 && tasks[signOffIndex].offset > 1) {
                        const reduce = Math.min(remaining, tasks[signOffIndex].offset - 1);
                        adjustedOffsets[signOffIndex] -= reduce;
                        remaining -= reduce;
                        if (reduce > 0) {
                            adjustedTasks.push(tasks[signOffIndex].name);
                            console.log(`  Reduced ${tasks[signOffIndex].name}: ${tasks[signOffIndex].offset} â†’ ${adjustedOffsets[signOffIndex]}`);
                        }
                    }

                    // Priority 2: Feedback from Client (find by name)
                    const feedbackIndex = tasks.findIndex(t => t.name === 'Feedback from Client');
                    if (remaining > 0 && feedbackIndex > 0 && tasks[feedbackIndex].offset > 1) {
                        const reduce = Math.min(remaining, tasks[feedbackIndex].offset - 1);
                        adjustedOffsets[feedbackIndex] -= reduce;
                        remaining -= reduce;
                        if (reduce > 0) {
                            adjustedTasks.push(tasks[feedbackIndex].name);
                            console.log(`  Reduced ${tasks[feedbackIndex].name}: ${tasks[feedbackIndex].offset} â†’ ${adjustedOffsets[feedbackIndex]}`);
                        }
                    }

                    // Priority 3: Payroll Reports Due (find by name)
                    const reportsIndex = tasks.findIndex(t => t.name === 'Payroll Reports Due');
                    if (remaining > 0 && reportsIndex > 0 && tasks[reportsIndex].offset > 1) {
                        const reduce = Math.min(remaining, tasks[reportsIndex].offset - 1);
                        adjustedOffsets[reportsIndex] -= reduce;
                        remaining -= reduce;
                        if (reduce > 0) {
                            adjustedTasks.push(tasks[reportsIndex].name);
                            console.log(`  Reduced ${tasks[reportsIndex].name}: ${tasks[reportsIndex].offset} â†’ ${adjustedOffsets[reportsIndex]}`);
                        }
                    }

                    if (remaining > 0) {
                        console.log(`âš ï¸ Still ${remaining} days short after all adjustments!`);
                    }
                }

                // Generate tasks with adjusted offsets
                let currentDate = new Date(cutoffDate);
                const periodTasks = [];

                periodTasks.push({
                    period: periodIndex,
                    periodLabel: payPeriod.label,
                    task: tasks[0].name,
                    date: new Date(cutoffDate),
                    month: payPeriod.month,
                    periodInMonth: payPeriod.periodInMonth,
                    adjusted: false
                });

                // First pass: Generate tasks that are calculated from previous (forward)
                // We'll handle "before pay date" tasks separately
                const taskDates = new Map();
                taskDates.set(0, new Date(cutoffDate));

                for (let i = 1; i < tasks.length - 1; i++) {
                    if (!tasks[i].beforePayDate) {
                        // Calculate forward from previous task
                        const offsetToUse = adjustedOffsets[i];
                        currentDate = calculateWorkingDate(currentDate, offsetToUse, 'forward', uniqueCountries);
                        taskDates.set(i, new Date(currentDate));
                    }
                }

                // Second pass: Generate tasks that are calculated before pay date (backward)
                for (let i = tasks.length - 2; i >= 1; i--) {
                    if (tasks[i].beforePayDate) {
                        // Calculate backward from pay date
                        const offsetToUse = adjustedOffsets[i];
                        const taskDate = calculateWorkingDate(payDate, offsetToUse, 'backward', uniqueCountries);
                        taskDates.set(i, new Date(taskDate));
                        console.log(`ðŸ“… ${tasks[i].name} calculated ${offsetToUse} working days before pay date: ${taskDate.toDateString()}`);
                    }
                }

                // Add all intermediate tasks to periodTasks
                for (let i = 1; i < tasks.length - 1; i++) {
                    periodTasks.push({
                        period: periodIndex,
                        periodLabel: payPeriod.label,
                        task: tasks[i].name,
                        date: taskDates.get(i),
                        month: payPeriod.month,
                        periodInMonth: payPeriod.periodInMonth,
                        adjusted: adjustedTasks.includes(tasks[i].name),
                        originalOffset: tasks[i].offset,
                        adjustedOffset: adjustedOffsets[i]
                    });
                }

                // PAY DATE: Always use the ORIGINAL pay date, never calculate it
                // The pay date only moves if it falls on a weekend/holiday (already handled in getPayDates)
                const lastTaskIndex = tasks.length - 1;
                periodTasks.push({
                    period: periodIndex,
                    periodLabel: payPeriod.label,
                    task: tasks[lastTaskIndex].name,
                    date: new Date(payDate),  // Use ORIGINAL pay date, not calculated
                    month: payPeriod.month,
                    periodInMonth: payPeriod.periodInMonth,
                    adjusted: false,  // Pay date never adjusted, it's fixed
                    originalOffset: tasks[lastTaskIndex].offset,
                    adjustedOffset: tasks[lastTaskIndex].offset
                });

                console.log(`âœ“ Pay Date set to original: ${payDate.toDateString()}`);

                generatedCalendar.push(...periodTasks);

                // IMPORTANT: Remove manual holiday immediately after processing this period
                // This prevents it from affecting subsequent periods
                if (manualHolidayDateStr) {
                    bankHolidays[employeeCountry] = bankHolidays[employeeCountry].filter(h => h.date !== manualHolidayDateStr);
                    console.log(`ðŸ§¹ Cleaned up manual holiday for period ${periodIndex} (prevents cross-period contamination)`);
                }
            });

            // Re-add all manual holidays before rendering so they show up in the UI
            if (periodManualHolidays.length > 0) {
                if (!bankHolidays[employeeCountry]) {
                    bankHolidays[employeeCountry] = [];
                }
                periodManualHolidays.forEach(mh => {
                    const exists = bankHolidays[employeeCountry].some(h => h.date === mh.dateStr);
                    if (!exists) {
                        bankHolidays[employeeCountry].push({
                            date: mh.dateStr,
                            localName: mh.name,
                            name: mh.name,
                            isManual: true
                        });
                    }
                });
                console.log(`ðŸ“Œ Re-added ${periodManualHolidays.length} manual holiday(ies) for UI rendering`);
            }

            renderCalendar(uniqueCountries, year, payFrequency);

            // DO NOT clean up manual holidays - they need to persist for Excel/PDF export
            // Duplicate prevention is handled in the re-add code above (checks if exists before adding)
            console.log(`âœ… Manual holidays kept in bankHolidays array for export functionality`);

            showMessage('Calendar generated successfully!', 'success');
        }

        function ignoreHoliday(holidayKey) {
            if (!ignoredHolidays.includes(holidayKey)) {
                ignoredHolidays.push(holidayKey);
            }
            // Regenerate calendar without ignored holidays
            generateCalendar(true); // Preserve cutoffs when ignoring holidays
        }

        function restoreHoliday(holidayKey) {
            const index = ignoredHolidays.indexOf(holidayKey);
            if (index > -1) {
                ignoredHolidays.splice(index, 1);
            }
            // Regenerate calendar with restored holiday
            generateCalendar(true); // Preserve cutoffs when restoring holidays
        }

        function renderCalendar(uniqueCountries, year, frequency) {
            const section = document.getElementById('calendarSection');
            const preview = document.getElementById('calendarPreview');

            if (generatedCalendar.length === 0) {
                section.classList.add('hidden');
                return;
            }

            section.classList.remove('hidden');

            const calendarByPeriod = {};
            generatedCalendar.forEach(entry => {
                if (!calendarByPeriod[entry.period]) {
                    calendarByPeriod[entry.period] = {
                        label: entry.periodLabel,
                        tasks: {},
                        holidays: [],
                        month: entry.month,
                        periodInMonth: entry.periodInMonth,
                        hasHolidayImpact: false,
                        hasAdjustment: false,
                        adjustedTasks: []
                    };
                }
                calendarByPeriod[entry.period].tasks[entry.task] = entry.date;

                if (entry.adjusted) {
                    calendarByPeriod[entry.period].hasAdjustment = true;
                    calendarByPeriod[entry.period].adjustedTasks.push({
                        name: entry.task,
                        originalOffset: entry.originalOffset,
                        adjustedOffset: entry.adjustedOffset
                    });
                }
            });

            // Assign holidays and check for impact
            uniqueCountries.forEach(country => {
                if (bankHolidays[country]) {
                    bankHolidays[country].forEach(holiday => {
                        const holidayDate = new Date(holiday.date);

                        Object.keys(calendarByPeriod).forEach(period => {
                            const periodData = calendarByPeriod[period];
                            const dates = Object.values(periodData.tasks);
                            const minDate = new Date(Math.min(...dates));
                            const maxDate = new Date(Math.max(...dates));

                            if (holidayDate >= minDate && holidayDate <= maxDate) {
                                const countryName = countries.find(c => c.code === country)?.name || country;
                                const dateStr = holidayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });

                                // Mark as impacted - any holiday in the period affects working day calculations
                                periodData.hasHolidayImpact = true;

                                // Add indicator if this is a manually added holiday
                                const manualIndicator = holiday.isManual ? ' [Manual]' : '';

                                periodData.holidays.push({
                                    date: holidayDate,
                                    countryCode: country,
                                    holidayKey: `${country}_${holiday.date}`,
                                    display: `${dateStr}: ${holiday.name} (${countryName})${manualIndicator}`,
                                    name: holiday.name,
                                    isManual: holiday.isManual || false
                                });
                            }
                        });
                    });
                }
            });

            Object.values(calendarByPeriod).forEach(periodData => {
                const uniqueHolidays = Array.from(new Set(periodData.holidays.map(h => h.display)))
                    .map(display => periodData.holidays.find(h => h.display === display));
                periodData.holidays = uniqueHolidays.sort((a, b) => a.date - b.date);
            });

            // Build table
            let html = '<table class="calendar-table"><thead><tr><th>Pay Period</th>';
            tasks.forEach(task => {
                html += `<th>${task.name}</th>`;
            });
            html += '<th>Bank Holidays During Payroll Processing</th></tr></thead><tbody>';

            Object.keys(calendarByPeriod).forEach(period => {
                const periodData = calendarByPeriod[period];
                const payDateTask = periodData.tasks['Pay Date'];
                const payDateStr = payDateTask ? formatDateToString(payDateTask) : '';

                const hasOverride = payDateOverrides[period] !== undefined;

                html += `<tr><td>
                    <div class="period-label">
                        ${periodData.hasHolidayImpact ? '<span class="holiday-indicator"></span>' : ''}
                        ${periodData.hasAdjustment ? '<span class="adjustment-indicator"></span>' : ''}
                        ${hasOverride ? '<span class="override-indicator" title="Pay date overridden">âœï¸</span>' : ''}
                        ${periodData.label}
                    </div>
                </td>`;

                tasks.forEach(task => {
                    const taskDate = periodData.tasks[task.name];
                    if (taskDate) {
                        const dateStr = taskDate.toLocaleDateString('en-GB', {
                            day: 'numeric',
                            month: 'short'
                        });
                        const dayName = taskDate.toLocaleDateString('en-GB', { weekday: 'short' });

                        // Format time display
                        const timeDisplay = task.dueTime ? `<span class="time-display" style="display: block; font-size: 11px; color: var(--text-medium); margin-top: 2px;">${formatTimeDisplay(task.dueTime)}</span>` : '';

                        // Add pencil icon to Pay Date column
                        if (task.name === 'Pay Date') {
                            html += `<td>
                                <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                                    <div>
                                        <span class="date-display">${dateStr}</span>
                                        <span class="day-display">${dayName}</span>
                                        ${timeDisplay}
                                    </div>
                                    <button class="icon-button" onclick="showPayDateOverride(${period}, '${payDateStr}')" title="Override pay date">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                        </svg>
                                    </button>
                                </div>
                            </td>`;
                        } else {
                            html += `<td>
                                <span class="date-display">${dateStr}</span>
                                <span class="day-display">${dayName}</span>
                                ${timeDisplay}
                            </td>`;
                        }
                    } else {
                        html += '<td>-</td>';
                    }
                });

                const holidaysList = periodData.holidays.map(h => {
                    const isIgnored = ignoredHolidays.includes(h.holidayKey);
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; ${isIgnored ? 'opacity: 0.5; text-decoration: line-through;' : ''}">
                            <span>${h.display}</span>
                            ${!isIgnored ?
                                `<button class="secondary small" style="margin-left: 8px; padding: 4px 8px; font-size: 11px;" onclick="ignoreHoliday('${h.holidayKey}')">Ignore</button>` :
                                `<button class="secondary small" style="margin-left: 8px; padding: 4px 8px; font-size: 11px;" onclick="restoreHoliday('${h.holidayKey}')">Restore</button>`
                            }
                        </div>
                    `;
                }).join('');

                // Add adjusted tasks information
                let adjustmentInfo = '';
                if (periodData.adjustedTasks && periodData.adjustedTasks.length > 0) {
                    adjustmentInfo = '<br><strong>âš ï¸ Adjusted Tasks:</strong><br>' +
                        periodData.adjustedTasks.map(adj =>
                            `${adj.name}: ${adj.originalOffset}â†’${adj.adjustedOffset} days`
                        ).join('<br>');
                }

                html += `<td>${holidaysList || '-'}${adjustmentInfo}</td></tr>`;
            });

            html += '</tbody></table>';
            preview.innerHTML = html;
        }

        function exportToXLSX() {
            try {
                if (generatedCalendar.length === 0) {
                    showMessage('Please generate a calendar first', 'error');
                    return;
                }

                if (typeof XLSX === 'undefined') {
                    showMessage('Excel library not loaded. Please refresh the page.', 'error');
                    return;
                }

                const clientName = document.getElementById('clientName').value.trim();
                const year = parseInt(document.getElementById('calendarYear').value);

                const calendarByPeriod = {};
            generatedCalendar.forEach(entry => {
                if (!calendarByPeriod[entry.period]) {
                    calendarByPeriod[entry.period] = {
                        label: entry.periodLabel,
                        tasks: {},
                        holidays: [],
                        month: entry.month,
                        periodInMonth: entry.periodInMonth,
                        hasHolidayImpact: false,
                        hasAdjustment: false,
                        adjustedTasks: []
                    };
                }
                calendarByPeriod[entry.period].tasks[entry.task] = entry.date;

                if (entry.adjusted) {
                    calendarByPeriod[entry.period].hasAdjustment = true;
                    calendarByPeriod[entry.period].adjustedTasks.push({
                        name: entry.task,
                        originalOffset: entry.originalOffset,
                        adjustedOffset: entry.adjustedOffset
                    });
                }
            });

            // Assign holidays to periods and check for impact
            const employeeCountry = document.getElementById('employeeCountry')?.value;
            const providerCountry = document.getElementById('providerCountry')?.value;
            const clientTeamCountry = document.getElementById('clientTeamCountry')?.value;

            const countriesForHolidays = [employeeCountry]; // Employee country always included

            // Check if provider country is selected and if its holidays should impact
            const providerImpact = document.getElementById('providerCountryImpact')?.checked ?? true;
            if (providerCountry && providerImpact) {
                countriesForHolidays.push(providerCountry);
            }

            // Check if client team country is selected and if its holidays should impact
            const clientTeamImpact = document.getElementById('clientTeamCountryImpact')?.checked ?? true;
            if (clientTeamCountry && clientTeamImpact) {
                countriesForHolidays.push(clientTeamCountry);
            }

            const uniqueCountries = [...new Set(countriesForHolidays)];

            uniqueCountries.forEach(country => {
                if (bankHolidays[country]) {
                    bankHolidays[country].forEach(holiday => {
                        const holidayDate = new Date(holiday.date);

                        Object.keys(calendarByPeriod).forEach(period => {
                            const periodData = calendarByPeriod[period];
                            const dates = Object.values(periodData.tasks);
                            const minDate = new Date(Math.min(...dates));
                            const maxDate = new Date(Math.max(...dates));

                            if (holidayDate >= minDate && holidayDate <= maxDate) {
                                const countryName = countries.find(c => c.code === country)?.name || country;
                                const dateStr = holidayDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });

                                // Mark as impacted - any holiday in the period affects working day calculations
                                periodData.hasHolidayImpact = true;

                                // Add indicator if this is a manually added holiday
                                const manualIndicator = holiday.isManual ? ' [Manual]' : '';

                                periodData.holidays.push({
                                    date: holidayDate,
                                    countryCode: country,
                                    holidayKey: `${country}_${holiday.date}`,
                                    display: `${dateStr}: ${holiday.name} (${countryName})${manualIndicator}`,
                                    name: holiday.name,
                                    isManual: holiday.isManual || false
                                });
                            }
                        });
                    });
                }
            });

            // Remove duplicate holidays
            Object.values(calendarByPeriod).forEach(periodData => {
                const uniqueHolidays = Array.from(new Set(periodData.holidays.map(h => h.display)))
                    .map(display => periodData.holidays.find(h => h.display === display));
                periodData.holidays = uniqueHolidays.sort((a, b) => a.date - b.date);
            });

            // Build data with separate indicator column - include time in header if present
            const tzAbbr = getTimezoneAbbr();
            const taskHeaders = tasks.map(t => {
                if (t.dueTime) {
                    const timeStr = formatTimeDisplay(t.dueTime);
                    return tzAbbr ? `${t.name} at ${timeStr} ${tzAbbr}` : `${t.name} at ${timeStr}`;
                }
                return t.name;
            });
            const data = [['Pay Period', 'Status', ...taskHeaders, 'Bank Holidays During Payroll Processing']];

            Object.keys(calendarByPeriod).forEach(period => {
                const periodData = calendarByPeriod[period];

                // Create status indicators
                let statusIndicators = [];
                if (periodData.hasHolidayImpact) {
                    statusIndicators.push('ðŸŸ¡ Holiday');
                }
                if (periodData.hasAdjustment) {
                    statusIndicators.push('ðŸŸ  Adjusted');
                }
                const statusText = statusIndicators.length > 0 ? statusIndicators.join('\n') : '-';

                const row = [periodData.label, statusText];

                tasks.forEach(task => {
                    const taskDate = periodData.tasks[task.name];
                    if (taskDate) {
                        // Format as "Thu, 27th Nov"
                        row.push(formatDateWithOrdinal(taskDate));
                    } else {
                        row.push('-');
                    }
                });

                // Add holidays column with adjustment info (excluding ignored holidays)
                const holidaysList = periodData.holidays
                    .filter(h => !ignoredHolidays.includes(h.holidayKey))
                    .map(h => h.display)
                    .join('\n');
                let adjustmentInfo = '';
                if (periodData.adjustedTasks && periodData.adjustedTasks.length > 0) {
                    adjustmentInfo = '\n\nâš ï¸ Adjusted Tasks:\n' +
                        periodData.adjustedTasks.map(adj =>
                            `${adj.name}: ${adj.originalOffset}â†’${adj.adjustedOffset} days`
                        ).join('\n');
                }
                row.push((holidaysList || '-') + adjustmentInfo);

                data.push(row);
            });

            const ws = XLSX.utils.aoa_to_sheet(data);

            // Style the header row with shading and bold
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const address = XLSX.utils.encode_col(C) + "1";
                if (!ws[address]) continue;

                const isFirstCol = (C === range.s.c);
                const isLastCol = (C === range.e.c);

                ws[address].s = {
                    font: {
                        bold: true,
                        color: { rgb: "FFFFFF" },
                        name: 'Arial',
                        size: 12
                    },
                    fill: {
                        fgColor: { rgb: "6B69D6" },
                        patternType: "solid"
                    },  // Purple shading for headers
                    alignment: {
                        horizontal: "center",
                        vertical: "center",
                        wrapText: true
                    },
                    border: {
                        top: { style: "medium", color: { rgb: "000000" } },
                        bottom: { style: "medium", color: { rgb: "000000" } },
                        left: isFirstCol ? { style: "medium", color: { rgb: "000000" } } : { style: "thin", color: { rgb: "D3D3D1" } },
                        right: { style: isLastCol ? "medium" : "thin", color: { rgb: isLastCol ? "000000" : "D3D3D1" } }
                    }
                };
            }

            // Style data rows with uniform styling
            const periodDataArray = Object.values(calendarByPeriod);
            for (let R = range.s.r + 1; R <= range.e.r; ++R) {
                const period = R - 1;
                const periodData = periodDataArray[period];
                if (!periodData) continue;

                const isLastRow = (R === range.e.r);

                for (let C = range.s.c; C <= range.e.c; ++C) {
                    const address = XLSX.utils.encode_col(C) + (R + 1);
                    if (!ws[address]) continue;

                    const isFirstCol = (C === range.s.c);
                    const isLastCol = (C === range.e.c);

                    // Uniform styling for all cells with solid white fill and vertical borders only
                    ws[address].s = {
                        alignment: {
                            horizontal: "center",
                            vertical: "center",
                            wrapText: true
                        },
                        font: {
                            name: 'Arial',
                            size: 11,
                            color: { rgb: "000000" }  // Explicit black text color for readability
                        },
                        fill: {
                            fgColor: { rgb: "FFFFFF" },
                            patternType: "solid"
                        },  // Solid white fill to hide gridlines
                        border: {
                            bottom: isLastRow ? { style: "medium", color: { rgb: "000000" } } : undefined,
                            left: isFirstCol ? { style: "medium", color: { rgb: "000000" } } : { style: "thin", color: { rgb: "D3D3D1" } },
                            right: { style: isLastCol ? "medium" : "thin", color: { rgb: isLastCol ? "000000" : "D3D3D1" } }
                        }
                    };

                    // First column (Pay Period) - left aligned, bold
                    if (C === 0) {
                        ws[address].s.alignment.horizontal = "left";
                        ws[address].s.font.bold = true;
                    }

                    // Second column (Status) - center aligned
                    if (C === 1) {
                        ws[address].s.alignment.horizontal = "center";
                        ws[address].s.alignment.vertical = "center";
                    }

                    // Last column (Bank Holidays During Payroll Processing) - left aligned
                    if (C === range.e.c) {
                        ws[address].s.alignment.horizontal = "left";
                        ws[address].s.alignment.vertical = "top";
                    }
                }
            }

            // Set column widths for uniform appearance
            ws['!cols'] = [
                { wch: 20 },  // Pay Period column
                { wch: 14 },  // Status column
                ...tasks.map(() => ({ wch: 18 })),  // Task columns (wider for "Thu, 27th Nov")
                { wch: 50 }  // Bank Holidays During Payroll Processing column
            ];

            // Set row heights
            ws['!rows'] = [{ hpt: 60 }]; // Header row (45 pixels)
            // Data rows: Let Excel auto-size based on content (especially for multi-line holidays column)

            // Fill cells outside the calendar content with solid white to hide gridlines
            const fillRows = 100; // Fill 100 rows beyond data
            const fillCols = 50; // Fill 50 columns beyond data
            const maxRow = range.e.r + fillRows;
            const maxCol = range.e.c + fillCols;

            for (let R = 0; R <= maxRow; R++) {
                for (let C = 0; C <= maxCol; C++) {
                    const address = XLSX.utils.encode_col(C) + (R + 1);
                    // Only fill cells that don't already have styling (outside calendar content)
                    if (!ws[address]) {
                        ws[address] = {
                            v: '',
                            t: 's',
                            s: {
                                fill: {
                                    fgColor: { rgb: "FFFFFF" },
                                    patternType: "solid"
                                }
                            }
                        };
                    }
                }
            }

            // Update the range to include filled cells
            ws['!ref'] = XLSX.utils.encode_range({
                s: { r: 0, c: 0 },
                e: { r: maxRow, c: maxCol }
            });

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Payroll Calendar");

                XLSX.writeFile(wb, `${clientName}_Payroll_Calendar_${year}.xlsx`, { cellStyles: true, bookType: 'xlsx' });
                showMessage('Calendar exported to Excel successfully!', 'success');
            } catch (error) {
                console.error('Excel export error:', error);
                showMessage('Failed to export to Excel: ' + error.message, 'error');
            }
        }

        function exportToPDF() {
            if (generatedCalendar.length === 0) {
                showMessage('Please generate a calendar first', 'error');
                return;
            }

            const clientName = document.getElementById('clientName').value.trim();
            const year = parseInt(document.getElementById('calendarYear').value);

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('l', 'mm', 'a4');

            // Title
            doc.setFontSize(20);
            doc.setTextColor(55, 53, 47);
            doc.text(`${clientName} - Payroll Calendar ${year}`, 15, 20);

            const calendarByPeriod = {};
            generatedCalendar.forEach(entry => {
                if (!calendarByPeriod[entry.period]) {
                    calendarByPeriod[entry.period] = {
                        label: entry.periodLabel,
                        tasks: {}
                    };
                }
                calendarByPeriod[entry.period].tasks[entry.task] = entry.date;
            });

            const tableData = [];
            Object.keys(calendarByPeriod).forEach(period => {
                const periodData = calendarByPeriod[period];
                const row = [periodData.label];

                tasks.forEach(task => {
                    const taskDate = periodData.tasks[task.name];
                    if (taskDate) {
                        row.push(taskDate.toLocaleDateString('en-GB', {
                            day: 'numeric',
                            month: 'short',
                            year: 'numeric'
                        }));
                    } else {
                        row.push('-');
                    }
                });

                tableData.push(row);
            });

            // Include time in PDF header if present
            const pdfTzAbbr = getTimezoneAbbr();
            const pdfTaskHeaders = tasks.map(t => {
                if (t.dueTime) {
                    const timeStr = formatTimeDisplay(t.dueTime);
                    return pdfTzAbbr ? `${t.name} at ${timeStr} ${pdfTzAbbr}` : `${t.name} at ${timeStr}`;
                }
                return t.name;
            });

            doc.autoTable({
                head: [['Pay Period', ...pdfTaskHeaders]],
                body: tableData,
                startY: 30,
                theme: 'grid',
                headStyles: {
                    fillColor: [55, 53, 47],
                    textColor: [255, 255, 255],
                    fontStyle: 'bold',
                    halign: 'center'
                },
                bodyStyles: {
                    textColor: [55, 53, 47]
                },
                alternateRowStyles: {
                    fillColor: [250, 250, 250]
                },
                columnStyles: {
                    0: { fontStyle: 'bold', fillColor: [250, 250, 250] }
                }
            });

            doc.save(`${clientName}_Payroll_Calendar_${year}.pdf`);
            showMessage('Calendar exported to PDF successfully!', 'success');
        }

        function saveConfiguration() {
            const clientName = document.getElementById('clientName').value.trim();
            const employeeCountry = document.getElementById('employeeCountry').value;
            const providerCountry = document.getElementById('providerCountry').value;
            const clientTeamCountry = document.getElementById('clientTeamCountry').value;
            const payFrequency = document.getElementById('payFrequency').value;
            const year = parseInt(document.getElementById('calendarYear').value);

            if (!clientName || !employeeCountry || !payFrequency) {
                showMessage('Please fill in all required fields (Client Name, Employee Country, Pay Frequency)', 'error');
                return;
            }

            let frequencyConfig = { type: payFrequency };
            if (payFrequency === 'monthly') {
                frequencyConfig.payDayOfMonth = document.getElementById('payDayOfMonth')?.value;
            } else if (payFrequency === 'semi-monthly') {
                frequencyConfig.firstPayDay = document.getElementById('firstPayDay')?.value;
                frequencyConfig.secondPayDay = document.getElementById('secondPayDay')?.value;
            } else if (payFrequency === 'bi-weekly' || payFrequency === 'weekly') {
                frequencyConfig.payDayOfWeek = document.getElementById('payDayOfWeek')?.value;
                frequencyConfig.firstPayDate = document.getElementById('firstPayDate')?.value;
            }

            const timezone = document.getElementById('calendarTimezone')?.value || '';

            const config = {
                id: Date.now(),
                clientName,
                employeeCountry,
                providerCountry,
                clientTeamCountry,
                payFrequency: frequencyConfig,
                cutoffConfig,
                year,
                timezone,
                tasks: tasks.filter(t => !t.core),
                taskOffsets: tasks.map(t => ({ name: t.name, offset: t.offset, dueTime: t.dueTime || '' })),
                savedDate: new Date().toISOString()
            };

            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            configs.push(config);
            localStorage.setItem('payrollConfigs', JSON.stringify(configs));

            loadSavedConfigurations();
            showMessage('Configuration saved successfully!', 'success');
        }

        function loadSavedConfigurations() {
            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            const container = document.getElementById('savedConfigs');

            if (configs.length === 0) {
                container.innerHTML = '<p style="color: var(--text-medium);">No saved configurations yet. Create one below!</p>';
                return;
            }

            container.innerHTML = '';

            configs.forEach(config => {
                const card = document.createElement('div');
                card.className = 'config-card';

                const countryName = countries.find(c => c.code === config.employeeCountry)?.name || config.employeeCountry;
                const freqType = config.payFrequency?.type || 'N/A';

                card.innerHTML = `
                    <h3>${config.clientName}</h3>
                    <p>ðŸŒ ${countryName}</p>
                    <p>ðŸ“… ${freqType}</p>
                    <p>ðŸ“† ${config.year}</p>
                    <div class="config-actions">
                        <button class="primary small" onclick="loadConfiguration(${config.id})">Load</button>
                        <button class="danger small" onclick="deleteConfiguration(${config.id})">Delete</button>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function loadConfiguration(id) {
            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            const config = configs.find(c => c.id === id);

            if (!config) return;

            document.getElementById('clientName').value = config.clientName;
            document.getElementById('employeeCountry').value = config.employeeCountry;
            document.getElementById('providerCountry').value = config.providerCountry;
            document.getElementById('clientTeamCountry').value = config.clientTeamCountry;
            document.getElementById('calendarYear').value = config.year;
            document.getElementById('calendarTimezone').value = config.timezone || '';

            const freqConfig = config.payFrequency || {};
            document.getElementById('payFrequency').value = freqConfig.type || '';
            updatePayDateConfig();

            setTimeout(() => {
                if (freqConfig.type === 'monthly') {
                    document.getElementById('payDayOfMonth').value = freqConfig.payDayOfMonth || '';
                } else if (freqConfig.type === 'semi-monthly') {
                    document.getElementById('firstPayDay').value = freqConfig.firstPayDay || '';
                    document.getElementById('secondPayDay').value = freqConfig.secondPayDay || '';
                } else if (freqConfig.type === 'bi-weekly' || freqConfig.type === 'weekly') {
                    document.getElementById('payDayOfWeek').value = freqConfig.payDayOfWeek || '';
                    document.getElementById('firstPayDate').value = freqConfig.firstPayDate || '';
                }

                if (config.cutoffConfig) {
                    cutoffConfig = config.cutoffConfig;
                    const modeRadio = document.getElementById(cutoffConfig.mode === 'date' ? 'cutoffByDate' : 'cutoffByOffset');
                    if (modeRadio) {
                        modeRadio.checked = true;
                        updateCutoffMode();

                        setTimeout(() => {
                            if (cutoffConfig.mode === 'offset') {
                                document.getElementById('cutoffDaysOffset').value = cutoffConfig.offset || 10;
                            }
                        }, 100);
                    }
                }
            }, 100);

            tasks = [...JSON.parse(JSON.stringify(defaultTasks))];
            if (config.taskOffsets) {
                config.taskOffsets.forEach((savedTask, i) => {
                    if (tasks[i]) {
                        tasks[i].offset = savedTask.offset;
                        tasks[i].dueTime = savedTask.dueTime || '';
                    }
                });
            }
            if (config.tasks) {
                tasks.push(...config.tasks);
            }

            renderTasks();
            showMessage('Configuration loaded successfully!', 'success');
        }

        function deleteConfiguration(id) {
            if (!confirm('Are you sure you want to delete this configuration?')) return;

            const configs = JSON.parse(localStorage.getItem('payrollConfigs') || '[]');
            const filtered = configs.filter(c => c.id !== id);
            localStorage.setItem('payrollConfigs', JSON.stringify(filtered));

            loadSavedConfigurations();
            showMessage('Configuration deleted', 'success');
        }

        function resetForm() {
            if (!confirm('Are you sure? This will clear all unsaved data.')) return;

            document.getElementById('clientName').value = '';
            document.getElementById('employeeCountry').value = '';
            document.getElementById('providerCountry').value = '';
            document.getElementById('clientTeamCountry').value = '';
            document.getElementById('payFrequency').value = '';
            document.getElementById('calendarYear').value = new Date().getFullYear();
            document.getElementById('calendarTimezone').value = '';

            updatePayDateConfig();

            tasks = JSON.parse(JSON.stringify(defaultTasks));
            cutoffConfig = { mode: 'offset', offset: 10 };
            renderTasks();

            generatedCalendar = [];
            document.getElementById('calendarSection').classList.add('hidden');

            showMessage('Form reset successfully', 'success');
        }

        function showMessage(text, type) {
            const messageDiv = document.getElementById('message');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;

            if (type !== 'loading') {
                setTimeout(() => {
                    messageDiv.className = 'message hidden';
                }, 5000);
            }
        }

        function showPayDateOverride(periodIndex, currentPayDate) {
            // Ensure periodIndex is a number
            periodIndex = parseInt(periodIndex);

            const modal = document.getElementById('payDateOverrideModal');
            const input = document.getElementById('overridePayDateInput');
            const cutoffInput = document.getElementById('overrideCutoffInput');
            const periodLabel = document.getElementById('overridePeriodLabel');
            const removeBtn = document.getElementById('removeOverrideBtn');

            // Find the period label and cutoff date from generated calendar
            const periodEntry = generatedCalendar.find(e => e.period === periodIndex);
            if (periodEntry) {
                periodLabel.textContent = periodEntry.periodLabel;

                // Find the cutoff task for this period
                const cutoffTask = generatedCalendar.find(e => e.period === periodIndex && e.task === 'Payroll Cut Off');
                if (cutoffTask && cutoffTask.date) {
                    cutoffInput.value = formatDateForInput(cutoffTask.date);
                }
            }

            input.value = currentPayDate;
            input.dataset.periodIndex = periodIndex;

            // Reset cutoff editor to collapsed state
            const cutoffSection = document.getElementById('cutoffEditorSection');
            const cutoffToggleIcon = document.getElementById('cutoffEditorToggleIcon');
            cutoffSection.style.display = 'none';
            cutoffToggleIcon.textContent = 'â–¶';

            // Reset bank holiday editor to collapsed state and populate if manual holiday exists
            const bankHolidaySection = document.getElementById('bankHolidayEditorSection');
            const bankHolidayToggleIcon = document.getElementById('bankHolidayEditorToggleIcon');
            const manualHolidayDateInput = document.getElementById('manualHolidayDate');
            const manualHolidayNameInput = document.getElementById('manualHolidayName');

            bankHolidaySection.style.display = 'none';
            bankHolidayToggleIcon.textContent = 'â–¶';

            // Populate manual holiday if one exists for this period
            if (manualHolidays[periodIndex]) {
                manualHolidayDateInput.value = formatDateForInput(manualHolidays[periodIndex].date);
                manualHolidayNameInput.value = manualHolidays[periodIndex].name;
            } else {
                manualHolidayDateInput.value = '';
                manualHolidayNameInput.value = '';
            }

            // Show/hide remove button based on whether there's an override
            const hasOverride = payDateOverrides[periodIndex] !== undefined ||
                               cutoffOverrides[periodIndex] !== undefined ||
                               manualHolidays[periodIndex] !== undefined;
            removeBtn.style.display = hasOverride ? 'inline-block' : 'none';

            modal.style.display = 'flex';
        }

        function toggleCutoffEditor() {
            const section = document.getElementById('cutoffEditorSection');
            const icon = document.getElementById('cutoffEditorToggleIcon');

            if (section.style.display === 'none') {
                section.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                section.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }

        function toggleBankHolidayEditor() {
            const section = document.getElementById('bankHolidayEditorSection');
            const icon = document.getElementById('bankHolidayEditorToggleIcon');

            if (section.style.display === 'none') {
                section.style.display = 'block';
                icon.textContent = 'â–¼';
            } else {
                section.style.display = 'none';
                icon.textContent = 'â–¶';
            }
        }

        function closePayDateOverride() {
            const modal = document.getElementById('payDateOverrideModal');
            const cutoffSection = document.getElementById('cutoffEditorSection');
            const cutoffToggleIcon = document.getElementById('cutoffEditorToggleIcon');
            const bankHolidaySection = document.getElementById('bankHolidayEditorSection');
            const bankHolidayToggleIcon = document.getElementById('bankHolidayEditorToggleIcon');

            // Reset the cutoff editor section
            cutoffSection.style.display = 'none';
            cutoffToggleIcon.textContent = 'â–¶';

            // Reset the bank holiday editor section
            bankHolidaySection.style.display = 'none';
            bankHolidayToggleIcon.textContent = 'â–¶';

            modal.style.display = 'none';
        }

        function applyPayDateOverride() {
            const payDateInput = document.getElementById('overridePayDateInput');
            const cutoffInput = document.getElementById('overrideCutoffInput');
            const periodIndex = parseInt(payDateInput.dataset.periodIndex);
            const newPayDate = payDateInput.value;
            const newCutoff = cutoffInput.value;

            if (!newPayDate) {
                showMessage('Please select a new pay date', 'error');
                return;
            }

            // Store the pay date override
            payDateOverrides[periodIndex] = new Date(newPayDate);

            // Handle cutoff override
            const cutoffSection = document.getElementById('cutoffEditorSection');
            const isCutoffSectionExpanded = cutoffSection.style.display !== 'none';

            if (isCutoffSectionExpanded) {
                // User has expanded the cutoff section
                if (newCutoff) {
                    // Store the cutoff override
                    cutoffOverrides[periodIndex] = new Date(newCutoff);
                } else {
                    // User cleared the cutoff field, remove any existing override
                    delete cutoffOverrides[periodIndex];
                }
            }
            // If cutoff section was never expanded, leave existing override unchanged

            // Handle manual bank holiday
            const bankHolidaySection = document.getElementById('bankHolidayEditorSection');
            const isBankHolidaySectionExpanded = bankHolidaySection.style.display !== 'none';

            if (isBankHolidaySectionExpanded) {
                const manualHolidayDate = document.getElementById('manualHolidayDate').value;
                const manualHolidayName = document.getElementById('manualHolidayName').value;

                if (manualHolidayDate && manualHolidayName) {
                    // Store the manual holiday
                    manualHolidays[periodIndex] = {
                        date: new Date(manualHolidayDate),
                        name: manualHolidayName
                    };
                } else if (!manualHolidayDate && !manualHolidayName) {
                    // Both fields cleared, remove manual holiday
                    delete manualHolidays[periodIndex];
                }
            }
            // If bank holiday section was never expanded, leave existing manual holiday unchanged

            // Close modal
            closePayDateOverride();

            // Regenerate calendar with overrides (preserve cutoffs)
            generateCalendar(true);

            showMessage('Override applied successfully', 'success');
        }

        function removePayDateOverride(periodIndex) {
            delete payDateOverrides[periodIndex];
            delete cutoffOverrides[periodIndex];
            delete manualHolidays[periodIndex];
            generateCalendar(true); // Preserve cutoffs when removing override
        }

        function formatDateForInput(date) {
            // Convert Date to YYYY-MM-DD format for date input
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatTimeDisplay(time24) {
            // Convert 24-hour time (HH:MM) to 12-hour format with am/pm
            if (!time24) return '';

            const [hours, minutes] = time24.split(':');
            const hour = parseInt(hours);
            const ampm = hour >= 12 ? 'pm' : 'am';
            const hour12 = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);

            return `${hour12}:${minutes}${ampm}`;
        }

        // Task Time Modal Functions
        let currentTaskIndex = null;

        function showTaskTimeModal(taskIndex) {
            currentTaskIndex = taskIndex;
            const task = tasks[taskIndex];

            const modal = document.getElementById('taskTimeModal');
            const label = document.getElementById('taskTimeLabel');
            const input = document.getElementById('taskTimeInput');
            const clearBtn = document.getElementById('clearTimeBtn');

            label.textContent = task.name;
            input.value = task.dueTime || '';

            // Show/hide clear button based on whether there's a time set
            clearBtn.style.display = task.dueTime ? 'inline-block' : 'none';

            modal.style.display = 'flex';
        }

        function closeTaskTimeModal() {
            const modal = document.getElementById('taskTimeModal');
            modal.style.display = 'none';
            currentTaskIndex = null;
        }

        function saveTaskTime() {
            if (currentTaskIndex === null) return;

            const input = document.getElementById('taskTimeInput');
            const newTime = input.value;

            tasks[currentTaskIndex].dueTime = newTime || '';

            closeTaskTimeModal();
            renderTasks();
        }

        function clearTaskTime() {
            if (currentTaskIndex === null) return;

            tasks[currentTaskIndex].dueTime = '';

            closeTaskTimeModal();
            renderTasks();
        }

        function getTimezoneAbbr() {
            const timezone = document.getElementById('calendarTimezone')?.value || '';
            if (!timezone) return '';

            // Map of timezone to abbreviation
            const tzMap = {
                'UTC': 'UTC',
                'America/New_York': 'ET',
                'America/Chicago': 'CT',
                'America/Denver': 'MT',
                'America/Los_Angeles': 'PT',
                'Europe/London': 'GMT',
                'Europe/Paris': 'CET',
                'Europe/Berlin': 'CET',
                'Asia/Dubai': 'GST',
                'Asia/Singapore': 'SGT',
                'Asia/Hong_Kong': 'HKT',
                'Asia/Tokyo': 'JST',
                'Australia/Sydney': 'AEDT'
            };

            return tzMap[timezone] || '';
        }

        window.onload = init;
    </script>

    <!-- Pay Date Override Modal -->
    <div id="payDateOverrideModal" class="modal-overlay" style="display: none;">
        <div class="modal">
            <h3>Override Pay Date</h3>
            <p style="color: var(--text-medium); margin-bottom: 20px;">
                Period: <strong id="overridePeriodLabel"></strong>
            </p>
            <div class="form-group">
                <label for="overridePayDateInput">New Pay Date</label>
                <input type="date" id="overridePayDateInput" style="width: 100%;">
                <span class="help-text">Task dates will be adjusted to fit the new pay date while maintaining the cut-off date (unless you also edit cut-off below).</span>
            </div>

            <!-- Advanced option to also edit cutoff -->
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-light);">
                <a href="#"
                   id="showCutoffEditor"
                   onclick="toggleCutoffEditor(); return false;"
                   style="color: var(--text-medium); font-size: 13px; text-decoration: none; display: inline-flex; align-items: center; gap: 6px;">
                    <span id="cutoffEditorToggleIcon">â–¶</span>
                    <span>Advanced: Also edit Payroll Cut-Off</span>
                </a>

                <div id="cutoffEditorSection" style="display: none; margin-top: 12px;">
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="overrideCutoffInput">New Cut-Off Date</label>
                        <input type="date" id="overrideCutoffInput" style="width: 100%;">
                        <span class="help-text">Task dates will be recalculated from this cut-off using working day offsets.</span>
                    </div>
                </div>
            </div>

            <!-- Advanced option to add manual bank holiday -->
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-light);">
                <a href="#"
                   id="showBankHolidayEditor"
                   onclick="toggleBankHolidayEditor(); return false;"
                   style="color: var(--text-medium); font-size: 13px; text-decoration: none; display: inline-flex; align-items: center; gap: 6px;">
                    <span id="bankHolidayEditorToggleIcon">â–¶</span>
                    <span>Advanced: Add Manual Bank Holiday</span>
                </a>

                <div id="bankHolidayEditorSection" style="display: none; margin-top: 12px;">
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label for="manualHolidayDate">Bank Holiday Date</label>
                        <input type="date" id="manualHolidayDate" style="width: 100%;">
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label for="manualHolidayName">Holiday Name</label>
                        <input type="text" id="manualHolidayName" placeholder="e.g., Company Holiday" style="width: 100%;">
                        <span class="help-text">Add a bank holiday that wasn't automatically detected. This will affect working day calculations for this period.</span>
                    </div>
                </div>
            </div>

            <div class="modal-buttons" style="justify-content: space-between; margin-top: 20px;">
                <button id="removeOverrideBtn" class="danger" onclick="removePayDateOverride(parseInt(document.getElementById('overridePayDateInput').dataset.periodIndex)); closePayDateOverride();" style="display: none;">
                    Remove Override
                </button>
                <div style="display: flex; gap: 12px;">
                    <button class="secondary" onclick="closePayDateOverride()">Cancel</button>
                    <button class="primary" onclick="applyPayDateOverride()">Apply Override</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Time Modal -->
    <div id="taskTimeModal" class="modal-overlay" style="display: none;">
        <div class="modal" style="max-width: 400px;">
            <h3>Set Due Time</h3>
            <p style="color: var(--text-medium); margin-bottom: 20px;">
                Task: <strong id="taskTimeLabel"></strong>
            </p>
            <div class="form-group">
                <label for="taskTimeInput">Due Time (Optional)</label>
                <input type="time" id="taskTimeInput" style="width: 100%; padding: 8px 12px; font-size: 14px;">
                <span class="help-text">Select a specific time when this task is due.</span>
            </div>

            <div class="modal-buttons" style="justify-content: space-between; margin-top: 20px;">
                <button id="clearTimeBtn" class="secondary" onclick="clearTaskTime()" style="display: none;">
                    Clear Time
                </button>
                <div style="display: flex; gap: 12px; margin-left: auto;">
                    <button class="secondary" onclick="closeTaskTimeModal()">Cancel</button>
                    <button class="primary" onclick="saveTaskTime()">Save</button>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
